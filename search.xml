<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++ 基础]]></title>
    <url>%2F2018%2F07%2F22%2FC-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基础特性C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性： 封装 抽象 继承 多态 标准库标准的 C++ 由三个重要部分组成： 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等。 标准模板库（STL），提供了大量的方法，用于操作数据结构等。 语法C++ 基本语法 对象 类 方法 即时变量 三字符组三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。 三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。 C++ 数据类型基本的内置类型 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 一些基本类型可以使用一个或多个类型修饰符进行修饰： signed unsigned short long typedef 声明可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法： typedef type newname; 枚举类型枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。 如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。 创建枚举，需要使用关键字 enum。枚举类型的一般形式为： 1234567enum 枚举名&#123; 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数]&#125; 枚举变量; C++ 变量类型C++ 中的变量定义变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示： type variable_list; type 必须是一个有效的 C++ 数据类型 C++ 中的变量声明变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。 C++ 修饰符类型C++ 允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。 下面列出了数据类型修饰符： signed unsigned long short C++ 存储类存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类： auto register static extern mutable thread_local (C++11) 从 C++ 11 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。 extern 存储类extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。 thread_local 存储类使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。thread_local 说明符可以与 static 或 extern 合并。可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。 C++ 循环循环类型C++ 编程语言提供了以下几种循环类型。 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件 for 循环 多次执行一个语句序列，简化管理循环变量的代码 do…while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似 嵌套循环 可以在 while、for 或 do..while 循环内使用一个或多个循环 循环控制语句循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。 C++ 提供了下列的控制语句。 循环类型 描述 break 语句 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 continue 语句 引起循环跳过主体的剩余部分，立即重新开始测试条件。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 C++ 函数函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat() 用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。函数还有很多叫法，比如方法、子例程或程序，等等。 在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分： 返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。 函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。 参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 函数主体：函数主体包含一组定义函数执行任务的语句。 函数参数如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。当调用函数时，有两种向函数传递参数的方式： 调用类型 描述 传值调用 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 指针调用 该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 引用调用 该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 Lambda 函数与表达式C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。 C++ 数组C++ 数组C++ 支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。 数组的声明并不是声明一个个单独的变量，比如 number0、number1、…、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。 所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素 声明数组在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示： type arrayName [ arraySize ]; 初始化数组在 C++ 中，可以逐个初始化数组，也可以使用一个初始化语句，如下所示：double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0}; 大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。如果省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0}; 创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：balance[4] = 50.0; 上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示： 访问数组元素 数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如： double salary = balance[9]; C++ 中数组详解 概念 描述 多维数组 C++ 支持多维数组。多维数组最简单的形式是二维数组。 指向数组的指针 可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 传递数组给函数 可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 从函数返回数组 C++ 允许从函数返回数组。 C++ 字符串C++ 提供了以下两种类型的字符串表示形式： C 风格字符串 C++ 引入的 string 类类型 C 风格字符串C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 null 字符 ‘\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 下面的声明和初始化创建了一个 “Hello” 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 “Hello” 的字符数多一个。 char greeting[6] = {&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\0&#39;}; 依据数组初始化规则，可以把上面的语句写成以下语句： char greeting[] = &quot;Hello&quot;; 以下是 C/C++ 中定义的字符串的内存表示： C++ 中有大量的函数用来操作以 null 结尾的字符串：supports a wide range of functions that manipulate null-terminated strings: 序号 函数 &amp; 目的 1 strcpy(s1, s2);复制字符串 s2 到字符串 s1。 2 strcat(s1, s2);连接字符串 s2 到字符串 s1 的末尾。 3 strlen(s1);返回字符串 s1 的长度。 4 strcmp(s1, s2);如果 s1 和 s2 是相同的，则返回 0；如果 s1s2 则返回值大于 0。 5 strchr(s1, ch);返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2);返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 C++ 中的 String 类C++ 标准库提供了 string 类类型，支持上述所有的操作，另外还增加了其他更多的功能。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; int main ()&#123; string str1 = "Hello"; string str2 = "World"; string str3; int len ; // 复制 str1 到 str3 str3 = str1; cout &lt;&lt; "str3 : " &lt;&lt; str3 &lt;&lt; endl; // 连接 str1 和 str2 str3 = str1 + str2; cout &lt;&lt; "str1 + str2 : " &lt;&lt; str3 &lt;&lt; endl; // 连接后，str3 的总长度 len = str3.size(); cout &lt;&lt; "str3.size() : " &lt;&lt; len &lt;&lt; endl; return 0;&#125; 结果： 十C++ 指针通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。 每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址 什么是指针？指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为： type *var-name; 在这里，type 是指针的基类型，它必须是一个有效的 C++ 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明： 1234int *ip; /* 一个整型的指针 */double *dp; /* 一个 double 型的指针 */float *fp; /* 一个浮点型的指针 */char *ch; /* 一个字符型的指针 */ 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。 C++ 中使用指针使用指针时会频繁进行以下几个操作： 定义一个指针变量、 把变量地址赋值给指针、 访问指针变量中可用地址的值。 这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main ()&#123; int var = 20; // 实际变量的声明 int *ip; // 指针变量的声明 ip = &amp;var; // 在指针变量中存储 var 的地址 cout &lt;&lt; "变量值: "; cout &lt;&lt; var &lt;&lt; endl; // 输出在指针变量中存储的地址 cout &lt;&lt; "变量地址 "; cout &lt;&lt; ip &lt;&lt; endl; // 访问指针中地址的值 cout &lt;&lt; "指针中地址的值: "; cout &lt;&lt; *ip &lt;&lt; endl; return 0;&#125; C++ 指针详解在 C++ 中，有很多指针相关的概念，这些概念都很简单，但是都很重要. 概念 描述 C++ Null 指针 C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 C++ 指针的算术运算 可以对指针进行四种算术运算：++、–、+、- C++ 指针 vs 数组 指针和数组之间有着密切的关系。 C++ 指针数组 可以定义用来存储指针的数组。 C++ 指向指针的指针 C++ 允许指向指针的指针。 C++ 传递指针给函数 通过引用或地址传递参数，使传递的参数在调用函数中被改变。 C++ 从函数返回指针 C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。 十C++ 引用引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 C++ 引用 vs 指针引用很容易与指针混淆，它们之间有三个主要的不同： 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 C++ 中创建引用变量名称是变量附属在内存位置中的标签，可以把引用当成是变量附属在内存位置中的第二个标签。因此可以通过原始变量名称或引用来访问变量的内容 引用通常用于函数参数列表和函数返回值。引用相关的重要概念： 概念 描述 把引用作为参数 C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 把引用作为返回值 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。 十 C++ 日期 &amp; 时间C++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 头文件。 有四个与时间相关的类型：clock_t、time_t、size_t 和 tm。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。 结构类型 tm 把日期和时间以 C 结构的形式保存，tm 结构的定义如下： 1234567891011struct tm &#123; int tm_sec; // 秒，正常范围从 0 到 59，但允许至 61 int tm_min; // 分，范围从 0 到 59 int tm_hour; // 小时，范围从 0 到 23 int tm_mday; // 一月中的第几天，范围从 1 到 31 int tm_mon; // 月，范围从 0 到 11 int tm_year; // 自 1900 年起的年数 int tm_wday; // 一周中的第几天，范围从 0 到 6，从星期日算起 int tm_yday; // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起 int tm_isdst; // 夏令时&#125; 下面是 C/C++ 中关于日期和时间的重要函数。所有这些函数都是 C/C++ 标准库的组成部分 序号 函数 &amp; 描述 1 time_t time(time_t *time);该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 .1。 2 char ctime(const time_t time);该返回一个表示当地时间的字符串指针，字符串形式 day month year hours:minutes:seconds year\n\0。 3 struct tm localtime(const time_t time);该函数返回一个指向表示本地时间的 tm 结构的指针。 4 clock_t clock(void);该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 .1。 5 char asctime ( const struct tm time );该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\n\0。 6 struct tm gmtime(const time_t time);该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 7 time_t mktime(struct tm *time);该函数返回日历时间，相当于 time 所指向结构中存储的时间。 8 double difftime ( time_t time2, time_t time1 );该函数返回 time1 和 time2 之间相差的秒数。 9 size_t strftime();该函数可用于格式化日期和时间为指定的格式。 当前日期和时间123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;ctime&gt; using namespace std; int main( )&#123; // 基于当前系统的当前日期/时间 time_t now = time(0); // 把 now 转换为字符串形式 char* dt = ctime(&amp;now); cout &lt;&lt; "本地日期和时间：" &lt;&lt; dt &lt;&lt; endl; // 把 now 转换为 tm 结构 tm *gmtm = gmtime(&amp;now); dt = asctime(gmtm); cout &lt;&lt; "UTC 日期和时间："&lt;&lt; dt &lt;&lt; endl;&#125; 使用结构 tm 格式化时间tm 结构在 C/C++ 中处理日期和时间相关的操作时，显得尤为重要。tm 结构以 C 结构的形式保存日期和时间。大多数与时间相关的函数都使用了 tm 结构。下面的实例使用了 tm 结构和各种与日期和时间相关的函数。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;ctime&gt; using namespace std; int main( )&#123; // 基于当前系统的当前日期/时间 time_t now = time(0); cout &lt;&lt; "1970 到目前经过秒数:" &lt;&lt; now &lt;&lt; endl; tm *ltm = localtime(&amp;now); // 输出 tm 结构的各个组成部分 cout &lt;&lt; "年: "&lt;&lt; 1900 + ltm-&gt;tm_year &lt;&lt; endl; cout &lt;&lt; "月: "&lt;&lt; 1 + ltm-&gt;tm_mon&lt;&lt; endl; cout &lt;&lt; "日: "&lt;&lt; ltm-&gt;tm_mday &lt;&lt; endl; cout &lt;&lt; "时间: "&lt;&lt; ltm-&gt;tm_hour &lt;&lt; ":"; cout &lt;&lt; ltm-&gt;tm_min &lt;&lt; ":"; cout &lt;&lt; ltm-&gt;tm_sec &lt;&lt; endl;&#125; 十 C++ 基本的输入输出C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。 I/O 库头文件 头文件 函数和描述 &lt;iostream&gt; 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 &lt;iomanip&gt; 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。 &lt;fstream&gt; 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 标准输出流（cout）定义的对象 cout 是 iostream 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与流插入运算符 &lt;&lt; 结合使用的 C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。流插入运算符 &lt;&lt; 在一个语句中可以多次使用 标准输入流（cin）预定义的对象 cin 是 iostream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 &gt;&gt; 结合使用的 标准错误流（cerr）预定义的对象 cerr 是 iostream 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。cerr 也是与流插入运算符 &lt;&lt; 结合使用的 标准日志流（clog）定义的对象 clog 是 iostream 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。clog 也是与流插入运算符 &lt;&lt; 结合使用的 我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出 十 C++ 数据结构C/C++ 数组允许定义可存储相同类型数据项的变量，但是结构是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。结构用于表示一条记录。 定义结构为了定义结构，必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下： 12345678struct type_name &#123;member_type1 member_name1;member_type2 member_name2;member_type3 member_name3;..&#125; object_names; type_name 是结构体类型的名称 member_type1 member_name1 是标准的变量定义，比如 int i; 或者 float f;或者其他有效的变量定义。 在结构定义的末尾，最后一个分号之前，可以指定一个或多个结构变量，这是可选的 访问结构成员为了访问结构的成员，使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。 结构作为函数参数可以把结构作为函数参数，传参方式与其他类型的变量或指针类似 实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstring&gt; using namespace std; // 声明一个结构体类型 Books struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;; int main( )&#123; Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, "C++ 教程"); strcpy( Book1.author, "ycp"); strcpy( Book1.subject, "编程语言"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, "CSS 教程"); strcpy( Book2.author, "ycp"); strcpy( Book2.subject, "前端技术"); Book2.book_id = 12346; // 输出 Book1 信息 cout &lt;&lt; "第一本书标题 : " &lt;&lt; Book1.title &lt;&lt;endl; cout &lt;&lt; "第一本书作者 : " &lt;&lt; Book1.author &lt;&lt;endl; cout &lt;&lt; "第一本书类目 : " &lt;&lt; Book1.subject &lt;&lt;endl; cout &lt;&lt; "第一本书 ID : " &lt;&lt; Book1.book_id &lt;&lt;endl; // 输出 Book2 信息 cout &lt;&lt; "第二本书标题 : " &lt;&lt; Book2.title &lt;&lt;endl; cout &lt;&lt; "第二本书作者 : " &lt;&lt; Book2.author &lt;&lt;endl; cout &lt;&lt; "第二本书类目 : " &lt;&lt; Book2.subject &lt;&lt;endl; cout &lt;&lt; "第二本书 ID : " &lt;&lt; Book2.book_id &lt;&lt;endl; return 0;&#125; 结构作为函数参数以把结构作为函数参数，传参方式与其他类型的变量或指针类似 实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstring&gt; using namespace std;void printBook( struct Books book ); // 声明一个结构体类型 Books struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;; int main( )&#123; Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, "C++ 教程"); strcpy( Book1.author, "ycp"); strcpy( Book1.subject, "编程语言"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, "CSS 教程"); strcpy( Book2.author, "ycp"); strcpy( Book2.subject, "前端技术"); Book2.book_id = 12346; // 输出 Book1 信息 printBook( Book1 ); // 输出 Book2 信息 printBook( Book2 ); return 0;&#125;void printBook( struct Books book )&#123; cout &lt;&lt; "书标题 : " &lt;&lt; book.title &lt;&lt;endl; cout &lt;&lt; "书作者 : " &lt;&lt; book.author &lt;&lt;endl; cout &lt;&lt; "书类目 : " &lt;&lt; book.subject &lt;&lt;endl; cout &lt;&lt; "书 ID : " &lt;&lt; book.book_id &lt;&lt;endl;&#125; 指向结构的指针可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示： struct Books *struct_pointer; 现在，可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，把 &amp; 运算符放在结构名称的前面，如下所示： struct_pointer = &amp;Book1; 为了使用指向该结构的指针访问结构的成员，必须使用 -&gt; 运算符，如下所示： struct_pointer-&gt;title; 重写上面的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstring&gt; using namespace std;void printBook( struct Books *book ); struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;; int main( )&#123; Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, "C++ 教程"); strcpy( Book1.author, "ycp"); strcpy( Book1.subject, "编程语言"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, "CSS 教程"); strcpy( Book2.author, "ycp"); strcpy( Book2.subject, "前端技术"); Book2.book_id = 12346; // 通过传 Book1 的地址来输出 Book1 信息 printBook( &amp;Book1 ); // 通过传 Book2 的地址来输出 Book2 信息 printBook( &amp;Book2 ); return 0;&#125;// 该函数以结构指针作为参数void printBook( struct Books *book )&#123; cout &lt;&lt; "书标题 : " &lt;&lt; book-&gt;title &lt;&lt;endl; cout &lt;&lt; "书作者 : " &lt;&lt; book-&gt;author &lt;&lt;endl; cout &lt;&lt; "书类目 : " &lt;&lt; book-&gt;subject &lt;&lt;endl; cout &lt;&lt; "书 ID : " &lt;&lt; book-&gt;book_id &lt;&lt;endl;&#125; typedef 关键字下面是一种更简单的定义结构的方式，可以为创建的类型取一个”别名”。例如：1234567typedef struct&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;Books; 现在，可以直接使用 Books 来定义 Books 类型的变量，而不需要使用 struct 关键字。下面是实例： Books Book1, Book2; 基础特性C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性： 封装 抽象 继承 多态 标准库标准的 C++ 由三个重要部分组成： 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等。 标准模板库（STL），提供了大量的方法，用于操作数据结构等。 语法C++ 基本语法 对象 类 方法 即时变量 三字符组三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。 三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。 C++ 数据类型基本的内置类型 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 一些基本类型可以使用一个或多个类型修饰符进行修饰： signed unsigned short long typedef 声明可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法： typedef type newname; 枚举类型枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。 如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。 创建枚举，需要使用关键字 enum。枚举类型的一般形式为： 1234567enum 枚举名&#123; 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数]&#125; 枚举变量; C++ 变量类型C++ 中的变量定义变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示： type variable_list; type 必须是一个有效的 C++ 数据类型 C++ 中的变量声明变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。 C++ 修饰符类型C++ 允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。 下面列出了数据类型修饰符： signed unsigned long short C++ 存储类存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类： auto register static extern mutable thread_local (C++11) 从 C++ 11 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。 extern 存储类extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。 thread_local 存储类使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。thread_local 说明符可以与 static 或 extern 合并。可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。 C++ 循环#####循环类型 C++ 编程语言提供了以下几种循环类型。 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件 for 循环 多次执行一个语句序列，简化管理循环变量的代码 do…while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似 嵌套循环 可以在 while、for 或 do..while 循环内使用一个或多个循环 循环控制语句循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。 C++ 提供了下列的控制语句。 循环类型 描述 break 语句 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 continue 语句 引起循环跳过主体的剩余部分，立即重新开始测试条件。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 C++ 函数函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat() 用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。函数还有很多叫法，比如方法、子例程或程序，等等。 在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分： 返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。 函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。 参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 函数主体：函数主体包含一组定义函数执行任务的语句。 函数参数如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。当调用函数时，有两种向函数传递参数的方式： 调用类型 描述 传值调用 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 指针调用 该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 引用调用 该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 Lambda 函数与表达式C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。 C++ 数组#####C++ 数组 C++ 支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。 数组的声明并不是声明一个个单独的变量，比如 number0、number1、…、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。 所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素 声明数组在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示： type arrayName [ arraySize ]; 初始化数组在 C++ 中，可以逐个初始化数组，也可以使用一个初始化语句，如下所示：double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0}; 大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。如果省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0}; 创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：balance[4] = 50.0; 上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示： 访问数组元素 数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如： double salary = balance[9]; C++ 中数组详解 概念 描述 多维数组 C++ 支持多维数组。多维数组最简单的形式是二维数组。 指向数组的指针 可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 传递数组给函数 可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 从函数返回数组 C++ 允许从函数返回数组。 C++ 字符串C++ 提供了以下两种类型的字符串表示形式： C 风格字符串 C++ 引入的 string 类类型 C 风格字符串C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 null 字符 ‘\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 下面的声明和初始化创建了一个 “Hello” 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 “Hello” 的字符数多一个。 char greeting[6] = {&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\0&#39;}; 依据数组初始化规则，可以把上面的语句写成以下语句： char greeting[] = &quot;Hello&quot;; 以下是 C/C++ 中定义的字符串的内存表示： C++ 中有大量的函数用来操作以 null 结尾的字符串：supports a wide range of functions that manipulate null-terminated strings: 序号 函数 &amp; 目的 1 strcpy(s1, s2);复制字符串 s2 到字符串 s1。 2 strcat(s1, s2);连接字符串 s2 到字符串 s1 的末尾。 3 strlen(s1);返回字符串 s1 的长度。 4 strcmp(s1, s2);如果 s1 和 s2 是相同的，则返回 0；如果 s1s2 则返回值大于 0。 5 strchr(s1, ch);返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2);返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 C++ 中的 String 类C++ 标准库提供了 string 类类型，支持上述所有的操作，另外还增加了其他更多的功能。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; int main ()&#123; string str1 = "Hello"; string str2 = "World"; string str3; int len ; // 复制 str1 到 str3 str3 = str1; cout &lt;&lt; "str3 : " &lt;&lt; str3 &lt;&lt; endl; // 连接 str1 和 str2 str3 = str1 + str2; cout &lt;&lt; "str1 + str2 : " &lt;&lt; str3 &lt;&lt; endl; // 连接后，str3 的总长度 len = str3.size(); cout &lt;&lt; "str3.size() : " &lt;&lt; len &lt;&lt; endl; return 0;&#125; 结果： C++ 指针通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。 每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址 什么是指针？指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为： type *var-name; 在这里，type 是指针的基类型，它必须是一个有效的 C++ 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明： 1234int *ip; /* 一个整型的指针 */double *dp; /* 一个 double 型的指针 */float *fp; /* 一个浮点型的指针 */char *ch; /* 一个字符型的指针 */ 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。 C++ 中使用指针使用指针时会频繁进行以下几个操作： 定义一个指针变量、 把变量地址赋值给指针、 访问指针变量中可用地址的值。 这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main ()&#123; int var = 20; // 实际变量的声明 int *ip; // 指针变量的声明 ip = &amp;var; // 在指针变量中存储 var 的地址 cout &lt;&lt; "变量值: "; cout &lt;&lt; var &lt;&lt; endl; // 输出在指针变量中存储的地址 cout &lt;&lt; "变量地址 "; cout &lt;&lt; ip &lt;&lt; endl; // 访问指针中地址的值 cout &lt;&lt; "指针中地址的值: "; cout &lt;&lt; *ip &lt;&lt; endl; return 0;&#125; C++ 指针详解在 C++ 中，有很多指针相关的概念，这些概念都很简单，但是都很重要. 概念 描述 C++ Null 指针 C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 C++ 指针的算术运算 可以对指针进行四种算术运算：++、–、+、- C++ 指针 vs 数组 指针和数组之间有着密切的关系。 C++ 指针数组 可以定义用来存储指针的数组。 C++ 指向指针的指针 C++ 允许指向指针的指针。 C++ 传递指针给函数 通过引用或地址传递参数，使传递的参数在调用函数中被改变。 C++ 从函数返回指针 C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。 C++ 引用引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 C++ 引用 vs 指针引用很容易与指针混淆，它们之间有三个主要的不同： 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 C++ 中创建引用变量名称是变量附属在内存位置中的标签，可以把引用当成是变量附属在内存位置中的第二个标签。因此可以通过原始变量名称或引用来访问变量的内容 引用通常用于函数参数列表和函数返回值。引用相关的重要概念： 概念 描述 把引用作为参数 C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 把引用作为返回值 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。 C++ 日期 &amp; 时间C++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 头文件。 有四个与时间相关的类型：clock_t、time_t、size_t 和 tm。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。 结构类型 tm 把日期和时间以 C 结构的形式保存，tm 结构的定义如下： 1234567891011struct tm &#123; int tm_sec; // 秒，正常范围从 0 到 59，但允许至 61 int tm_min; // 分，范围从 0 到 59 int tm_hour; // 小时，范围从 0 到 23 int tm_mday; // 一月中的第几天，范围从 1 到 31 int tm_mon; // 月，范围从 0 到 11 int tm_year; // 自 1900 年起的年数 int tm_wday; // 一周中的第几天，范围从 0 到 6，从星期日算起 int tm_yday; // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起 int tm_isdst; // 夏令时&#125; 下面是 C/C++ 中关于日期和时间的重要函数。所有这些函数都是 C/C++ 标准库的组成部分 序号 函数 &amp; 描述 1 time_t time(time_t *time);该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 .1。 2 char ctime(const time_t time);该返回一个表示当地时间的字符串指针，字符串形式 day month year hours:minutes:seconds year\n\0。 3 struct tm localtime(const time_t time);该函数返回一个指向表示本地时间的 tm 结构的指针。 4 clock_t clock(void);该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 .1。 5 char asctime ( const struct tm time );该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\n\0。 6 struct tm gmtime(const time_t time);该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 7 time_t mktime(struct tm *time);该函数返回日历时间，相当于 time 所指向结构中存储的时间。 8 double difftime ( time_t time2, time_t time1 );该函数返回 time1 和 time2 之间相差的秒数。 9 size_t strftime();该函数可用于格式化日期和时间为指定的格式。 当前日期和时间123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;ctime&gt; using namespace std; int main( )&#123; // 基于当前系统的当前日期/时间 time_t now = time(0); // 把 now 转换为字符串形式 char* dt = ctime(&amp;now); cout &lt;&lt; "本地日期和时间：" &lt;&lt; dt &lt;&lt; endl; // 把 now 转换为 tm 结构 tm *gmtm = gmtime(&amp;now); dt = asctime(gmtm); cout &lt;&lt; "UTC 日期和时间："&lt;&lt; dt &lt;&lt; endl;&#125; 使用结构 tm 格式化时间tm 结构在 C/C++ 中处理日期和时间相关的操作时，显得尤为重要。tm 结构以 C 结构的形式保存日期和时间。大多数与时间相关的函数都使用了 tm 结构。下面的实例使用了 tm 结构和各种与日期和时间相关的函数。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;ctime&gt; using namespace std; int main( )&#123; // 基于当前系统的当前日期/时间 time_t now = time(0); cout &lt;&lt; "1970 到目前经过秒数:" &lt;&lt; now &lt;&lt; endl; tm *ltm = localtime(&amp;now); // 输出 tm 结构的各个组成部分 cout &lt;&lt; "年: "&lt;&lt; 1900 + ltm-&gt;tm_year &lt;&lt; endl; cout &lt;&lt; "月: "&lt;&lt; 1 + ltm-&gt;tm_mon&lt;&lt; endl; cout &lt;&lt; "日: "&lt;&lt; ltm-&gt;tm_mday &lt;&lt; endl; cout &lt;&lt; "时间: "&lt;&lt; ltm-&gt;tm_hour &lt;&lt; ":"; cout &lt;&lt; ltm-&gt;tm_min &lt;&lt; ":"; cout &lt;&lt; ltm-&gt;tm_sec &lt;&lt; endl;&#125; C++ 基本的输入输出C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。 I/O 库头文件 头文件 函数和描述 &lt;iostream&gt; 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 &lt;iomanip&gt; 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。 &lt;fstream&gt; 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 标准输出流（cout）定义的对象 cout 是 iostream 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与流插入运算符 &lt;&lt; 结合使用的 C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。流插入运算符 &lt;&lt; 在一个语句中可以多次使用 标准输入流（cin）预定义的对象 cin 是 iostream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 &gt;&gt; 结合使用的 标准错误流（cerr）预定义的对象 cerr 是 iostream 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。cerr 也是与流插入运算符 &lt;&lt; 结合使用的 标准日志流（clog）定义的对象 clog 是 iostream 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。clog 也是与流插入运算符 &lt;&lt; 结合使用的 我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出 C++ 数据结构C/C++ 数组允许定义可存储相同类型数据项的变量，但是结构是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。结构用于表示一条记录。 定义结构为了定义结构，必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下： 12345678struct type_name &#123;member_type1 member_name1;member_type2 member_name2;member_type3 member_name3;..&#125; object_names; type_name 是结构体类型的名称 member_type1 member_name1 是标准的变量定义，比如 int i; 或者 float f;或者其他有效的变量定义。 在结构定义的末尾，最后一个分号之前，可以指定一个或多个结构变量，这是可选的 访问结构成员为了访问结构的成员，使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。 结构作为函数参数可以把结构作为函数参数，传参方式与其他类型的变量或指针类似 实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstring&gt; using namespace std; // 声明一个结构体类型 Books struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;; int main( )&#123; Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, "C++ 教程"); strcpy( Book1.author, "ycp"); strcpy( Book1.subject, "编程语言"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, "CSS 教程"); strcpy( Book2.author, "ycp"); strcpy( Book2.subject, "前端技术"); Book2.book_id = 12346; // 输出 Book1 信息 cout &lt;&lt; "第一本书标题 : " &lt;&lt; Book1.title &lt;&lt;endl; cout &lt;&lt; "第一本书作者 : " &lt;&lt; Book1.author &lt;&lt;endl; cout &lt;&lt; "第一本书类目 : " &lt;&lt; Book1.subject &lt;&lt;endl; cout &lt;&lt; "第一本书 ID : " &lt;&lt; Book1.book_id &lt;&lt;endl; // 输出 Book2 信息 cout &lt;&lt; "第二本书标题 : " &lt;&lt; Book2.title &lt;&lt;endl; cout &lt;&lt; "第二本书作者 : " &lt;&lt; Book2.author &lt;&lt;endl; cout &lt;&lt; "第二本书类目 : " &lt;&lt; Book2.subject &lt;&lt;endl; cout &lt;&lt; "第二本书 ID : " &lt;&lt; Book2.book_id &lt;&lt;endl; return 0;&#125; 结构作为函数参数以把结构作为函数参数，传参方式与其他类型的变量或指针类似 实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstring&gt; using namespace std;void printBook( struct Books book ); // 声明一个结构体类型 Books struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;; int main( )&#123; Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, "C++ 教程"); strcpy( Book1.author, "ycp"); strcpy( Book1.subject, "编程语言"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, "CSS 教程"); strcpy( Book2.author, "ycp"); strcpy( Book2.subject, "前端技术"); Book2.book_id = 12346; // 输出 Book1 信息 printBook( Book1 ); // 输出 Book2 信息 printBook( Book2 ); return 0;&#125;void printBook( struct Books book )&#123; cout &lt;&lt; "书标题 : " &lt;&lt; book.title &lt;&lt;endl; cout &lt;&lt; "书作者 : " &lt;&lt; book.author &lt;&lt;endl; cout &lt;&lt; "书类目 : " &lt;&lt; book.subject &lt;&lt;endl; cout &lt;&lt; "书 ID : " &lt;&lt; book.book_id &lt;&lt;endl;&#125; 指向结构的指针可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示： struct Books *struct_pointer; 现在，可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，把 &amp; 运算符放在结构名称的前面，如下所示： struct_pointer = &amp;Book1; 为了使用指向该结构的指针访问结构的成员，必须使用 -&gt; 运算符，如下所示： struct_pointer-&gt;title; 重写上面的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstring&gt; using namespace std;void printBook( struct Books *book ); struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;; int main( )&#123; Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, "C++ 教程"); strcpy( Book1.author, "ycp"); strcpy( Book1.subject, "编程语言"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, "CSS 教程"); strcpy( Book2.author, "ycp"); strcpy( Book2.subject, "前端技术"); Book2.book_id = 12346; // 通过传 Book1 的地址来输出 Book1 信息 printBook( &amp;Book1 ); // 通过传 Book2 的地址来输出 Book2 信息 printBook( &amp;Book2 ); return 0;&#125;// 该函数以结构指针作为参数void printBook( struct Books *book )&#123; cout &lt;&lt; "书标题 : " &lt;&lt; book-&gt;title &lt;&lt;endl; cout &lt;&lt; "书作者 : " &lt;&lt; book-&gt;author &lt;&lt;endl; cout &lt;&lt; "书类目 : " &lt;&lt; book-&gt;subject &lt;&lt;endl; cout &lt;&lt; "书 ID : " &lt;&lt; book-&gt;book_id &lt;&lt;endl;&#125; typedef 关键字下面是一种更简单的定义结构的方式，可以为创建的类型取一个”别名”。例如：1234567typedef struct&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;Books; 现在，可以直接使用 Books 来定义 Books 类型的变量，而不需要使用 struct 关键字。下面是实例： Books Book1, Book2; 可以使用 typedef 关键字来定义非结构类型，如下所示：typedef long int *pint32; pint32 x, y, z; x, y 和 z 都是指向长整型 long int 的指针。可以使用 typedef 关键字来定义非结构类型，如下所示：typedef long int *pint32; pint32 x, y, z; x, y 和 z 都是指向长整型 long int 的指针。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel中的服务容器]]></title>
    <url>%2F2018%2F07%2F16%2Flaravel%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[控制反转（IoC）和依赖注入（DI）几乎所有php框架，或者对php程序来说，都是单一入口，都是以index.php开始的。那么laravel的入口文件都干了些什么事呢？ IoC 容器 —— Laravel 的核心laravel 的请求生命周期几乎所有php框架，或者对php程序来说，都是单一入口，都是以index.php开始的。那么laravel的 入口文件都干了些什么事呢？ 所有请求通过web服务器（apapache/nignx）引导至 public/index.php。 第一件事就是从bootstrap/app.php脚本中检索laravel应用程序的实例。 引入app.php（创建一个新的应用）$app = require_once __DIR__.&#39;/../bootstrap/app.php&#39;; app.php文件当中，第一件事就是创建一个新的实例; $app = new Illuminate\Foundation\Application( realpath(__DIR__.&#39;/../&#39;) ); 实例化Application 123456789101112131415 class Application extends Container implements ApplicationContract, HttpKernelInterface&#123; public function __construct($basePath = null) &#123; if ($basePath) &#123; $this-&gt;setBasePath($basePath); &#125; $this-&gt;registerBaseBindings(); $this-&gt;registerBaseServiceProviders(); $this-&gt;registerCoreContainerAliases(); &#125;&#125; 实例化的时候干了4件事 绑定当前实例路径 注册基本绑定 注册所有基本服务提供者 注册所有核心依赖到容器中 (2)将重要的接口绑定到容器12345678910111213$app-&gt;singleton( Illuminate\Contracts\Http\Kernel::class, App\Http\Kernel::class);$app-&gt;singleton( Illuminate\Contracts\Console\Kernel::class, App\Console\Kernel::class);$app-&gt;singleton( Illuminate\Contracts\Debug\ExceptionHandler::class, App\Exceptions\Handler::class); 绑定单例到容器（http,kernel,debug） (3)返回应用程序(当前实例)启动应用程序$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class); 这里 Illuminate\Contracts\Http\Kernel::class只是一个接口，这里的$app-&gt;make() 这里有深入研究 Laravel 执行流程（五）之 认识 Make 简单来说就是从容器中解析给定的类型。那么这行代码可以理解为实例化位于app/Http/Kernel.php这个类。 HTTP／控制器内核所有请求都会Http的核心类（kernel）中的handle方法处理 这个handle方法长这个样子 1234567891011121314151617181920212223public function handle($request) &#123; try &#123; $request-&gt;enableHttpMethodParameterOverride(); $response = $this-&gt;sendRequestThroughRouter($request); &#125; catch (Exception $e) &#123; $this-&gt;reportException($e); $response = $this-&gt;renderException($request, $e); &#125; catch (Throwable $e) &#123; $this-&gt;reportException($e = new FatalThrowableError($e)); $response = $this-&gt;renderException($request, $e); &#125; $this-&gt;app['events']-&gt;dispatch( new Events\RequestHandled($request, $response) ); return $response; &#125; 简单来说就是创建了一个新的HTTP内核实例，并且实例化了一些重要的组件 应用程序的请求类型将传入的请求发送到 HTTP 内核或控制台内核。而这两个内核是用来作为所 有请求都要通过的中心位置。一个处理http请求，一个处理控制台请求。我们一般用到的是HTTP 内核。 $response = $kernel-&gt;handle( $request = Illuminate\Http\Request::capture() );实例化了kernel传入了请求类 1234class Request extends SymfonyRequest implements Arrayable, ArrayAccess&#123;&#125; 继承了symfony的Request然后实现了一些接口。 从请求入口后面就可以开始处理自己业务逻辑了 返回$response-&gt;send(); 服务容器与服务提供器服务提供器 最重要的内核引导操作之一是加载应用程序的 服务提供器。应用程序的所有服务提供器都在 config/app.php 配置文件的 providers 数组中配置。首先，所有提供器都会调用 register 方法，接着，由 boot 方法负责调用所有被注册提供器。 服务提供器负责引导所有框架的各种组件，如数据库、队列、验证和路由组件。也就是说，框架提供的每个功能都它们来引导并配置。因此也可以说，服务提供器是整个 Laravel 引导过程中最重要的方面。 简单来说就是在容器中注册需要的类 服务容器服务容器通过构造函数或者某些情况下通过 set 方法将类依赖注入到类中。说得专业点就是用于管理类依赖和执行依赖注入的强大工具 依赖注入与控制反转 我的理解：当一个类A需要实例化另一个类B，我们不在类A里面实例化，让其他类(专门的)来实例化,这个就叫控制反转。那怎么把实例化的类B放到类A,可以通过构造函数,或者set方法注入，这个就叫依赖注入。 在php当中一般使用类型提示注入依赖，比如管理员控制器需要注入，角色和权限 1234567891011class AdminController extends controller&#123; protected $user; protected $role; public function __construct(UserServices $userServices,RoleServices $roleServices) &#123; $this-&gt;user=$userServices; $this-&gt;role=$roleServices; &#125; &#125; 这里的UserService,RoleServices为接口 在laravel中服务容器有一个强大的功能，就是将接口绑定到给定实现。如果需要用到服务容器，一般是注入接口，如果不是就接口，也就没有必要使用了。直接注入就行了，可以使用Repository模式，事实证明，服务容器很麻烦，如果不是超大型项目，根本没有必要使用。 Laravel 的核心就是一个 IoC 容器，高级的IOC容器，他会根据类的依赖需求，自动在注册、绑定的一堆实例中搜寻符合的依赖需求，并自动注入到构造函数参数中去。这种自动搜寻依赖需求的功能，是通过反射（Reflection）实现的。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>IOC</tag>
        <tag>依赖注入</tag>
        <tag>控制反转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel 技巧总结]]></title>
    <url>%2F2018%2F07%2F16%2Flaravel-%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一些使用laravel时用到的一些小技巧建立文件夹，放在app目录下，比如：然后再 conposer.json文件中的自动加载项加入你添加的自定义文件： 添加自定义函数建立文件夹，放在app目录下，比如： 然后再 conposer.json文件中的自动加载项加入你添加的自定义文件： 123456789101112"autoload": &#123; "classmap": [ "database" ], "files":[ "app/Helpers/Helpers.php" ], "psr-4": &#123; "App\\": "app/" &#125; &#125;, 然后运行： composer dump-autoload 开发项目必备 1.ide-hlper composer require --dev barryvdh/laravel-ide-helper 然后在 app/Providers/AppServiceProvider.php file, 添加 12345678public function register()&#123; if ($this-&gt;app-&gt;environment() !== 'production') &#123; $this-&gt;app-&gt;register(\Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider::class); &#125; // ...&#125; 2.laravel-debugbar 1). 使用 Composer 安装该扩展包： composer require barryvdh/laravel-debugbar 2). 安装完成后，修改 config/app.php 在 providers 数组内追加 Debugbar 的 Provider 12345'providers' =&gt; [ ... Barryvdh\Debugbar\ServiceProvider::class,], 同时在 aliases 数组内追加如下内容 12345'aliases' =&gt; [ ... 'Debugbar' =&gt; Barryvdh\Debugbar\Facade::class,] 3). 接下来运行以下命令生成此扩展包的配置文件 config/debugbar.php： php artisan vendor:publish --provider=&quot;Barryvdh\Debugbar\ServiceProvider&quot; 打开 config/debugbar.php，将 enabled 的值设置为： &#39;enabled&#39; =&gt; env(&#39;APP_DEBUG&#39;, false), 修改完以后, Debugbar 分析器的启动状态将由 .env文件中 APP_DEBUG 值决定。 加密解密函数 laravel 当中提供了两种加密解密方式 ###encrypt和decrypt 你可以使用辅助函数 encrypt 来加密一个值。所有加密值都使用 OpenSSL 与 AES-256-CBC 来进行加密。此外，所有加密过的值都会使用消息认证码（MAC）进行签名，以检测加密字符串是否被篡改过： 1234567891011121314151617181920212223242526&lt;?phpnamespace App\Http\Controllers;use App\User;use Illuminate\Http\Request;use App\Http\Controllers\Controller;class UserController extends Controller&#123; /** * 存储用户保密信息 * * @param Request $request * @param int $id * @return Response */ public function storeSecret(Request $request, $id) &#123; $user = User::findOrFail($id); $user-&gt;fill([ 'secret' =&gt; encrypt($request-&gt;secret) ])-&gt;save(); &#125;&#125; 无序列化加密加密值在加密期间通过 serialize 传递，这允许对象和数组的加密。因此，接收加密值的非PHP客户端将需要 unserialize 数据。如果想在不序列化的情况下加密和解密值，可以使用 Crypt Facade 的 encryptString 和 decryptString 方法： use Illuminate\Support\Facades\Crypt; $encrypted = Crypt::encryptString(&#39;Hello world.&#39;); $decrypted = Crypt::decryptString($encrypted); 解密一个值你可以使用辅助函数 decrypt 来解密一个值。如果该值不能被正确解密，例如当 MAC 无效时，会抛出异常 Illuminate\Contracts\Encryption\DecryptException： 12345678use Illuminate\Contracts\Encryption\DecryptException;try &#123; $decrypted = decrypt($encryptedValue);&#125; catch (DecryptException $e) &#123; //&#125; 哈希Laravel Hash Facade 提供安全的 Bcrypt 哈希保存用户密码。 如果应用程序中使用了 Laravel 内置的 LoginController 和 RegisterController 类，它们将自动使用 Bcrypt 进行注册和身份验证 如果用到了laravel auth认证模块，默认是采用这种加密方式 基本用法你可以通过调用 Hash Facade 的 make 方法来填写密码： 1234567891011121314151617181920212223242526&lt;?phpnamespace App\Http\Controllers;use Illuminate\Http\Request;use Illuminate\Support\Facades\Hash;use App\Http\Controllers\Controller;class UpdatePasswordController extends Controller&#123; /** * 更新用户密码 * * @param Request $request * @return Response */ public function update(Request $request) &#123; // Validate the new password length... $request-&gt;user()-&gt;fill([ 'password' =&gt; Hash::make($request-&gt;newPassword) ])-&gt;save(); &#125;&#125; make 方法还能使用 rounds 选项来管理 bcrypt 哈希算法的加密系数。然而，大多数应用程序还是能接受默认值的： 123$hashed = Hash::make('password', [ 'rounds' =&gt; 12]); 根据哈希值验证密码check 方法可以验证给定的纯文本字符串对应于给定的散列。 如果使用 Laravel 内置的 LoginController，则不需要直接使用该方法，因为该控制器会自动调用此方法： 1234if (Hash::check('plain-text', $hashedPassword)) &#123; // 密码对比...&#125; 检查密码是否需要重新加密needsRehash 函数允许你检查已加密的密码所使用的加密系数是否被修改： 1234if (Hash::needsRehash($hashed)) &#123; $hashed = Hash::make('plain-text');&#125; ###PHPSTORM最新注册码 http://www.0-php.com:1017 –2018/3/12（可用）]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>技巧总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT常用命令]]></title>
    <url>%2F2018%2F07%2F16%2FGIT%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[总结了下用的比较多的git命令 1.建立项目文件夹，添加初始代码，比如如果安装了laravel 安装器。可以通过 laravel new test ,创建一个新的项目。 2.在github上面添加一个新的代码仓库，然后复制仓库地址 初始化项目 1.建立项目文件夹，添加初始代码，比如如果安装了laravel 安装器。可以通过 laravel new test ,创建一个新的项目。 2.在github上面添加一个新的代码仓库，然后复制仓库地址 https://github.com/ycp19940225/test.git 通过GIT提交项目 git init 初始化本地代码仓库 git add -A 将所有代码纳入版本控制 git commit -m &#39;init&#39; 此次版本更新说明注释 git remote add origin https://github.com/ycp19940225/test.git 链接到远程仓库 git push -u origin master 上传到主分支 远程服务器更新时发生版本冲突 解决办法：强制覆盖服务器文件 命令 ： git fetch --all git reset --hard origin/master git pull 删除代码仓库进入到代码仓库，点击setting，拉到最下面，点击删除 PHPSTORM当中使用GIT 找到VCS,点击inport into version control ,选择share project on github ,然后输入你的github账号。 这个是真的好用，有代码对比版本记录等等方便的功能，，谁用谁知道 本地服务器发生版本冲突 解决办法：强制覆盖本地文件 git checkout master git reset --hard develop //先将本地的master分支重置成develop git push origin master --force //再推送到远程仓库]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[~~~ 坐在空荡荡的车厢里，望着车窗外的车水马龙，觥筹交错，莫名的空虚感弥漫上心头。每次放假都不想回家，对于家的概念一直不强烈，但是潜意识里不是抗拒它，而是每次回家，总是无尽的争吵，一切不和谐的画面烙在年少的记忆当中。但其实想想自己其实更多的时候是一个被爱的角色，尽管有很多的争吵，但是好像从小我想要的，一切都会尽力为我满足。而我一直没有搞清楚自己想要的是什么。高考之前只是想着一心好好学习，能考上一个好一点的大学。但是当我真的进入了大学这个环境，它不像初中高中，没人约束着你每天都必须要干什么，一切都是靠自己的自觉。当一个人陷入迷茫，大多数选择都是会找到一个精神寄托，或好或坏。 时间真是一个奇妙的东西，它让坚不可摧的东西变得柔软，把你曾经觉得无比重要的一点点消磨。曾经觉得自己其实容易多愁善感的，但是到现在才发觉我只是对自己的情感看的最重要，回想过去多少的决定显得很自私。却固执的认为自己再来一次还是会坚持当时的决定。 阅尽世间繁华，愿归来仍是少年 – 献给未来的自己]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>-feeling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP基础整理（三）]]></title>
    <url>%2F2018%2F07%2F16%2FPHP%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[类与对象（1） PHP 5完全重写了对象模型以得到更佳性能和更多特性,具有完整的对象模型。 PHP 对待对象的方式与引用和句柄相同，即每个变量都持有对象的引用，而不是整个对象的拷贝。 我们都知道PHP对象赋值默认情况下是通过引用传递的，但这并不完全正确。 PHP中的类与对象简介 PHP 5完全重写了对象模型以得到更佳性能和更多特性,具有完整的对象模型。 PHP 对待对象的方式与引用和句柄相同，即每个变量都持有对象的引用，而不是整个对象的拷贝。 我们都知道PHP对象赋值默认情况下是通过引用传递的，但这并不完全正确。 比如： 123456789101112131415class A &#123; public $i = 1;&#125;$a = new A();$b = $a ; //此时，$a,$b是同一个标识符的拷贝，即 ($a) = ($b) = &lt;id&gt;$c = &amp;$a; //此时，$a,$b是引用 即 ($c,$d) = &lt;id&gt;function foo($obj)&#123; $obj-&gt;i = 2 ;&#125;foo($a); //此时传递$a 对象，是标识符拷贝 ，即 // ($obj) = ($e) = &lt;id&gt; ###类型提示 PHP是弱类型语言，向方法传递参数时候也不太区分类型。这样的使用会引起很多的问题，PHP开发者认为，这些问题应该是由代码书写者在书写代码时进行检验以避免。没有类型提示很危险 下面的代码可能会出现问题。 123456789101112131415161718192021222324class NormalUser&#123; /* * 其它相关代码..省略........ */ private $age; public function setAge($_age)&#123; $this-&gt;age = $_age; &#125; public function getAge()&#123; return $this-&gt;age ; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657$normalUser = new NormalUser();$normalUser-&gt;setAge("I am ycp"); //这里我们传输一个非数值.echo "age is " .$normalUser-&gt;getAge();``` //注意输出结果不是我想要的类型.?&gt;程序运行结果：1`age is I am ycp`####原始类型的类型判断PHP中提供了一些函数，来判断数值的类型。我们可使用is_numeric()。判断是否是一个数值或者可转换为数值的字符串。其它相关的还有`is_bool()、is_int()、is_float()、is_integer()、is_numeric()、is_string()、is_array() 和 is_object()`。于是代码有了修改：```php&lt;?class NormalUser&#123; /* * 其它相关代码..省略........ */ private $age; public function setAge($_age)&#123; if(is_numeric($_age))&#123; $this-&gt;age = $_age; &#125; public function getAge()&#123; return $this-&gt;age ; &#125;&#125; 1234567891011121314$normalUser = new NormalUser();$normalUser-&gt;setAge("I am tom"); //这里我们传输一个非数值.echo "age is " .$normalUser-&gt;getAge();//看到这里的结果为空.echo "&lt;br&gt;";$normalUser-&gt;setAge("100");echo "age is ".$normalUser-&gt;getAge();// 这里就有了结果.?&gt; 程序运行结果：12341age is2age is 100 向方法内传递对象如果传递的参数是一个对象呢？下面的代码用起来很正常。 12345678910111213141516171819202122&lt;?class NormalUser &#123; private $name; public function setName($_name)&#123; $this-&gt;name = $_name; &#125; public function getName()&#123; return $this-&gt;name; &#125;&#125; 12345678910111213141516171819202122class UserAdmin&#123; //这里定义的参数,第一个是User类的实例,第二是要设置的名字. public static function changeName($_user,$_name)&#123; $_user-&gt;setName($_name); &#125;&#125;$normalUser = new NormalUser();UserAdmin::changeName($normalUser,"Tom");echo "userName is " . $normalUser-&gt;getName();?&gt; 程序运行结果：121userName is Tom 我们还有一个类，和图书相关的类，在图书类中也可以设置图书的书名setName($name)。如果我向，刚才代码中的方法changeName() 中传入一个Book的实例，原定于改变人名的方法现在改变了书的书名。这有什么风险？能把脏衣服扔到洗衣机里面去洗，同样的清洗，把盘子和碗都扔进洗衣机里面洗洗试试。下面的代码演示我们不想看到的一幕。 12345678910111213141516171819&lt;?class NormalUser&#123; private $name; public function setName($_name)&#123; $this-&gt;name = $_name; &#125; public function getName()&#123; return $this-&gt;name; &#125;&#125; 1234567891011121314151617181920 class Book&#123; private $bookName; public function setName($_name)&#123; $this-&gt;bookName = $_name; &#125; public function getName()&#123; return $this-&gt;bookName; &#125; &#125; 1234567891011121314151617181920212223class UserAdmin&#123; public static function changeName($_user,$_name)&#123; $_user-&gt;setName($_name); &#125;&#125; $book = new Book();UserAdmin::changeName($book,"Tom");echo "bookName is " . $book-&gt;getName(); ?&gt; 程序运行结果：121bookName is Tom 类型提示保障数据安全为了避免对象类型不规范引起的问题，PHP5中引入了类型提示这个概念。在定义方法参数时，同时定义参数的对象类型。如果在调用的时候，传入参数的类型不对会报错。这样保证了数据的安全性。 12345678910111213141516171819202122&lt;?class NormalUser &#123; private $name; public function setName($_name)&#123; $this-&gt;name = $_name; &#125; public function getName()&#123; return $this-&gt;name; &#125;&#125; 123456789101112131415class UserAdmin&#123; public static function changeName(NormalUser $_user,$_name)&#123; $_user-&gt;setName($_name); &#125;&#125;UserAdmin::changeName("anyType","Tom");?&gt; 程序运行结果：121Catchable fatal error: Argument 1 passed to UserAdmin::changeName() must be an instance of NormalUser, string given, called in E:\PHPProjects\NowaMagic\php\php_TypeTips.php on line 221 and defined in E:\PHPProjects\NowaMagic\php\php_TypeTips.php on line 217 建议在定义方法参数时，要使用类型提示。如果类型不是对象，要采用代码进行类型建议，以增强安全性。]]></content>
      <categories>
        <category>PHP基础</category>
      </categories>
      <tags>
        <tag>php基础</tag>
        <tag>类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP基础整理（二）]]></title>
    <url>%2F2018%2F07%2F16%2FPHP%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这里记录一些PHP常见的，自己以前理解不到位的一些小问题。时不时会更新 汇总1.$i++和++$i 先看2个例子12345678910&lt;?phpfor($i=0;$i&lt;3;++$i)&#123; $j=$i; echo $j.'-'.$i.'&lt;br/&gt;';&#125;for($i=0;$i&lt;3;$i++)&#123; $j=$i; echo $j.'-'.$i.'&lt;br/&gt;';&#125; 结果为 1234560-01-12-20-01-12-2 以前总是记住$i++是先用再自增，++$i是先自增再用。并没有想过其实现原理。 底层实现应该是这样子的 12345$temp = $i; $i = $i + 1; $j = $temp; 返回的是$j,$i自增。 所以无论运行$i++,++$i,都会使得$i 加1，但是如果要直接使用$i++,或者++$i,可以将其看成一个函数，2者返回值一个是本身，一个是自增后的值。这样上面最开始的例子就好理解了。 第二个： 12345$a=1;echo $a+$a++.'&lt;br/&gt;';$a=1;echo $a+$a+$a++; 结果：12333 这里$i++,++$i会改变局部结合顺序，但仅仅是局部. 通常而言++优先级高,所以$a+$a++ 是先使用后者$a值,又因为是同一变量,本着从左到右结合,在使用第一个$a时值变成了2,所以结果2+1 得3但无论是i++,还是++i(只能改变局部结合顺序),都是加法运算(优先级相同),显然加运算整体从左到右,($a+$a)+$a++,后者$a++ 不影响,后者表达式前2个$a的值.]]></content>
      <categories>
        <category>PHP基础</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>php基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP基础整理（一）]]></title>
    <url>%2F2018%2F07%2F16%2FPHP%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[PHP赋值语句的引用传递与按值传递之前对于php当中的引用传递与按值传递，并没有深入了解 php中对变量赋值有2种方式：这2个主要应用于变量或者函数赋值，计数赋值用于对象赋值。 赋值语句的引用传递与按值传递 之前对于php当中的引用传递与按值传递，并没有深入了解。 php中对变量赋值有2种方式： 按值传递 引用传递 这2个主要应用于变量或者函数赋值，计数赋值用于对象赋值。 ###按值传递 简单来说就是将变量进行复制，然后开辟一块新的内存空间存储。比如： 1234$b = 1;$a = $b;$a = 2;dd($a,$b); 结果为 2 1 $a的改变并不会影响$b的数值。变量相当于一个内存中的地址别名，当$a = $b，就开辟一个新的内存空间，将$a地址内存的数据取出来放在$b所指向的地址中。因为是不同的地址内存中，所以互相不会影响。按值赋值php7之前有个copy on write(写时复制)机制，貌似到php7废除了（以待以后考证）。 ###引用传递 引用传递则是拷贝一份变量的引用。关于变量的引用，有一篇解释的非常好的文章http://www.cnblogs.com/mushan/p/4330386.html。简单来说，php中的变量与值是2个不同的概念，变量存于一个符号表中，并有作用域，而值则在php内部（zend引擎中），存于一个zval结构体当中。 is_ref 代表他是否为引用，是一个bool值，用来标识这个值是否是一个引用。第二个额外字节是refcount，用来表示指向这个值的变量（也称符号即symbol）的个数。如果refcount为0，那么这个值就可以被回收了。 测试代码如下： 123456789101112$b = 1;$a = $b;$a = 2;xdebug_debug_zval('a');xdebug_debug_zval('b');$c = 1;$d = &amp;$c;$d = 2;xdebug_debug_zval('c');xdebug_debug_zval('d');dd($a,$b); 测试结果： 123456789101112a: (refcount=0, is_ref=0)int 2b: (refcount=0, is_ref=0)int 1c: (refcount=2, is_ref=1)int 2d: (refcount=2, is_ref=1)int 2 2 1 2 2 这里我的php版本为7.0.12，a b 变量的refcount都为0了，这是在php7当中对于在zval的value字段中能保存下的值，不在进行引用计数的原因。这里暂时不深入研究，不然又跑远了。 看一下c d 变量使用应用传递的时候，refcount数量都为2，有2个变量指向它，is_ref为1，这就说明c`d都指向了同一个变量，且变量被标记为引用值。当改变了d的的值，c`也会随之改变，因为2者指向同一个zval容器。 默认传值方式 总结 搞清楚PHP引用赋值与按值赋值的过程当中，查了很多资料，也让自己由以前对2者模糊的印象，变得清晰。值得注意的是由于PHP版本不同，让自己测试当中遇到一些困难。PHP7数据结构发生了变化，性能也得到了提升。鸟哥的博客当中对这一块也有过解释，但是我自己的环境运行代码，与他得到的结果也不一样，和php手册上的也不一样。 总的来说，变量与数组一般都是按值赋值，对象默认是引用传递。当需要修改一个内存存储大量数据的变量，或者需要在函数内部修改变量，并返回修改的变量，使用引用传递（&amp;）。 参考资料： php手册：引用的解释 http://php.net/manual/zh/language.references.php php手册：引用计数基本知识 http://php.net/manual/zh/features.gc.refcounting-basics.php 鸟哥博客：深入理解PHP原理之变量分离/引用(Variables Separation) http://www.laruence.com/2008/09/19/520.html php的三种变量赋值方式 http://blog.csdn.net/sanwenyublog/article/details/13021975 –END]]></content>
      <categories>
        <category>PHP基础</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>php基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用php反射机制 获取权限]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%88%A9%E7%94%A8php%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6-%E8%8E%B7%E5%8F%96%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[之前实现了一个基于角色的权限控制，需要后台手动添加权限，当系统庞大的时候，一条条的加无疑是一场灾难…后来看到公司的权限系统利用php反射机制获取权限，感觉很不错，自己查了下php的反射机制，应用在了自己博客中。 数据库表结构截个图吧… pri_name:权限名 pri_desc:权限描述 module_name:模块名 controller:控制器名 action_name:方法名 一些约定1.代码编写时需要以下的格式 12345678910111213141516/** * @name 添加操作 * @desc 添加操作 * @param Request $request * @return \Illuminate\Http\JsonResponse */ public function addOperate(Request $request) &#123; if($this-&gt;user-&gt;checkUnique($request-&gt;input('adminname')))&#123; return response()-&gt;json(msg('error','该管理员已存在！')); &#125; if($this-&gt;user-&gt;saveUser($request))&#123; return response()-&gt;json(msg('success','添加成功!')); &#125; return response()-&gt;json(msg('error','添加失败！')); &#125; 需要注释加上@name @desc，@name是必须的 2.还需要配置你需要控制的模块，在config/app.php 加上1234567/** * 自定义配置 */ 'ACCESS_CHECK_MODULE' =&gt; env('ACCESS_CHECK_MODULE','admin'), 'name_space' =&gt;'App\Http\Controllers', ` .env 文件写上哪些模块需要权限控制 ACCESS_CHECK_MODULE = &#39;Admin 3.被控制的模块路由地址必须和控制器方法名吻合，比如： 1234567 //角色Route::any('/role/add','RoleController@add');Route::post('/role/addOperate','RoleController@addOperate');Route::get('/role/index','RoleController@index');Route::get('/role/edit/&#123;id&#125;','RoleController@edit')-&gt;where('id', '[0-9]+');Route::post('/role/editOperate','RoleController@editOperate');Route::post('/role/delete','RoleController@delete'); 实现PBAC类 这个类的功能只是获取并返回权限 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101 &lt;?php/** * @name 利用反射获取权限树(路由) * @author [ycp] &lt;[820363773@qq.com]&gt; * Author: ycp * Date: 2017/6/14 * Time: 10:35 * Created by PhpStorm. */namespace App\Models;use ReflectionClass;class Rbac&#123; public function getAccess()&#123; //1.获取所有控制器 $modules = config('app.ACCESS_CHECK_MODULE'); $modules = explode(',',$modules); $controllers =[]; $pris = []; //获取基础控制器的方法 $base_controller = config('app.name_space').'\\'.'Controller'; $reflection = new ReflectionClass($base_controller); $action_base_names = $reflection-&gt;getMethods(); $action_base_name=[]; foreach ($action_base_names as $v)&#123; $action_base_name[]=$v-&gt;name; &#125; //循环模块 foreach ($modules as $mk=&gt;$mv)&#123; $controllers = $this-&gt;getController($mv); if($controllers == null)&#123; continue; &#125; //循环控制器 foreach ($controllers as $con)&#123; $con_name = str_replace('Controller','',basename($con)); $reflection2 = new ReflectionClass($con); $action_names = $reflection2-&gt;getMethods(); //循环方法 foreach ($action_names as $ak=&gt;$av)&#123; $av_real = $av-&gt;name; $desc = $av-&gt;getDocComment(); //控制器名称 if (!preg_match('/@name\s+(\w+)/u', $desc, $catch)) continue; $name = $catch[1]; //控制器描述 $description = preg_match('/@desc\s+(\w+)/u', $desc, $catch) ? $catch[1] : ''; if(in_array($av_real,$action_base_name) || $av_real == '__construct')&#123; continue; &#125;else&#123; $pris[] = [ 'module_name' =&gt;$mv, 'controller' =&gt;$con_name, 'action_name' =&gt;$av_real, 'pri_name' =&gt;$name, 'pri_desc' =&gt;$description ]; &#125; &#125; &#125; &#125; return $pris; &#125; /** * 获取所有控制器名称 * @param string $module * @return array */ protected function getController($module)&#123; if(empty($module))&#123; return null; &#125; $module_path = app_path('Http\Controllers').'/'.$module;//模块路径 $module_path = str_replace('\\','/',$module_path); if(!is_dir($module_path)) &#123; return null; &#125;; $module_path .= '/*.php'; $ary_files = glob($module_path); $files= []; foreach ($ary_files as $file)&#123; if(is_dir($file) || basename($file,'.php') =='LoginController')&#123; continue; &#125;else&#123; $files[]=config('app.name_space').'\\'.$module.'\\'.basename($file,'.php'); &#125; &#125; return $files; &#125;&#125; 添加权限123456789101112131415161718192021222324252627282930/** * @name 系统权限添加入库 * @desc 系统权限添加入库 * @return mixed */ public function refreshPri() &#123; $rbac = new Rbac(); $pris = $rbac-&gt;getAccess(); $ids = [] ; //更新或者添加的ID foreach ($pris as $k=&gt;$v)&#123; //添加或者更新已有权限 $pri = $this-&gt;updateOrCreate([ 'module_name' =&gt;$v['module_name'], 'controller' =&gt;$v['controller'], 'action_name' =&gt;$v['action_name'] ],[ 'pri_name' =&gt;$v['pri_name'], 'pri_desc' =&gt;$v['pri_desc'] ]); $ids[] = $pri-&gt;id; &#125; //去掉删除的权限 $old_ids = json_decode($this-&gt;pluck('id'),true); $delete_ids = array_diff($old_ids,$ids); foreach ($delete_ids as $v)&#123; $this-&gt;destroy($v); &#125; return true; &#125; 到这里php处理得就差不多了，然后就是前段展示的问题 展示权限截个图… 权限控制权限检测都在中间件中进行，定义AdminNeedsPermission中间件 12345678910111213141516171819202122232425262728293031&lt;?phpnamespace App\Http\Middleware;use Closure;class AdminNeedsPermission&#123; /** * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure $next * @return mixed */ public function handle($request, Closure $next) &#123; //公共包不做权限验证 if($request-&gt;is('common/*'))&#123; return $next($request); &#125; if(checkPri($request-&gt;path()))&#123; if(\Request::ajax())&#123; return response()-&gt;json(msg('error','您没有权限访问！')); &#125; return redirect('admin')-&gt;with(['SYS_INFO'=&gt;'您没有权限访问！']); &#125; return $next($request); &#125;&#125; checkPri方法：添加到辅助方法helper中 1234567891011121314151617181920212223242526/** * 检测权限 */if ( ! function_exists('checkPri'))&#123; function checkPri($url)&#123; if($url == 'admin')&#123;//首页不验证 return false; &#125; $pris = SC::getUserAccess(); if(count($pris)&gt;0)&#123; if(!is_array($url))&#123; $url = explode('/',$url); &#125; foreach ($pris as $pri)&#123; if($pri-&gt;admin_id ===1)&#123; return false; &#125; if(strtolower($url[0]) == strtolower($pri-&gt;module_name) &amp;&amp; strtolower($url[1]) == strtolower($pri-&gt;controller) &amp;&amp; strtolower($url[2]) == strtolower($pri-&gt;action_name))&#123; return false; &#125; &#125; &#125; return true; &#125;&#125; 总结：实现起来并不复杂，从此不必手动一个个添加权限了 以上代码都在项目https://github.com/ycp19940225/blog可以找到 ——END]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PBAC</tag>
        <tag>reflection</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel Eloquent ORM 模型关联 使用总结]]></title>
    <url>%2F2018%2F07%2F16%2Flaravel-Eloquent-ORM-%E6%A8%A1%E5%9E%8B%E5%85%B3%E8%81%94-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在lavaral中可以直接使用DB查询构建器写sql关联语句，其实挺方便，程序执行效率也会更高。ORM主要应该使用于关联查询比较多的情景。主要是前3种关联用的多。返回的数据是集合类型。 简介laravel当中主要有以下几种关联关系： 一对一 一对多 多对多 远程一对多 多态关联 多对多的多态关联主要是前3种关联用的多。返回的数据是集合类型。 定义关联关系简单定义使用在模型中定义一个函数，比如：1234567891011121314class Users extends Base&#123; protected $table = 'blog_admin'; protected $dateFormat = 'U'; /** * 关联模型 * 属于该用户的身份。 */ public function roles() &#123; return $this-&gt;belongsToMany('App\Models\Admin\Role','blog_admin_role','admin_id','role_id'); &#125;&#125; 使用:按正常查询数据，然后在后面跟上roles属性就行了。需要注意的是，必须是单条记录才能直接使用roles属性。 1$data-&gt;roles; 多条记录需要遍历： 123foreach($data as $v)&#123; $v-&gt;roles;&#125; 关联关系 每种关联关系都有正向关联和反向关联 一对一正向： $this-&gt;hasOne(&#39;要关联的模型名&#39;,&#39;foreign_key&#39;,&#39;local_key&#39;); 反向： $this-&gt;belongsTo(&#39;要关联的模型名&#39;,&#39;local_key&#39;,&#39;foreign_key&#39;); foreign_key:关联模型名对应的外键 local_key:本模型被关联的ID 一对多正向： $this-&gt;hasMany(&#39;要关联的模型名&#39;,&#39;foreign_key&#39;,&#39;local_key&#39;); 反向： $this-&gt;belongsTo(&#39;要关联的模型名&#39;,&#39;local_key&#39;,&#39;foreign_key&#39;); foreign_key:关联模型名对应的外键 local_key:本模型被关联的ID 比如：一个分类对应多篇文章，一个文章只属于一个分类，我在文章模型中定义 正向关联： 12345678/** * 关联模型 * 属于该文章的分类。 */public function cat()&#123; return $this-&gt;hasMany('App\Models\Admin\Cat','id','cat_id');&#125; 反向关联： 12345678/** * 关联模型 * 属于该文章的分类。 */public function cat()&#123; return $this-&gt;belongsTo('App\Models\Admin\Cat','cat_id','id');&#125; 总结来说,第一个参数就是外键，无论正向反向关联，这里填写数据表中的外键即可 多对多比如一个管理员和角色多对多，中间表明为blog_admin_role,可以这样定义：12345678/** * 关联模型 * 属于该用户的身份。 */ public function roles() &#123; return $this-&gt;belongsToMany('App\Models\Admin\Role','blog_admin_role','admin_id','role_id'); &#125; 插入 &amp; 更新关联模型插入关联模型首先需要获取到模型，比如，添加一片文章，然后添加标签 添加文章 1$this_article = $this-&gt;create($data); 添加标签 1$this_article-&gt;tag()-&gt;attach($tags_id); 移除关联模型获取文章 1$this_article = $this-&gt;find($id); 移除标签 1$this_article-&gt;tag()-&gt;detach($tags_id); 更新关联模型1$this_article-&gt;tag()-&gt;sync($tags_id); sync方法会接受一组数据，他会保存新添加的数据，移除删除掉的数据。 以上便是简单使用orm后，自己的一些理解。 —-更新（2017/12/24） 多对多添加更新中间表当多对多中间表需要添加额外字段，可以这样做 12$this_article-&gt;tag()-&gt;attach($tags_id,['key'=&gt;$value]); 或者将$tags_id改造成以下格式（假如额外字段位tag_val） 123[ &apos;1&apos;=&gt;[&apos;tag_val&apos;=&gt;&apos;tag_1&apos;], &apos;2&apos;=&gt;[&apos;tag_val&apos;=&gt;&apos;tag_2&apos;]] 参考： http://laravelacademy.org/post/6996.html – END]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>orm</tag>
        <tag>关联模型</tag>
      </tags>
  </entry>
</search>
