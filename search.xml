<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[laravel中的服务容器]]></title>
    <url>%2F2018%2F07%2F16%2Flaravel%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[控制反转（IoC）和依赖注入（DI）几乎所有php框架，或者对php程序来说，都是单一入口，都是以index.php开始的。那么laravel的入口文件都干了些什么事呢？ IoC 容器 —— Laravel 的核心laravel 的请求生命周期几乎所有php框架，或者对php程序来说，都是单一入口，都是以index.php开始的。那么laravel的 入口文件都干了些什么事呢？ 所有请求通过web服务器（apapache/nignx）引导至 public/index.php。 第一件事就是从bootstrap/app.php脚本中检索laravel应用程序的实例。 引入app.php（创建一个新的应用）$app = require_once __DIR__.&#39;/../bootstrap/app.php&#39;; app.php文件当中，第一件事就是创建一个新的实例; $app = new Illuminate\Foundation\Application( realpath(__DIR__.&#39;/../&#39;) ); 实例化Application 123456789101112131415 class Application extends Container implements ApplicationContract, HttpKernelInterface&#123; public function __construct($basePath = null) &#123; if ($basePath) &#123; $this-&gt;setBasePath($basePath); &#125; $this-&gt;registerBaseBindings(); $this-&gt;registerBaseServiceProviders(); $this-&gt;registerCoreContainerAliases(); &#125;&#125; 实例化的时候干了4件事 绑定当前实例路径 注册基本绑定 注册所有基本服务提供者 注册所有核心依赖到容器中 (2)将重要的接口绑定到容器12345678910111213$app-&gt;singleton( Illuminate\Contracts\Http\Kernel::class, App\Http\Kernel::class);$app-&gt;singleton( Illuminate\Contracts\Console\Kernel::class, App\Console\Kernel::class);$app-&gt;singleton( Illuminate\Contracts\Debug\ExceptionHandler::class, App\Exceptions\Handler::class); 绑定单例到容器（http,kernel,debug） (3)返回应用程序(当前实例)启动应用程序$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class); 这里 Illuminate\Contracts\Http\Kernel::class只是一个接口，这里的$app-&gt;make() 这里有深入研究 Laravel 执行流程（五）之 认识 Make 简单来说就是从容器中解析给定的类型。那么这行代码可以理解为实例化位于app/Http/Kernel.php这个类。 HTTP／控制器内核所有请求都会Http的核心类（kernel）中的handle方法处理 这个handle方法长这个样子 1234567891011121314151617181920212223public function handle($request) &#123; try &#123; $request-&gt;enableHttpMethodParameterOverride(); $response = $this-&gt;sendRequestThroughRouter($request); &#125; catch (Exception $e) &#123; $this-&gt;reportException($e); $response = $this-&gt;renderException($request, $e); &#125; catch (Throwable $e) &#123; $this-&gt;reportException($e = new FatalThrowableError($e)); $response = $this-&gt;renderException($request, $e); &#125; $this-&gt;app['events']-&gt;dispatch( new Events\RequestHandled($request, $response) ); return $response; &#125; 简单来说就是创建了一个新的HTTP内核实例，并且实例化了一些重要的组件 应用程序的请求类型将传入的请求发送到 HTTP 内核或控制台内核。而这两个内核是用来作为所 有请求都要通过的中心位置。一个处理http请求，一个处理控制台请求。我们一般用到的是HTTP 内核。 $response = $kernel-&gt;handle( $request = Illuminate\Http\Request::capture() );实例化了kernel传入了请求类 1234class Request extends SymfonyRequest implements Arrayable, ArrayAccess&#123;&#125; 继承了symfony的Request然后实现了一些接口。 从请求入口后面就可以开始处理自己业务逻辑了 返回$response-&gt;send(); 服务容器与服务提供器服务提供器 最重要的内核引导操作之一是加载应用程序的 服务提供器。应用程序的所有服务提供器都在 config/app.php 配置文件的 providers 数组中配置。首先，所有提供器都会调用 register 方法，接着，由 boot 方法负责调用所有被注册提供器。 服务提供器负责引导所有框架的各种组件，如数据库、队列、验证和路由组件。也就是说，框架提供的每个功能都它们来引导并配置。因此也可以说，服务提供器是整个 Laravel 引导过程中最重要的方面。 简单来说就是在容器中注册需要的类 服务容器服务容器通过构造函数或者某些情况下通过 set 方法将类依赖注入到类中。说得专业点就是用于管理类依赖和执行依赖注入的强大工具 依赖注入与控制反转 我的理解：当一个类A需要实例化另一个类B，我们不在类A里面实例化，让其他类(专门的)来实例化,这个就叫控制反转。那怎么把实例化的类B放到类A,可以通过构造函数,或者set方法注入，这个就叫依赖注入。 在php当中一般使用类型提示注入依赖，比如管理员控制器需要注入，角色和权限 1234567891011class AdminController extends controller&#123; protected $user; protected $role; public function __construct(UserServices $userServices,RoleServices $roleServices) &#123; $this-&gt;user=$userServices; $this-&gt;role=$roleServices; &#125; &#125; 这里的UserService,RoleServices为接口 在laravel中服务容器有一个强大的功能，就是将接口绑定到给定实现。如果需要用到服务容器，一般是注入接口，如果不是就接口，也就没有必要使用了。直接注入就行了，可以使用Repository模式，事实证明，服务容器很麻烦，如果不是超大型项目，根本没有必要使用。 Laravel 的核心就是一个 IoC 容器，高级的IOC容器，他会根据类的依赖需求，自动在注册、绑定的一堆实例中搜寻符合的依赖需求，并自动注入到构造函数参数中去。这种自动搜寻依赖需求的功能，是通过反射（Reflection）实现的。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>IOC</tag>
        <tag>依赖注入</tag>
        <tag>控制反转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel 技巧总结]]></title>
    <url>%2F2018%2F07%2F16%2Flaravel-%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一些使用laravel时用到的一些小技巧建立文件夹，放在app目录下，比如：然后再 conposer.json文件中的自动加载项加入你添加的自定义文件： 添加自定义函数建立文件夹，放在app目录下，比如： 然后再 conposer.json文件中的自动加载项加入你添加的自定义文件： 123456789101112"autoload": &#123; "classmap": [ "database" ], "files":[ "app/Helpers/Helpers.php" ], "psr-4": &#123; "App\\": "app/" &#125; &#125;, 然后运行： composer dump-autoload 开发项目必备 1.ide-hlper composer require --dev barryvdh/laravel-ide-helper 然后在 app/Providers/AppServiceProvider.php file, 添加 12345678public function register()&#123; if ($this-&gt;app-&gt;environment() !== 'production') &#123; $this-&gt;app-&gt;register(\Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider::class); &#125; // ...&#125; 2.laravel-debugbar 1). 使用 Composer 安装该扩展包： composer require barryvdh/laravel-debugbar 2). 安装完成后，修改 config/app.php 在 providers 数组内追加 Debugbar 的 Provider 12345'providers' =&gt; [ ... Barryvdh\Debugbar\ServiceProvider::class,], 同时在 aliases 数组内追加如下内容 12345'aliases' =&gt; [ ... 'Debugbar' =&gt; Barryvdh\Debugbar\Facade::class,] 3). 接下来运行以下命令生成此扩展包的配置文件 config/debugbar.php： php artisan vendor:publish --provider=&quot;Barryvdh\Debugbar\ServiceProvider&quot; 打开 config/debugbar.php，将 enabled 的值设置为： &#39;enabled&#39; =&gt; env(&#39;APP_DEBUG&#39;, false), 修改完以后, Debugbar 分析器的启动状态将由 .env文件中 APP_DEBUG 值决定。 加密解密函数 laravel 当中提供了两种加密解密方式 ###encrypt和decrypt 你可以使用辅助函数 encrypt 来加密一个值。所有加密值都使用 OpenSSL 与 AES-256-CBC 来进行加密。此外，所有加密过的值都会使用消息认证码（MAC）进行签名，以检测加密字符串是否被篡改过： 1234567891011121314151617181920212223242526&lt;?phpnamespace App\Http\Controllers;use App\User;use Illuminate\Http\Request;use App\Http\Controllers\Controller;class UserController extends Controller&#123; /** * 存储用户保密信息 * * @param Request $request * @param int $id * @return Response */ public function storeSecret(Request $request, $id) &#123; $user = User::findOrFail($id); $user-&gt;fill([ 'secret' =&gt; encrypt($request-&gt;secret) ])-&gt;save(); &#125;&#125; 无序列化加密加密值在加密期间通过 serialize 传递，这允许对象和数组的加密。因此，接收加密值的非PHP客户端将需要 unserialize 数据。如果想在不序列化的情况下加密和解密值，可以使用 Crypt Facade 的 encryptString 和 decryptString 方法： use Illuminate\Support\Facades\Crypt; $encrypted = Crypt::encryptString(&#39;Hello world.&#39;); $decrypted = Crypt::decryptString($encrypted); 解密一个值你可以使用辅助函数 decrypt 来解密一个值。如果该值不能被正确解密，例如当 MAC 无效时，会抛出异常 Illuminate\Contracts\Encryption\DecryptException： 12345678use Illuminate\Contracts\Encryption\DecryptException;try &#123; $decrypted = decrypt($encryptedValue);&#125; catch (DecryptException $e) &#123; //&#125; 哈希Laravel Hash Facade 提供安全的 Bcrypt 哈希保存用户密码。 如果应用程序中使用了 Laravel 内置的 LoginController 和 RegisterController 类，它们将自动使用 Bcrypt 进行注册和身份验证 如果用到了laravel auth认证模块，默认是采用这种加密方式 基本用法你可以通过调用 Hash Facade 的 make 方法来填写密码： 1234567891011121314151617181920212223242526&lt;?phpnamespace App\Http\Controllers;use Illuminate\Http\Request;use Illuminate\Support\Facades\Hash;use App\Http\Controllers\Controller;class UpdatePasswordController extends Controller&#123; /** * 更新用户密码 * * @param Request $request * @return Response */ public function update(Request $request) &#123; // Validate the new password length... $request-&gt;user()-&gt;fill([ 'password' =&gt; Hash::make($request-&gt;newPassword) ])-&gt;save(); &#125;&#125; make 方法还能使用 rounds 选项来管理 bcrypt 哈希算法的加密系数。然而，大多数应用程序还是能接受默认值的： 123$hashed = Hash::make('password', [ 'rounds' =&gt; 12]); 根据哈希值验证密码check 方法可以验证给定的纯文本字符串对应于给定的散列。 如果使用 Laravel 内置的 LoginController，则不需要直接使用该方法，因为该控制器会自动调用此方法： 1234if (Hash::check('plain-text', $hashedPassword)) &#123; // 密码对比...&#125; 检查密码是否需要重新加密needsRehash 函数允许你检查已加密的密码所使用的加密系数是否被修改： 1234if (Hash::needsRehash($hashed)) &#123; $hashed = Hash::make('plain-text');&#125; ###PHPSTORM最新注册码 http://www.0-php.com:1017 –2018/3/12（可用）]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>技巧总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT常用命令]]></title>
    <url>%2F2018%2F07%2F16%2FGIT%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[总结了下用的比较多的git命令 1.建立项目文件夹，添加初始代码，比如如果安装了laravel 安装器。可以通过 laravel new test ,创建一个新的项目。 2.在github上面添加一个新的代码仓库，然后复制仓库地址 初始化项目 1.建立项目文件夹，添加初始代码，比如如果安装了laravel 安装器。可以通过 laravel new test ,创建一个新的项目。 2.在github上面添加一个新的代码仓库，然后复制仓库地址 https://github.com/ycp19940225/test.git 通过GIT提交项目 git init 初始化本地代码仓库 git add -A 将所有代码纳入版本控制 git commit -m &#39;init&#39; 此次版本更新说明注释 git remote add origin https://github.com/ycp19940225/test.git 链接到远程仓库 git push -u origin master 上传到主分支 远程服务器更新时发生版本冲突 解决办法：强制覆盖服务器文件 命令 ： git fetch --all git reset --hard origin/master git pull 删除代码仓库进入到代码仓库，点击setting，拉到最下面，点击删除 PHPSTORM当中使用GIT 找到VCS,点击inport into version control ,选择share project on github ,然后输入你的github账号。 这个是真的好用，有代码对比版本记录等等方便的功能，，谁用谁知道 本地服务器发生版本冲突 解决办法：强制覆盖本地文件 git checkout master git reset --hard develop //先将本地的master分支重置成develop git push origin master --force //再推送到远程仓库]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[~~~ 坐在空荡荡的车厢里，望着车窗外的车水马龙，觥筹交错，莫名的空虚感弥漫上心头。每次放假都不想回家，对于家的概念一直不强烈，但是潜意识里不是抗拒它，而是每次回家，总是无尽的争吵，一切不和谐的画面烙在年少的记忆当中。但其实想想自己其实更多的时候是一个被爱的角色，尽管有很多的争吵，但是好像从小我想要的，一切都会尽力为我满足。而我一直没有搞清楚自己想要的是什么。高考之前只是想着一心好好学习，能考上一个好一点的大学。但是当我真的进入了大学这个环境，它不像初中高中，没人约束着你每天都必须要干什么，一切都是靠自己的自觉。当一个人陷入迷茫，大多数选择都是会找到一个精神寄托，或好或坏。 时间真是一个奇妙的东西，它让坚不可摧的东西变得柔软，把你曾经觉得无比重要的一点点消磨。曾经觉得自己其实容易多愁善感的，但是到现在才发觉我只是对自己的情感看的最重要，回想过去多少的决定显得很自私。却固执的认为自己再来一次还是会坚持当时的决定。 阅尽世间繁华，愿归来仍是少年 – 献给未来的自己]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>-feeling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP基础整理（三）]]></title>
    <url>%2F2018%2F07%2F16%2FPHP%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[类与对象（1） PHP 5完全重写了对象模型以得到更佳性能和更多特性,具有完整的对象模型。 PHP 对待对象的方式与引用和句柄相同，即每个变量都持有对象的引用，而不是整个对象的拷贝。 我们都知道PHP对象赋值默认情况下是通过引用传递的，但这并不完全正确。 PHP中的类与对象简介 PHP 5完全重写了对象模型以得到更佳性能和更多特性,具有完整的对象模型。 PHP 对待对象的方式与引用和句柄相同，即每个变量都持有对象的引用，而不是整个对象的拷贝。 我们都知道PHP对象赋值默认情况下是通过引用传递的，但这并不完全正确。 比如： 123456789101112131415class A &#123; public $i = 1;&#125;$a = new A();$b = $a ; //此时，$a,$b是同一个标识符的拷贝，即 ($a) = ($b) = &lt;id&gt;$c = &amp;$a; //此时，$a,$b是引用 即 ($c,$d) = &lt;id&gt;function foo($obj)&#123; $obj-&gt;i = 2 ;&#125;foo($a); //此时传递$a 对象，是标识符拷贝 ，即 // ($obj) = ($e) = &lt;id&gt; ###类型提示 PHP是弱类型语言，向方法传递参数时候也不太区分类型。这样的使用会引起很多的问题，PHP开发者认为，这些问题应该是由代码书写者在书写代码时进行检验以避免。没有类型提示很危险 下面的代码可能会出现问题。 123456789101112131415161718192021222324class NormalUser&#123; /* * 其它相关代码..省略........ */ private $age; public function setAge($_age)&#123; $this-&gt;age = $_age; &#125; public function getAge()&#123; return $this-&gt;age ; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657$normalUser = new NormalUser();$normalUser-&gt;setAge("I am ycp"); //这里我们传输一个非数值.echo "age is " .$normalUser-&gt;getAge();``` //注意输出结果不是我想要的类型.?&gt;程序运行结果：1`age is I am ycp`####原始类型的类型判断PHP中提供了一些函数，来判断数值的类型。我们可使用is_numeric()。判断是否是一个数值或者可转换为数值的字符串。其它相关的还有`is_bool()、is_int()、is_float()、is_integer()、is_numeric()、is_string()、is_array() 和 is_object()`。于是代码有了修改：```php&lt;?class NormalUser&#123; /* * 其它相关代码..省略........ */ private $age; public function setAge($_age)&#123; if(is_numeric($_age))&#123; $this-&gt;age = $_age; &#125; public function getAge()&#123; return $this-&gt;age ; &#125;&#125; 1234567891011121314$normalUser = new NormalUser();$normalUser-&gt;setAge("I am tom"); //这里我们传输一个非数值.echo "age is " .$normalUser-&gt;getAge();//看到这里的结果为空.echo "&lt;br&gt;";$normalUser-&gt;setAge("100");echo "age is ".$normalUser-&gt;getAge();// 这里就有了结果.?&gt; 程序运行结果：12341age is2age is 100 向方法内传递对象如果传递的参数是一个对象呢？下面的代码用起来很正常。 12345678910111213141516171819202122&lt;?class NormalUser &#123; private $name; public function setName($_name)&#123; $this-&gt;name = $_name; &#125; public function getName()&#123; return $this-&gt;name; &#125;&#125; 12345678910111213141516171819202122class UserAdmin&#123; //这里定义的参数,第一个是User类的实例,第二是要设置的名字. public static function changeName($_user,$_name)&#123; $_user-&gt;setName($_name); &#125;&#125;$normalUser = new NormalUser();UserAdmin::changeName($normalUser,"Tom");echo "userName is " . $normalUser-&gt;getName();?&gt; 程序运行结果：121userName is Tom 我们还有一个类，和图书相关的类，在图书类中也可以设置图书的书名setName($name)。如果我向，刚才代码中的方法changeName() 中传入一个Book的实例，原定于改变人名的方法现在改变了书的书名。这有什么风险？能把脏衣服扔到洗衣机里面去洗，同样的清洗，把盘子和碗都扔进洗衣机里面洗洗试试。下面的代码演示我们不想看到的一幕。 12345678910111213141516171819&lt;?class NormalUser&#123; private $name; public function setName($_name)&#123; $this-&gt;name = $_name; &#125; public function getName()&#123; return $this-&gt;name; &#125;&#125; 1234567891011121314151617181920 class Book&#123; private $bookName; public function setName($_name)&#123; $this-&gt;bookName = $_name; &#125; public function getName()&#123; return $this-&gt;bookName; &#125; &#125; 1234567891011121314151617181920212223class UserAdmin&#123; public static function changeName($_user,$_name)&#123; $_user-&gt;setName($_name); &#125;&#125; $book = new Book();UserAdmin::changeName($book,"Tom");echo "bookName is " . $book-&gt;getName(); ?&gt; 程序运行结果：121bookName is Tom 类型提示保障数据安全为了避免对象类型不规范引起的问题，PHP5中引入了类型提示这个概念。在定义方法参数时，同时定义参数的对象类型。如果在调用的时候，传入参数的类型不对会报错。这样保证了数据的安全性。 12345678910111213141516171819202122&lt;?class NormalUser &#123; private $name; public function setName($_name)&#123; $this-&gt;name = $_name; &#125; public function getName()&#123; return $this-&gt;name; &#125;&#125; 123456789101112131415class UserAdmin&#123; public static function changeName(NormalUser $_user,$_name)&#123; $_user-&gt;setName($_name); &#125;&#125;UserAdmin::changeName("anyType","Tom");?&gt; 程序运行结果：121Catchable fatal error: Argument 1 passed to UserAdmin::changeName() must be an instance of NormalUser, string given, called in E:\PHPProjects\NowaMagic\php\php_TypeTips.php on line 221 and defined in E:\PHPProjects\NowaMagic\php\php_TypeTips.php on line 217 建议在定义方法参数时，要使用类型提示。如果类型不是对象，要采用代码进行类型建议，以增强安全性。]]></content>
      <categories>
        <category>PHP基础</category>
      </categories>
      <tags>
        <tag>php基础</tag>
        <tag>类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP基础整理（二）]]></title>
    <url>%2F2018%2F07%2F16%2FPHP%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这里记录一些PHP常见的，自己以前理解不到位的一些小问题。时不时会更新 汇总1.$i++和++$i 先看2个例子12345678910&lt;?phpfor($i=0;$i&lt;3;++$i)&#123; $j=$i; echo $j.'-'.$i.'&lt;br/&gt;';&#125;for($i=0;$i&lt;3;$i++)&#123; $j=$i; echo $j.'-'.$i.'&lt;br/&gt;';&#125; 结果为 1234560-01-12-20-01-12-2 以前总是记住$i++是先用再自增，++$i是先自增再用。并没有想过其实现原理。 底层实现应该是这样子的 12345$temp = $i; $i = $i + 1; $j = $temp; 返回的是$j,$i自增。 所以无论运行$i++,++$i,都会使得$i 加1，但是如果要直接使用$i++,或者++$i,可以将其看成一个函数，2者返回值一个是本身，一个是自增后的值。这样上面最开始的例子就好理解了。 第二个： 12345$a=1;echo $a+$a++.'&lt;br/&gt;';$a=1;echo $a+$a+$a++; 结果：12333 这里$i++,++$i会改变局部结合顺序，但仅仅是局部. 通常而言++优先级高,所以$a+$a++ 是先使用后者$a值,又因为是同一变量,本着从左到右结合,在使用第一个$a时值变成了2,所以结果2+1 得3但无论是i++,还是++i(只能改变局部结合顺序),都是加法运算(优先级相同),显然加运算整体从左到右,($a+$a)+$a++,后者$a++ 不影响,后者表达式前2个$a的值.]]></content>
      <categories>
        <category>PHP基础</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>php基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP基础整理（一）]]></title>
    <url>%2F2018%2F07%2F16%2FPHP%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[PHP赋值语句的引用传递与按值传递之前对于php当中的引用传递与按值传递，并没有深入了解 php中对变量赋值有2种方式：这2个主要应用于变量或者函数赋值，计数赋值用于对象赋值。 赋值语句的引用传递与按值传递 之前对于php当中的引用传递与按值传递，并没有深入了解。 php中对变量赋值有2种方式： 按值传递 引用传递 这2个主要应用于变量或者函数赋值，计数赋值用于对象赋值。 ###按值传递 简单来说就是将变量进行复制，然后开辟一块新的内存空间存储。比如： 1234$b = 1;$a = $b;$a = 2;dd($a,$b); 结果为 2 1 $a的改变并不会影响$b的数值。变量相当于一个内存中的地址别名，当$a = $b，就开辟一个新的内存空间，将$a地址内存的数据取出来放在$b所指向的地址中。因为是不同的地址内存中，所以互相不会影响。按值赋值php7之前有个copy on write(写时复制)机制，貌似到php7废除了（以待以后考证）。 ###引用传递 引用传递则是拷贝一份变量的引用。关于变量的引用，有一篇解释的非常好的文章http://www.cnblogs.com/mushan/p/4330386.html。简单来说，php中的变量与值是2个不同的概念，变量存于一个符号表中，并有作用域，而值则在php内部（zend引擎中），存于一个zval结构体当中。 is_ref 代表他是否为引用，是一个bool值，用来标识这个值是否是一个引用。第二个额外字节是refcount，用来表示指向这个值的变量（也称符号即symbol）的个数。如果refcount为0，那么这个值就可以被回收了。 测试代码如下： 123456789101112$b = 1;$a = $b;$a = 2;xdebug_debug_zval('a');xdebug_debug_zval('b');$c = 1;$d = &amp;$c;$d = 2;xdebug_debug_zval('c');xdebug_debug_zval('d');dd($a,$b); 测试结果： 123456789101112a: (refcount=0, is_ref=0)int 2b: (refcount=0, is_ref=0)int 1c: (refcount=2, is_ref=1)int 2d: (refcount=2, is_ref=1)int 2 2 1 2 2 这里我的php版本为7.0.12，a b 变量的refcount都为0了，这是在php7当中对于在zval的value字段中能保存下的值，不在进行引用计数的原因。这里暂时不深入研究，不然又跑远了。 看一下c d 变量使用应用传递的时候，refcount数量都为2，有2个变量指向它，is_ref为1，这就说明c`d都指向了同一个变量，且变量被标记为引用值。当改变了d的的值，c`也会随之改变，因为2者指向同一个zval容器。 默认传值方式 总结 搞清楚PHP引用赋值与按值赋值的过程当中，查了很多资料，也让自己由以前对2者模糊的印象，变得清晰。值得注意的是由于PHP版本不同，让自己测试当中遇到一些困难。PHP7数据结构发生了变化，性能也得到了提升。鸟哥的博客当中对这一块也有过解释，但是我自己的环境运行代码，与他得到的结果也不一样，和php手册上的也不一样。 总的来说，变量与数组一般都是按值赋值，对象默认是引用传递。当需要修改一个内存存储大量数据的变量，或者需要在函数内部修改变量，并返回修改的变量，使用引用传递（&amp;）。 参考资料： php手册：引用的解释 http://php.net/manual/zh/language.references.php php手册：引用计数基本知识 http://php.net/manual/zh/features.gc.refcounting-basics.php 鸟哥博客：深入理解PHP原理之变量分离/引用(Variables Separation) http://www.laruence.com/2008/09/19/520.html php的三种变量赋值方式 http://blog.csdn.net/sanwenyublog/article/details/13021975 –END]]></content>
      <categories>
        <category>PHP基础</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>php基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用php反射机制 获取权限]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%88%A9%E7%94%A8php%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6-%E8%8E%B7%E5%8F%96%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[之前实现了一个基于角色的权限控制，需要后台手动添加权限，当系统庞大的时候，一条条的加无疑是一场灾难…后来看到公司的权限系统利用php反射机制获取权限，感觉很不错，自己查了下php的反射机制，应用在了自己博客中。 数据库表结构截个图吧… pri_name:权限名 pri_desc:权限描述 module_name:模块名 controller:控制器名 action_name:方法名 一些约定1.代码编写时需要以下的格式 12345678910111213141516/** * @name 添加操作 * @desc 添加操作 * @param Request $request * @return \Illuminate\Http\JsonResponse */ public function addOperate(Request $request) &#123; if($this-&gt;user-&gt;checkUnique($request-&gt;input('adminname')))&#123; return response()-&gt;json(msg('error','该管理员已存在！')); &#125; if($this-&gt;user-&gt;saveUser($request))&#123; return response()-&gt;json(msg('success','添加成功!')); &#125; return response()-&gt;json(msg('error','添加失败！')); &#125; 需要注释加上@name @desc，@name是必须的 2.还需要配置你需要控制的模块，在config/app.php 加上1234567/** * 自定义配置 */ 'ACCESS_CHECK_MODULE' =&gt; env('ACCESS_CHECK_MODULE','admin'), 'name_space' =&gt;'App\Http\Controllers', ` .env 文件写上哪些模块需要权限控制 ACCESS_CHECK_MODULE = &#39;Admin 3.被控制的模块路由地址必须和控制器方法名吻合，比如： 1234567 //角色Route::any('/role/add','RoleController@add');Route::post('/role/addOperate','RoleController@addOperate');Route::get('/role/index','RoleController@index');Route::get('/role/edit/&#123;id&#125;','RoleController@edit')-&gt;where('id', '[0-9]+');Route::post('/role/editOperate','RoleController@editOperate');Route::post('/role/delete','RoleController@delete'); 实现PBAC类 这个类的功能只是获取并返回权限 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101 &lt;?php/** * @name 利用反射获取权限树(路由) * @author [ycp] &lt;[820363773@qq.com]&gt; * Author: ycp * Date: 2017/6/14 * Time: 10:35 * Created by PhpStorm. */namespace App\Models;use ReflectionClass;class Rbac&#123; public function getAccess()&#123; //1.获取所有控制器 $modules = config('app.ACCESS_CHECK_MODULE'); $modules = explode(',',$modules); $controllers =[]; $pris = []; //获取基础控制器的方法 $base_controller = config('app.name_space').'\\'.'Controller'; $reflection = new ReflectionClass($base_controller); $action_base_names = $reflection-&gt;getMethods(); $action_base_name=[]; foreach ($action_base_names as $v)&#123; $action_base_name[]=$v-&gt;name; &#125; //循环模块 foreach ($modules as $mk=&gt;$mv)&#123; $controllers = $this-&gt;getController($mv); if($controllers == null)&#123; continue; &#125; //循环控制器 foreach ($controllers as $con)&#123; $con_name = str_replace('Controller','',basename($con)); $reflection2 = new ReflectionClass($con); $action_names = $reflection2-&gt;getMethods(); //循环方法 foreach ($action_names as $ak=&gt;$av)&#123; $av_real = $av-&gt;name; $desc = $av-&gt;getDocComment(); //控制器名称 if (!preg_match('/@name\s+(\w+)/u', $desc, $catch)) continue; $name = $catch[1]; //控制器描述 $description = preg_match('/@desc\s+(\w+)/u', $desc, $catch) ? $catch[1] : ''; if(in_array($av_real,$action_base_name) || $av_real == '__construct')&#123; continue; &#125;else&#123; $pris[] = [ 'module_name' =&gt;$mv, 'controller' =&gt;$con_name, 'action_name' =&gt;$av_real, 'pri_name' =&gt;$name, 'pri_desc' =&gt;$description ]; &#125; &#125; &#125; &#125; return $pris; &#125; /** * 获取所有控制器名称 * @param string $module * @return array */ protected function getController($module)&#123; if(empty($module))&#123; return null; &#125; $module_path = app_path('Http\Controllers').'/'.$module;//模块路径 $module_path = str_replace('\\','/',$module_path); if(!is_dir($module_path)) &#123; return null; &#125;; $module_path .= '/*.php'; $ary_files = glob($module_path); $files= []; foreach ($ary_files as $file)&#123; if(is_dir($file) || basename($file,'.php') =='LoginController')&#123; continue; &#125;else&#123; $files[]=config('app.name_space').'\\'.$module.'\\'.basename($file,'.php'); &#125; &#125; return $files; &#125;&#125; 添加权限123456789101112131415161718192021222324252627282930/** * @name 系统权限添加入库 * @desc 系统权限添加入库 * @return mixed */ public function refreshPri() &#123; $rbac = new Rbac(); $pris = $rbac-&gt;getAccess(); $ids = [] ; //更新或者添加的ID foreach ($pris as $k=&gt;$v)&#123; //添加或者更新已有权限 $pri = $this-&gt;updateOrCreate([ 'module_name' =&gt;$v['module_name'], 'controller' =&gt;$v['controller'], 'action_name' =&gt;$v['action_name'] ],[ 'pri_name' =&gt;$v['pri_name'], 'pri_desc' =&gt;$v['pri_desc'] ]); $ids[] = $pri-&gt;id; &#125; //去掉删除的权限 $old_ids = json_decode($this-&gt;pluck('id'),true); $delete_ids = array_diff($old_ids,$ids); foreach ($delete_ids as $v)&#123; $this-&gt;destroy($v); &#125; return true; &#125; 到这里php处理得就差不多了，然后就是前段展示的问题 展示权限截个图… 权限控制权限检测都在中间件中进行，定义AdminNeedsPermission中间件 12345678910111213141516171819202122232425262728293031&lt;?phpnamespace App\Http\Middleware;use Closure;class AdminNeedsPermission&#123; /** * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure $next * @return mixed */ public function handle($request, Closure $next) &#123; //公共包不做权限验证 if($request-&gt;is('common/*'))&#123; return $next($request); &#125; if(checkPri($request-&gt;path()))&#123; if(\Request::ajax())&#123; return response()-&gt;json(msg('error','您没有权限访问！')); &#125; return redirect('admin')-&gt;with(['SYS_INFO'=&gt;'您没有权限访问！']); &#125; return $next($request); &#125;&#125; checkPri方法：添加到辅助方法helper中 1234567891011121314151617181920212223242526/** * 检测权限 */if ( ! function_exists('checkPri'))&#123; function checkPri($url)&#123; if($url == 'admin')&#123;//首页不验证 return false; &#125; $pris = SC::getUserAccess(); if(count($pris)&gt;0)&#123; if(!is_array($url))&#123; $url = explode('/',$url); &#125; foreach ($pris as $pri)&#123; if($pri-&gt;admin_id ===1)&#123; return false; &#125; if(strtolower($url[0]) == strtolower($pri-&gt;module_name) &amp;&amp; strtolower($url[1]) == strtolower($pri-&gt;controller) &amp;&amp; strtolower($url[2]) == strtolower($pri-&gt;action_name))&#123; return false; &#125; &#125; &#125; return true; &#125;&#125; 总结：实现起来并不复杂，从此不必手动一个个添加权限了 以上代码都在项目https://github.com/ycp19940225/blog可以找到 ——END]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PBAC</tag>
        <tag>reflection</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel Eloquent ORM 模型关联 使用总结]]></title>
    <url>%2F2018%2F07%2F16%2Flaravel-Eloquent-ORM-%E6%A8%A1%E5%9E%8B%E5%85%B3%E8%81%94-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在lavaral中可以直接使用DB查询构建器写sql关联语句，其实挺方便，程序执行效率也会更高。ORM主要应该使用于关联查询比较多的情景。主要是前3种关联用的多。返回的数据是集合类型。 简介laravel当中主要有以下几种关联关系： 一对一 一对多 多对多 远程一对多 多态关联 多对多的多态关联主要是前3种关联用的多。返回的数据是集合类型。 定义关联关系简单定义使用在模型中定义一个函数，比如：1234567891011121314class Users extends Base&#123; protected $table = 'blog_admin'; protected $dateFormat = 'U'; /** * 关联模型 * 属于该用户的身份。 */ public function roles() &#123; return $this-&gt;belongsToMany('App\Models\Admin\Role','blog_admin_role','admin_id','role_id'); &#125;&#125; 使用:按正常查询数据，然后在后面跟上roles属性就行了。需要注意的是，必须是单条记录才能直接使用roles属性。 1$data-&gt;roles; 多条记录需要遍历： 123foreach($data as $v)&#123; $v-&gt;roles;&#125; 关联关系 每种关联关系都有正向关联和反向关联 一对一正向： $this-&gt;hasOne(&#39;要关联的模型名&#39;,&#39;foreign_key&#39;,&#39;local_key&#39;); 反向： $this-&gt;belongsTo(&#39;要关联的模型名&#39;,&#39;local_key&#39;,&#39;foreign_key&#39;); foreign_key:关联模型名对应的外键 local_key:本模型被关联的ID 一对多正向： $this-&gt;hasMany(&#39;要关联的模型名&#39;,&#39;foreign_key&#39;,&#39;local_key&#39;); 反向： $this-&gt;belongsTo(&#39;要关联的模型名&#39;,&#39;local_key&#39;,&#39;foreign_key&#39;); foreign_key:关联模型名对应的外键 local_key:本模型被关联的ID 比如：一个分类对应多篇文章，一个文章只属于一个分类，我在文章模型中定义 正向关联： 12345678/** * 关联模型 * 属于该文章的分类。 */public function cat()&#123; return $this-&gt;hasMany('App\Models\Admin\Cat','id','cat_id');&#125; 反向关联： 12345678/** * 关联模型 * 属于该文章的分类。 */public function cat()&#123; return $this-&gt;belongsTo('App\Models\Admin\Cat','cat_id','id');&#125; 总结来说,第一个参数就是外键，无论正向反向关联，这里填写数据表中的外键即可 多对多比如一个管理员和角色多对多，中间表明为blog_admin_role,可以这样定义：12345678/** * 关联模型 * 属于该用户的身份。 */ public function roles() &#123; return $this-&gt;belongsToMany('App\Models\Admin\Role','blog_admin_role','admin_id','role_id'); &#125; 插入 &amp; 更新关联模型插入关联模型首先需要获取到模型，比如，添加一片文章，然后添加标签 添加文章 1$this_article = $this-&gt;create($data); 添加标签 1$this_article-&gt;tag()-&gt;attach($tags_id); 移除关联模型获取文章 1$this_article = $this-&gt;find($id); 移除标签 1$this_article-&gt;tag()-&gt;detach($tags_id); 更新关联模型1$this_article-&gt;tag()-&gt;sync($tags_id); sync方法会接受一组数据，他会保存新添加的数据，移除删除掉的数据。 以上便是简单使用orm后，自己的一些理解。 —-更新（2017/12/24） 多对多添加更新中间表当多对多中间表需要添加额外字段，可以这样做 12$this_article-&gt;tag()-&gt;attach($tags_id,['key'=&gt;$value]); 或者将$tags_id改造成以下格式（假如额外字段位tag_val） 123[ &apos;1&apos;=&gt;[&apos;tag_val&apos;=&gt;&apos;tag_1&apos;], &apos;2&apos;=&gt;[&apos;tag_val&apos;=&gt;&apos;tag_2&apos;]] 参考： http://laravelacademy.org/post/6996.html – END]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>orm</tag>
        <tag>关联模型</tag>
      </tags>
  </entry>
</search>
