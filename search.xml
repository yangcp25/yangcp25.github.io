<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法题汇总]]></title>
    <url>%2F2018%2F07%2F22%2F%E7%AE%97%E6%B3%95%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[LeetCode上面的算法题练习记录 算法题汇总主要用c++实现 vector函数： 123456789101112131415161718191.push_back 在数组的最后添加一个数据2.pop_back 去掉数组的最后一个数据3.at 得到编号位置的数据4.begin 得到数组头的指针5.end 得到数组的最后一个单元+1的指针6.front 得到数组头的引用7.back 得到数组的最后一个单元的引用8.max_size 得到vector最大可以是多大9.capacity 当前vector分配的大小10.size 当前使用数据的大小11.resize 改变当前使用数据的大小，如果它比当前使用的大，则填充默认值12.reserve 改变当前vecotr所分配空间的大小13.erase 删除指针指向的数据项14.clear 清空当前的vector15.rbegin 将vector反转后的开始指针返回(其实就是原来的end-1)16.rend 将vector反转构的结束指针返回(其实就是原来的begin-1)17.empty 判断vector是否为空18.swap 与另一个vector交换数据 一、数组旋转数组将包含 n 个元素的数组向右旋转 k 步。 例如，如果 n = 7 , k = 3，给定数组 [1,2,3,4,5,6,7] ，向右旋转后的结果为 [5,6,7,1,2,3,4]。 思路：一是需要申请一个新的数组存数据，二是要取余，确定前进步数。 代码： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: void solution(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; t=nums; for(int i=0;i&lt;nums.size();i++)&#123; nums[(i+k)%nums.size()] =t[i]; &#125; &#125;&#125;;int main()&#123; Solution solution1; vector&lt;int&gt; arr=&#123;1,2,3,4,5,6,7&#125;; solution1.solution(arr,3); vector&lt;int&gt;::iterator it;//声明一个迭代器，来访问vector容器，作用：遍历或者指向vector容器的元素 for(it=arr.begin();it!=arr.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;" "; &#125; return 0;&#125; 从排序数组中删除重复项给定一个有序数组，你需要原地删除其中的重复内容，使每个元素只出现一次,并返回新的长度。 不要另外定义一个数组，您必须通过用 O(1) 额外内存原地修改输入的数组来做到这一点。 思路：判断是否重复，没有重复的数据放在原数组，并重新定义下标。最后重置数组大小。 代码： 123456789101112131415161718192021class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) &#123; return 0; &#125; int n = nums.size(),k=0; for(int i=1;i&lt;n;++i) &#123; if(nums[i] != nums[k]) &#123; nums[++k] = nums[i]; &#125;//if &#125;//for nums.resize(k+1); return k+1; &#125;&#125; 买卖股票的最佳时机 II假设有一个数组，它的第 i 个元素是一个给定的股票在第 i 天的价格。 设计一个算法来找到最大的利润。你可以完成尽可能多的交易（多次买卖股票）。然而，你不能同时参与多个交易（你必须在再次购买前出售股票）。 思路:因为必须买和卖才能获取利润，所以只需确保买卖的时候有利润，就可以实现利润最大 123456789101112131415class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int t = prices.size(),nums=0,d; for(int j=0;j&lt;t;j++)&#123; d =prices[j+1] - prices[j]; if(d&gt;0)&#123; nums +=d; &#125; &#125; return nums; &#125;&#125;; 存在重复给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数应该返回 true。如果每个元素都不相同，则返回 false。 思路：循环判断 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: bool solution(vector&lt;int&gt;&amp; nums) &#123; for(int i = 0;i&lt;nums.size()-1;++i)&#123; for(int j = i;j&lt;nums.size();++j)&#123; if(i!=j)&#123; if(nums[i]==nums[j])&#123; return true; &#125; &#125; &#125; &#125; return false; &#125;&#125;;int main()&#123; Solution solution1; vector&lt;int&gt; arr=&#123;1,2,1,4,5,6,7&#125;; bool res =solution1.solution(arr); cout &lt;&lt;res; return 0;&#125; 只出现一次的数字给定一个整数数组，除了某个元素外其余元素均出现两次。请找出这个只出现一次的元素。 思路：复制一个数组，循环比较，如不相同的次数是长度-1，那这个就是唯一的，否则不相同次数应该为长度-2。。。。 代码： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int solution(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; t=nums; for(int i =0;i&lt;nums.size();++i)&#123; int sum = 0; for(int j=0;j&lt;nums.size();++j)&#123; if(nums[i]!=t[j])&#123; sum++; &#125; &#125; if(sum ==nums.size()-1)&#123; return nums[i]; &#125; &#125; &#125;&#125;;int main()&#123; Solution solution1; vector&lt;int&gt; arr=&#123;2,4,6,6,2,7,7&#125;; int res =solution1.solution(arr); cout&lt;&lt;res; return 0;&#125; 科学算法： 要用到异或. 思路：遍历数组，异或得到的就是与其他都不一样的数 代码： 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: int solution(vector&lt;int&gt;&amp; nums) &#123; int count=0; for(int i=0;i&lt;nums.size();i++)&#123; count^=nums[i]; &#125; return count; &#125;&#125;;int main()&#123; Solution solution1; vector&lt;int&gt; arr=&#123;2,4,6,6,2,7,7&#125;; int res =solution1.solution(arr); cout&lt;&lt;res; return 0;&#125; 两个数组的交集 II给定两个数组，写一个方法来计算它们的交集。 例如:给定 nums1 = [1, 2, 2, 1], nums2 = [2, 2], 返回 [2, 2]. 注意： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。 我们可以不考虑输出结果的顺序。跟进: 如果给定的数组已经排好序呢？你将如何优化你的算法？如果 nums1 的大小比 nums2 小很多，哪种方法更优？如果nums2的元素存储在磁盘上，内存是有限的，你不能一次加载所有的元素到内存中，你该怎么办？ 思路：遍历数组，以某个数组为标准，当相同的时候，把数据放入新数组，将有交集的数从另外一个数组删除掉，然后继续比较。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;template &lt;class T&gt;int getArrayLen(T&amp; array) //使用模板定义一个函数getArrayLen,该函数将返回数组array的长度&#123; return (sizeof(array) / sizeof(array[0]));&#125;class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; nums3; int k=0,i=0,j=0; vector&lt;int&gt;::iterator it; for(i=0;i&lt;nums1.size();i++)&#123; for(it=nums2.begin();it!=nums2.end();it++) &#123; if(nums1[i] == *it)&#123; nums3.push_back(nums1[i]); nums2.erase(it); break; &#125; &#125; &#125; return nums3; &#125;&#125;;int main()&#123; Solution solution; vector&lt;int&gt; arr1=&#123;1,2,2,1&#125;; vector&lt;int&gt; arr2=&#123;2,2&#125;; vector&lt;int&gt; res =solution.intersect(arr1,arr2); vector&lt;int&gt;::iterator it; for(it=res.begin();it!=res.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;" "; &#125; return 0;&#125; 加一给定一个非负整数组成的非空数组，在该数的基础上加一，返回一个新的数组。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 123456示例 2:输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 一开始没看懂题目的意思，，就是一个整数，按高位到低位（百十个），比如123,1是百位，由它开始，放入数组，组成[‘1’,2,3],然后这个整数加1，得到124，[1,2,4],然后返回[1,2,4]。感觉这道题有点怪。 思路： 代码： 12]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础]]></title>
    <url>%2F2018%2F07%2F22%2FJAVA%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一个Java程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。 JAVA基础一、JAVA基础一个Java程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。 对象：对象是类的一个实例，有状态和行为 类：类是一个模板，它描述一类对象的行为和状态。 方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 基本语法编写Java程序时，应注意以下几点： 大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。 类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。 源文件名：源文件名必须和类名相同。当保存文件的时候，应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。 主方法入口：所有的Java 程序由public static void main(String []args)方法开始执行。 Java标识符Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。关于Java标识符，有以下几点需要注意： 所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始 首字符之后可以是字母（A-Z或者a-z）,美元符（$）、下划线（_）或数字的任何字符组合 关键字不能用作标识符 标识符是大小写敏感的 合法标识符举例：age、$salary、_value、__1_value 非法标识符举例：123abc、-salary Java修饰符像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符： 访问控制修饰符 : default, public , protected, private 非访问控制修饰符 : final, abstract, strictfp Java变量Java中主要有如下几种类型的变量 局部变量 类变量（静态变量） 成员变量（非静态变量） Java数组数组是储存在堆上的对象，可以保存多个同类型变量。 Java枚举ava 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的bug。 枚举可以单独声明或者声明在类里面。方法、变量、构造函数也可以在枚举中定义 Java关键字下面列出了Java保留字。这些保留字不能用于常量、变量、和任何标识符的名称。 继承在Java中，一个类可以由其他类派生。如果要创建一个类，而且已经存在一个类具有所需要的属性或方法，那么可以将新创建的类继承该类。利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（subclass）。 接口在Java中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。 Java 源程序与编译型运行区别 二、Java 对象和类Java作为一种面向对象语言。支持以下基本概念： 多态 继承 封装 抽象 类 对象 实例 方法 重载 对象：对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是一个模板，它描述一类对象的行为和状态。 Java中的对象软件对象有状态和行为。软件对象的状态就是属性，行为通过方法体现。在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。 Java中的类实例： 1234567891011121314public class Dog&#123; String breed; int age; String color; void barking()&#123; &#125; void hungry()&#123; &#125; void sleeping()&#123; &#125;&#125; 一个类可以包含以下类型变量： 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。 类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。 一个类可以拥有多个方法，在上面的例子中：barking()、hungry()和sleeping()都是Dog类的方法 构造方法每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。 创建对象对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步： 声明：声明一个对象，包括对象名称和对象类型。 实例化：使用关键字new来创建一个对象。 初始化：使用new创建对象时，会调用构造方法初始化对象。 实例： 1234567891011public class Puppy&#123; public Puppy(String name) &#123; System.out.println("名字是"+name); &#125; public static void main(String []args) &#123; Puppy myPuppy = new Puppy("pipigo"); &#125;&#125; 访问实例变量和方法通过已创建的对象来访问成员变量和成员方法，如下所示： 1234567/* 实例化对象 */ObjectReference = new Constructor();/* 访问类中的变量 */ObjectReference.variableName;/* 访问类中的方法 */ObjectReference.MethodName(); 实例： 1234567891011121314151617181920212223public class Puppy&#123; int puppyAge; public Puppy(String name) &#123; System.out.println("名字是"+name); &#125; public void setAge(int age) &#123; puppyAge = age; &#125; public int getAge() &#123; System.out.println("皮皮虾的年纪为"+puppyAge); return puppyAge; &#125; public static void main(String []args) &#123; Puppy myPuppy = new Puppy("pipigo"); myPuppy.setAge(12); myPuppy.getAge(); System.out.println("年纪"+myPuppy.puppyAge); &#125;&#125; 结果: 名字是pipigo 皮皮虾的年纪为12 年纪12 源文件声明规则当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。 一个源文件中只能有一个public类 一个源文件可以有多个非public类 源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。 如果一个类定义在某个包中，那么package语句应该在源文件的首行。 如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。 import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。 类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。 除了上面提到的几种类型，Java还有一些特殊的类，如：内部类、匿名类。 Java包包主要用来对类和接口进行分类。当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。 Import语句在Java中，如果给出一个完整的限定名，包括包名、类名，那么Java编译器就可以很容易地定位到源代码或者类。Import语句就是用来提供一个合理的路径，使得编译器可以找到某个类。例如 import java.io.*; 命令行将会命令编译器载入java_installation/java/io路径下的所有类 三、Java 基本数据类型变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。 内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。 因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。Java 的两大数据类型: 内置数据类型 引用数据类型 内置数据类型ava语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 byte： byte 数据类型是8位、有符号的，以二进制补码表示的整数； 最小值是 -128（-2^7）； 最大值是 127（2^7-1）； 默认值是 0； byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一； 例子：byte a = 100，byte b = -50。 short： short 数据类型是 16 位、有符号的以二进制补码表示的整数 最小值是 -32768（-2^15）； 最大值是 32767（2^15 - 1）； Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一； 默认值是 0； 例子：short s = 1000，short r = -20000。 int： int 数据类型是32位、有符号的以二进制补码表示的整数； 最小值是 -2,147,483,648（-2^31）； 最大值是 2,147,483,647（2^31 - 1）； 一般地整型变量默认为 int 类型； 默认值是 0 ； 例子：int a = 100000, int b = -200000。 long： long 数据类型是 64 位、有符号的以二进制补码表示的整数； 最小值是 -9,223,372,036,854,775,808（-2^63）； 最大值是 9,223,372,036,854,775,807（2^63 -1）； 这种类型主要使用在需要比较大整数的系统上； 默认值是 0L； 例子： long a = 100000L，Long b = -200000L。 “L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。 float： float 数据类型是单精度、32位、符合IEEE 754标准的浮点数； float 在储存大型浮点数组的时候可节省内存空间； 默认值是 0.0f； 浮点数不能用来表示精确的值，如货币； 例子：float f1 = 234.5f。 double： double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数； 浮点数的默认类型为double类型； double类型同样不能表示精确的值，如货币； 默认值是 0.0d； 例子：double d1 = 123.4。 boolean： boolean数据类型表示一位的信息； 只有两个取值：true 和 false； 这种类型只作为一种标志来记录 true/false 情况； 默认值是 false； 例子：boolean one = true。 char： char类型是一个单一的 16 位 Unicode 字符； 最小值是 \u0000（即为0）； 最大值是 \uffff（即为65,535）； char 数据类型可以储存任何字符； 例子：char letter = &#39;A&#39;;。 Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的”E+数字”表示E之前的数字要乘以10的多少次方。比如3.14E3就是3.14 × 103 =3140，3.14E-3 就是 3.14 x 10-3 =0.00314。实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。 引用类型 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。 对象、数组都是引用数据类型。 所有引用类型的默认值都是null。 一个引用变量可以用来引用任何与之兼容的类型。 例子：Site site = new Site(&quot;Runoob&quot;)。 Java 常量常量在程序运行时是不能被修改的。 在 Java 中使用 final关键字来修饰常量，声明方式和变量类似： final double PI = 3.1415927; 虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。 字面量可以赋给任何内置类型的变量。例如：byte a = 68; char a = &#39;A&#39;byte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示。 当使用常量的时候，前缀 0 表示 8 进制，而前缀 0x 代表 16 进制, 例如：int decimal = 100; int octal = 0144; int hexa = 0x64; 和其他语言一样，Java的字符串常量也是包含在两个引号之间的字符序列. 1234"Hello World""two\nlines""\"This is in quotes\"" 字符串常量和字符常量都可以包含任何Unicode字符。例如： 12char a = &apos;\u0001&apos;;String a = &quot;\u0001&quot;; Java语言支持一些特殊的转义字符序列。 符号 字符含义 \n 换行 (0x0a) \r 回车 (0x0d) \f 换页符(0x0c) \b 退格 (0x08) \0 空字符 (0x20) \s 字符串 \t 制表符 \” 双引号 \’ 单引号 \ 反斜杠 \ddd 八进制字符 (ddd) \uxxxx 16进制Unicode字符 (xxxx) 自动类型转换整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。转换从低级到高级。 12345低 ------------------------------------&gt; 高byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 数据类型转换必须满足如下规则： 1.不能对boolean类型进行类型转换。 2.不能把对象类型转换成不相关类的对象。 3.在把容量大的类型转换为容量小的类型时必须使用强制类型转换。 4.转换过程中可能导致溢出或损失精度因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。，例如：int i =128;byte b = (byte)i; 5.浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入 自动类型转换必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。 强制类型转换 1.条件是转换的数据类型必须是兼容的。 2.格式：(type)value type是要强制类型转换后的数据类型 隐含强制类型转换 1.整数的默认类型是 int。 2.浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或者 f。 四、Java 变量类型在Java语言中，所有的变量在使用前必须声明。声明变量的基本格式如下： type identifier [ = value][, identifier [= value] ...] ; 格式说明：type为Java数据类型。identifier是变量名。可以使用逗号隔开来声明多个同类型变量。 Java语言支持的变量类型有： 类变量：独立于方法之外的变量，用 static 修饰。 实例变量：独立于方法之外的变量，不过没有 static 修饰。 局部变量：类的方法中的变量。 Java 局部变量 局部变量声明在方法、构造方法或者语句块中； 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁； 访问修饰符不能用于局部变量； 局部变量只在声明它的方法、构造方法或者语句块中可见； 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 实例变量 实例变量声明在一个类中，但在方法、构造方法和语句块之外； 当一个对象被实例化之后，每个实例变量的值就跟着确定； 实例变量在对象创建的时候创建，在对象被销毁的时候销毁； 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息； 实例变量可以声明在使用前或者使用后； 访问修饰符可以修饰实例变量； 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见； 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定； 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。 类变量（静态变量） 类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。 静态变量在程序开始时创建，在程序结束时销毁。 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。 静态变量可以通过：ClassName.VariableName的方式访问。 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。 如果其他类想要访问该变量，可以这样访问：Employee.DEPARTMENT。 Java 修饰符Java语言提供了很多修饰符，主要分为以下两类： 访问修饰符 非访问修饰符 访问控制修饰符Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。 default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 默认访问修饰符-不使用任何关键字使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为 public static final,而接口里的方法默认情况下访问权限为 public。 私有访问修饰符-private私有访问修饰符是最严格的访问级别，所以被声明为 private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。 公有访问修饰符-public被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。 如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。 以下函数使用了公有访问控制： 123public static void main(String[] arguments) &#123; // ...&#125; Java 程序的 main() 方法必须设置成公有的，否则，Java 解释器将不能运行该类 受保护的访问修饰符-protectedprotected 需要从以下两个点来分析说明： 子类与基类在同一包中：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问； 子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。 protected 访问修饰符不能修饰类和接口，方法和成员变量能够声明为 protected，但是接口的成员变量和成员方法不能声明为 protected。子类能访问 protected 修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。 访问控制和继承方法继承的规则： 父类中声明为 public 的方法在子类中也必须为 public。 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。 父类中声明为 private 的方法，不能够被继承。 非访问修饰符为了实现一些其他的功能，Java 也提供了许多非访问修饰符。 static 修饰符，用来修饰类方法和类变量。final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。abstract 修饰符，用来创建抽象类和抽象方法。synchronized 和 volatile 修饰符，主要用于线程的编程。 static 修饰符 静态变量：static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。 静态方法：static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。对类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname 的方式访问。 final 修饰符final 变量： final 变量能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。final 修饰符通常和 static 修饰符一起使用来创建类常量。 final 方法 类中的 final 方法可以被子类继承，但是不能被子类修改。声明 final 方法的主要目的是防止该方法的内容被修改。 final 类 final 类不能被继承，没有类能够继承 final 类的任何特性。 abstract 修饰符抽象类： 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。抽象类可以包含抽象方法和非抽象方法。 抽象方法抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成 final 和 static。任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 synchronized 修饰符synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。 transient 修饰符序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。 olatile 修饰符volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 一个 volatile 对象引用可能是 null。 五、Java Number &amp; Math 类般地，当需要使用数字的时候，我们通常使用内置数据类型，如：byte、int、long、double 等。 然而，在实际开发过程中，经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，Java 语言为每一个内置数据类型提供了对应的包装类。所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。 这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。 Java Math 类Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。 Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。 1234567891011public class PuppyTest &#123; public static void main(String args[]) &#123; System.out.println("90度的正弦"+Math.sin(Math.PI/2)); System.out.println("90度的余弦"+Math.cos(0)); System.out.println("60度的正切"+Math.tan(Math.PI/3)); System.out.println("1的的反正切"+Math.atan(1)); System.out.println(Math.PI); &#125;&#125; 结果: 12345690度的正弦1.090度的余弦1.060度的正切1.73205080756887671的的反正切0.78539816339744833.141592653589793 Number &amp; Math 类方法表中列出的是 Number &amp; Math 类常用的一些方法： 序号 方法与描述 1 xxxValue()将 Number 对象转换为xxx数据类型的值并返回。 2 compareTo()将number对象与参数比较。 3 equals()判断number对象是否与参数相等。 4 valueOf()返回一个 Number 对象指定的内置数据类型 5 toString()以字符串形式返回值。 6 parseInt()将字符串解析为int类型。 7 abs()返回参数的绝对值。 8 ceil()返回大于等于( &gt;= )给定参数的的最小整数。 9 floor()返回小于等于（&lt;=）给定参数的最大整数 。 10 rint()返回与参数最接近的整数。返回类型为double。 11 round()它表示四舍五入，算法为 Math.floor(x+0.5)，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。 12 min()返回两个参数中的最小值。 13 max()返回两个参数中的最大值。 14 exp()返回自然数底数e的参数次方。 15 log()返回参数的自然数底数的对数值。 16 pow()返回第一个参数的第二个参数次方。 17 sqrt()求参数的算术平方根。 18 sin()求指定double类型参数的正弦值。 19 cos()求指定double类型参数的余弦值。 20 tan()求指定double类型参数的正切值。 21 asin()求指定double类型参数的反正弦值。 22 acos()求指定double类型参数的反余弦值。 23 atan()求指定double类型参数的反正切值。 24 atan2()将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。 25 toDegrees()将参数转化为角度。 26 toRadians()将角度转换为弧度。 27 random()返回一个随机数。 六、Java Character 类Character 类用于对单个字符进行操作。Character 类在对象中包装一个基本类型 char 的值。 实际开发过程中，经常会遇到需要使用对象，而不是内置数据类型的情况。为了解决这个问题，Java语言为内置数据类型char提供了包装类Character类。Character类提供了一系列方法来操纵字符。你可以使用Character的构造方法创建一个Character类对象，例如： Character ch = new Character(&#39;a&#39;); 在某些情况下，Java编译器会自动创建一个Character对象。例如，将一个char类型的参数传递给需要一个Character类型参数的方法时，那么编译器会自动地将char类型参数转换为Character对象。 这种特征称为装箱，反过来称为拆箱。 Character 方法下面是Character类的方法： 序号 方法与描述 1 isLetter()是否是一个字母 2 isDigit()是否是一个数字字符 3 isWhitespace()是否是一个空格 4 isUpperCase()是否是大写字母 5 isLowerCase()是否是小写字母 6 toUpperCase()指定字母的大写形式 7 toLowerCase()指定字母的小写形式 8 toString()返回字符的字符串形式，字符串的长度仅为1 七、Java String 类字符串广泛应用 在Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。 创建字符串创建字符串最简单的方式如下: String greeting = &quot;ycp&quot;; 在代码中遇到字符串常量时，这里的值是 “菜鸟教程””，编译器会使用该值创建一个 String 对象。和其它对象一样，可以使用关键字和构造方法来创建 String 对象。String 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，比如提供一个字符数组参数: 12345678StringDemo.java 文件代码：public class StringDemo&#123; public static void main(String args[])&#123; char[] helloArray = &#123; 'y', 'c', 'p'&#125;; String helloString = new String(helloArray); System.out.println( helloString ); &#125;&#125; 以上实例编译运行结果如下：`ycp注意:String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了 如果需要对字符串做很多修改，那么应该选择使用 StringBuffer &amp; StringBuilder 类。 连接字符串String 类提供了连接两个字符串的方法： string1.concat(string2); 返回 string2 连接 string1 的新字符串。也可以对字符串常量使用 concat() 方法，如： &quot;我的名字是 &quot;.concat(&quot;YCp&quot;);更常用的是使用’+’操作符来连接字符串，如： &quot;Hello,&quot; + &quot; ycp&quot; + &quot;!&quot; 创建格式化字符串输出格式化数字可以使用 printf() 和 format() 方法。String 类使用静态方法 format() 返回一个String 对象而不是 PrintStream 对象。String 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。 String 方法八、Java StringBuffer 和 StringBuilder 类当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。 StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。 由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。 12345678910public class PuppyTest &#123; public static void main(String args[]) &#123; StringBuffer sBuffer =new StringBuffer("ycp"); sBuffer.append("180cm"); sBuffer.append("18cm"); System.out.println(sBuffer); &#125;&#125; StringBuffer 方法以下是 StringBuffer 类支持的主要方法： 序号 方法描述 1 public StringBuffer append(String s)将指定的字符串追加到此字符序列。 2 public StringBuffer reverse()将此字符序列用其反转形式取代。 3 public delete(int start, int end)移除此序列的子字符串中的字符。 4 public insert(int offset, int i)将 int 参数的字符串表示形式插入此序列中。 5 replace(int start, int end, String str)使用给定 String 中的字符替换此序列的子字符串中的字符。 下面的列表里的方法和 String 类的方法类似：序号 |方法描述-|-1 |int capacity()返回当前容量。2 |char charAt(int index)返回此序列中指定索引处的 char 值。3 |void ensureCapacity(int minimumCapacity)确保容量至少等于指定的最小值。4 |void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)将字符从此序列复制到目标字符数组 dst。5 |int indexOf(String str)返回第一次出现的指定子字符串在该字符串中的索引。6 |int indexOf(String str, int fromIndex)从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。7 |int lastIndexOf(String str)返回最右边出现的指定子字符串在此字符串中的索引。8 |int lastIndexOf(String str, int fromIndex)返回 String 对象中子字符串最后出现的位置。9 |int length() 返回长度（字符数）。10 |void setCharAt(int index, char ch)将给定索引处的字符设置为 ch。11 |void setLength(int newLength)设置字符序列的长度。12 |CharSequence subSequence(int start, int end)返回一个新的字符序列，该字符序列是此序列的子序列。13 |String substring(int start)返回一个新的 String，它包含此字符序列当前所包含的字符子序列。14 |String substring(int start, int end)返回一个新的 String，它包含此序列当前所包含的字符子序列。15 |String toString()返回此序列中数据的字符串表示形式。 Java 中 StringBuffer 和 String 是有一定的区别的，首先，String 是被 final 修饰的，他的长度是不可变的，就算调用 String 的concat 方法，那也是把字符串拼接起来并重新创建一个对象，把拼接后的 String 的值赋给新创建的对象，而 StringBuffer 的长度是可变的，调用StringBuffer 的 append 方法，来改变 StringBuffer 的长度，并且，相比较于 StringBuffer，String 一旦发生长度变化，是非常耗费内存的！ 九、Java 数组ava 语言中提供的数组是用来存储固定大小的同类型元素。 十、Java 流(Stream)、文件(File)和IOJava.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。 读取控制台输入Java 的控制台输入由 System.in 完成。为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。下面是创建 BufferedReader 的基本语法：12BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。 从 BufferedReader 对象读取一个字符要使用 read() 方法，它的语法如下：int read( ) throws IOException每次调用 read() 方法，它从输入流读取一个字符并把该字符作为整数值返回。 当流结束的时候返回 -1。该方法抛出 IOException。 1234567891011121314151617import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class PuppyTest &#123; public static void main(String args[]) throws IOException&#123; char c; BufferedReader brBufferedReader =new BufferedReader(new InputStreamReader(System.in)); do &#123; c = (char) brBufferedReader.read(); System.out.println(c); &#125;while(c != 'q'); &#125;&#125; 从控制台读取字符串从标准输入读取一个字符串需要使用 BufferedReader 的 readLine() 方法。它的一般格式是： String readLine( ) throws IOException 下面的程序读取和显示字符行直到你输入了单词”end”。代码： 123456789101112131415161718// 使用 BufferedReader 在控制台读取字符import java.io.*;public class BRReadLines &#123; public static void main(String args[]) throws IOException &#123; // 使用 System.in 创建 BufferedReader BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str; System.out.println("Enter lines of text."); System.out.println("Enter 'end' to quit."); do &#123; str = br.readLine(); System.out.println(str); &#125; while(!str.equals("end")); &#125;&#125; 控制台输出控制台的输出由 print( ) 和 println() 完成。这些方法都由类 PrintStream 定义，System.out 是该类对象的一个引用。PrintStream 继承了 OutputStream类，并且实现了方法 write()。这样，write() 也可以用来往控制台写操作。PrintStream 定义 write() 的最简单格式如下所示： void write(int byteval) 该方法将 byteval 的低八位字节写到流中。 读写文件一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。 FileInputStream该流用于从文件读取数据，它的对象可以用关键字 new 来创建。有多种构造方法可用来创建对象。可以使用字符串类型的文件名来创建一个输入流对象来读取文件： InputStream f = new FileInputStream(&quot;C:/java/hello&quot;); 也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象： File f = new File(&quot;C:/java/hello&quot;);InputStream out = new FileInputStream(f); 创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。 序号 方法及描述 1 public void close() throws IOException{}关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。 2 protected void finalize()throws IOException {}这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。 3 public int read(int r)throws IOException{}这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。 4 public int read(byte[] r) throws IOException{}这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。 5 public int available() throws IOException{}返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。 除了 InputStream 外，还有一些其他的输入流: ByteArrayInputStream DataInputStream FileOutputStream该类用来创建一个文件并向文件中写数据。如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。有两个构造方法可以用来创建 FileOutputStream 对象。使用字符串类型的文件名来创建一个输出流对象： OutputStream f = new FileOutputStream(&quot;C:/java/hello&quot;) 也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象： File f = new File(&quot;C:/java/hello&quot;);OutputStream f = new FileOutputStream(f); 创建OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。 序号 方法及描述 1 public void close() throws IOException{}关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。 2 protected void finalize()throws IOException {}这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。 3 public void write(int w)throws IOException{}这个方法把指定的字节写到输出流中。 4 public void write(byte[] w)把指定数组中w.length长度的字节写到OutputStream中。 除了OutputStream外，还有一些其他的输出流 ByteArrayOutputStream DataOutputStream 实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.io.*; public class fileStreamTest2&#123; public static void main(String[] args) throws IOException &#123; File f = new File("a.txt"); FileOutputStream fop = new FileOutputStream(f); // 构建FileOutputStream对象,文件不存在会自动新建 OutputStreamWriter writer = new OutputStreamWriter(fop, "UTF-8"); // 构建OutputStreamWriter对象,参数可以指定编码,默认为操作系统默认编码,windows上是gbk writer.append("中文输入"); // 写入到缓冲区 writer.append("\r\n"); //换行 writer.append("English"); // 刷新缓存冲,写入到文件,如果下面已经没有写入的内容了,直接close也会写入 writer.close(); //关闭写入流,同时会把缓冲区内容写入文件,所以上面的注释掉 fop.close(); // 关闭输出流,释放系统资源 FileInputStream fip = new FileInputStream(f); // 构建FileInputStream对象 InputStreamReader reader = new InputStreamReader(fip, "UTF-8"); // 构建InputStreamReader对象,编码与写入相同 StringBuffer sb = new StringBuffer(); while (reader.ready()) &#123; sb.append((char) reader.read()); // 转成char加到StringBuffer对象中 &#125; System.out.println(sb.toString()); reader.close(); // 关闭读取流 fip.close(); // 关闭输入流,释放系统资源 &#125;&#125; Java中的目录创建目录：File类中有两个方法可以用来创建文件夹： mkdir( )方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。 mkdirs()方法创建一个文件夹和它的所有父文件夹。 Java 在 UNIX 和 Windows 自动按约定分辨文件路径分隔符。如果你在 Windows 版本的 Java 中使用分隔符 (/) ，路径依然能够被正确解析。 读取目录 一个目录其实就是一个 File 对象，它包含其他文件和文件夹。如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。 删除目录或文件 删除文件可以使用 java.io.File.delete() 方法。以下代码会删除目录/tmp/java/，即便目录不为空。 十一、Java Scanner 类java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。下面是创建 Scanner 对象的基本语法： Scanner s = new Scanner(System.in); 通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据： 十二、Java 异常处理异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。 异常发生的原因有很多，通常包含以下几大类： 用户输入了非法数据。 要打开的文件不存在。 网络通信时连接中断，或者JVM内存溢出。 这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。 要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常： 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。 运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。 错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。 Exception 类的层次所有的异常类是从 java.lang.Exception 类继承的子类。Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。Error 用来指示运行时环境发生的错误。 异常类有两个主要的子类：IOException 类和 RuntimeException 类。 Java 内置异常类Java 语言定义了一些异常类在 java.lang 标准包中。标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。 finally关键字finally 关键字用来创建在 try 代码块后面执行的代码块。无论是否发生异常，finally 代码块中的代码总会被执行。在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。finally 代码块出现在 catch 代码块最后，语法如下： 123456789try&#123; // 程序代码&#125;catch(异常类型1 异常的变量名1)&#123; // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码&#125;finally&#123; // 程序代码&#125; 通用异常在Java中定义了两种类型的异常和错误。 JVM(Java虚拟机) 异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。 程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++资源库]]></title>
    <url>%2F2018%2F07%2F22%2FC-%E8%B5%84%E6%BA%90%E5%BA%93%2F</url>
    <content type="text"><![CDATA[C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。 C++资源库一、C++ STLC++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。 C++ 标准模板库的核心包括以下三个组件： 组件 描述 容器（Containers） 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 算法（Algorithms） 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 迭代器（iterators） 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 这三个组件都带有丰富的预定义函数，帮助我们通过简单的方式处理复杂的任务。 实例： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; vec; int i; cout&lt;&lt;"vec原始大小"&lt;&lt;vec.size()&lt;&lt;endl; for(i = 0;i&lt;5;i++)&#123; vec.push_back(i); &#125; cout&lt;&lt;"vec拓展后的大小"&lt;&lt;vec.size()&lt;&lt;endl; for(i = 0;i&lt;5;i++)&#123; cout&lt;&lt;"访问值："&lt;&lt;vec[i]&lt;&lt;endl; &#125; //使用迭代器访问值 vector&lt;int&gt;::iterator v = vec.begin(); while (v != vec.end())&#123; cout&lt;&lt;"迭代器访问值："&lt;&lt; *v &lt;&lt;endl; v++; &#125; return 0;&#125; 结果: 123456789101112vec原始大小0vec拓展后的大小5访问值：0访问值：1访问值：2访问值：3访问值：4迭代器访问值：0迭代器访问值：1迭代器访问值：2迭代器访问值：3迭代器访问值：4 其中: push_back( ) 成员函数在向量的末尾插入值，如果有必要会扩展向量的大小。 size( ) 函数显示向量的大小。 begin( ) 函数返回一个指向向量开头的迭代器。 end( ) 函数返回一个指向向量末尾的迭代器。 二、C++ 标准库C++ 标准库可以分为两部分： 标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。 面向对象类库： 这个库是类及其相关函数的集合。C++ 标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改。 标准函数库标准函数库分为以下几类： 输入/输出 I/O 字符串和字符处理 数学 时间、日期和本地化 动态分配 其他 宽字符函数 面向对象类库标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入/输出 I/O、字符串处理、数值处理。面向对象类库包含以下内容： 标准的 C++ I/O 类 String 类 数值类 STL 容器类 STL 算法 STL 函数对象 STL 迭代器 STL 分配器 本地化库 异常处理类 杂项支持库]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 进阶]]></title>
    <url>%2F2018%2F07%2F22%2FC-%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[文件和流、异常、内存、多线程、web编程 —– 基础知识 C++ 进阶一、C++ 文件和流iostream 标准库，它提供了 cin 和 cout 方法分别用于从标准输入读取流和向标准输出写入流。 C++ 中另一个标准库 fstream，它定义了三个新的数据类型： 数据类型 描述 ofstream 该数据类型表示输出文件流，用于创建文件并向文件写入信息。 ifstream 该数据类型表示输入文件流，用于从文件读取信息。 fstream 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 和 。 打开文件在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象。下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 void open(const char *filename, ios::openmode mode); 在这里，open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。 模式标志 描述 ios::app 追加模式。所有写入都追加到文件末尾。 ios::ate 文件打开后定位到文件末尾。 ios::in 打开文件用于读取。 ios::out 打开文件用于写入。 ios::trunc 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 如果要以写入模式打开文件，并希望截断文件，以防文件已存在，那么可以使用下面的语法： ofstream outfile; outfile.open(&quot;file.dat&quot;, ios::out | ios::trunc ); 似地，如果想要打开一个文件用于读写，可以使用下面的语法： fstream afile; afile.open(&quot;file.dat&quot;, ios::out | ios::in ); 关闭文件当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件 下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。void close(); 写入文件在 C++ 编程中，使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里使用的是 ofstream 或 fstream 对象，而不是 cout 对象 读取文件在 C++ 编程中，使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里使用的是 ifstream 或 fstream 对象，而不是 cin 对象。 读取 &amp; 写入实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; char data[100]; //写模式打开文件 ofstream outfile; outfile.open("test.dat"); cout &lt;&lt; "写入文件--"&lt;&lt;endl; cout &lt;&lt; "输入你的姓名：" &lt;&lt;endl; cin.getline(data,100); //文件写入 outfile &lt;&lt; data &lt;&lt; endl; cout &lt;&lt;"输入年纪"&lt;&lt;endl; cin &gt;&gt;data; cin.ignore(); //再次文件写入 outfile &lt;&lt;data&lt;&lt;endl; //关闭 outfile.close(); //读模式打开文件 ifstream infile; infile.open("test.dat"); cout &lt;&lt; "从文件读取内容" &lt;&lt;endl; infile &gt;&gt;data; //输出 cout &lt;&lt;data &lt;&lt;endl; //再次读取，输出 cout &lt;&lt; "再次读取文件读取内容" &lt;&lt;endl; infile&gt;&gt;data; cout &lt;&lt;data &lt;&lt;endl; //关闭 infile.close(); return 0;&#125; 结果： 12345678910111213141516171819202122写入文件--输入你的姓名：ycp2ycp2输入年纪1919从文件读取内容ycp2再次读取文件读取内容19 上面的实例中使用了 cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。 文件位置指针istream 和 ostream 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 seekg（”seek get”）和关于 ostream 的 seekp（”seek put”）。 seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 ios::beg（默认的，从流的开头开始定位），也可以是 ios::cur（从流的当前位置开始定位），也可以是 ios::end（从流的末尾开始定位）。 文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get” 文件位置指针的实例： // 定位到 fileObject 的第 n 个字节（假设是 ios::beg） fileObject.seekg( n ); // 把文件的读指针从 fileObject 当前位置向后移 n 个字节 fileObject.seekg( n, ios::cur ); // 把文件的读指针从 fileObject 末尾往回移 n 个字节 fileObject.seekg( n, ios::end ); // 定位到 fileObject 的末尾 fileObject.seekg( 0, ios::end ); 二、C++ 异常处理异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。 异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：try、catch、throw。throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。 catch: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。try: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。 如果有一个块抛出一个异常，捕获异常的方法会使用 try 和 catch 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示： 12345678910111213try&#123; // 保护代码&#125;catch( ExceptionName e1 )&#123; // catch 块&#125;catch( ExceptionName e2 )&#123; // catch 块&#125;catch( ExceptionName eN )&#123; // catch 块&#125; 如果 try 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 catch 语句，用于捕获不同类型的异常。 抛出异常可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。 以下是尝试除以零时抛出异常的实例： 12345678double division(int a, int b)&#123; if( b == 0 ) &#123; throw "Division by zero condition!"; &#125; return (a/b);&#125; 捕获异常catch 块跟在 try 块后面，用于捕获异常。可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。 1234567try&#123; // 保护代码&#125;catch( ExceptionName e )&#123; // 处理 ExceptionName 异常的代码&#125; catch 块跟在 try 块后面，用于捕获异常。可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。1234567try&#123; // 保护代码&#125;catch( ExceptionName e )&#123; // 处理 ExceptionName 异常的代码&#125; 实例： 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;double division(int a ,int b)&#123; if(b == 0)&#123; throw "除数不能为0"; &#125; return (a/b);&#125;int main()&#123; int x = 10; int b = 0; double z = 0; try&#123; z = division(x,b); &#125;catch(const char* msg) &#123; cerr &lt;&lt;msg&lt;&lt;endl; &#125; return 0;&#125; 由于抛出了一个类型为 const char 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 `const char`。当上面的代码被编译和执行时，它会产生下列结果： 除数不能为0 C++ 标准的异常C++ 提供了一系列标准的异常，定义在 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示： 下表是对上面层次结构中出现的每个异常的说明： 异常 描述 std::exception 该异常是所有标准 C++ 异常的父类。 std::bad_alloc 该异常可以通过 new 抛出。 std::bad_cast 该异常可以通过 dynamic_cast 抛出。 std::bad_exception 这在处理 C++ 程序中无法预期的异常时非常有用。 std::bad_typeid 该异常可以通过 typeid 抛出。 std::logic_error 理论上可以通过读取代码来检测到的异常。 std::domain_error 当使用了一个无效的数学域时，会抛出该异常。 std::invalid_argument 当使用了无效的参数时，会抛出该异常。 std::length_error 当创建了太长的 std::string 时，会抛出该异常。 std::out_of_range 该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator。 std::runtime_error 理论上不可以通过读取代码来检测到的异常。 std::overflow_error 当发生数学上溢时，会抛出该异常。 std::range_error 当尝试存储超出范围的值时，会抛出该异常。 std::underflow_error 当发生数学下溢时，会抛出该异常。 定义新的异常可以通过继承和重载 exception 类来定义新的异常实例： 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;exception&gt;using namespace std;struct MyException:public exception&#123; const char * what() const throw()&#123; return "C++ 自定义异常 "; &#125;&#125;;int main()&#123; try &#123; throw MyException(); &#125;catch (MyException&amp; e)&#123; std::cout &lt;&lt; "我的异常" &lt;&lt;std::endl; std::cout &lt;&lt; e.what() &lt;&lt;std::endl; &#125;catch(std::exception&amp; e) &#123; //其他的错误 &#125; return 0;&#125; 结果: 123456789101112131415161718192021222324252627我的异常C++ 自定义异常``` #### 三、**C++ 动态内存**C++ 程序中的内存分为两个部分：* 栈：在函数内部声明的所有变量都将占用栈内存。* 堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存。很多时候，无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。在 C++ 中，可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 `new` 运算符。如果不需要动态分配内存，可以使用 `delete` 运算符，删除之前由 `new` 运算符分配的内存。##### **new 和 delete 运算符**下面是使用 new 运算符来为任意的数据类型动态分配内存的通用语法：`new data-type;`在这里，data-type 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。先来看下内置的数据类型。例如，我们可以定义一个指向 double 类型的指针，然后请求内存，该内存在执行时被分配。我们可以按照下面的语句使用 new 运算符来完成这点：```cppdouble* pvalue = NULL; // 初始化为 null 的指针pvalue = new double; // 为变量请求内存 如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作： 1234567double* pvalue = NULL;if( !(pvalue = new double ))&#123; cout &lt;&lt; "Error: out of memory." &lt;&lt;endl; exit(1); &#125; malloc() 函数在 C 语言中就出现了，在 C++ 中仍然存在，但尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。在任何时候，当觉得某个已经动态分配内存的变量不再需要使用时，可以使用 delete 操作符释放它所占用的内存，如下所示： delete pvalue; // 释放 pvalue 所指向的内存 实例： 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main()&#123; double* pvalue = NULL ;//初始化为null的指针 pvalue =new double; //为变量请求内存 *pvalue = 111111; cout &lt;&lt;"变量的值：" &lt;&lt; *pvalue &lt;&lt;endl; delete pvalue; //释放内存 return 0;&#125; 结果： 变量的值：111111 数组的动态内存分配分配内存 123456789101112131415161718192021char* pvalue = NULL; // 初始化为 null 的指针pvalue = new char[20]; // 为变量请求内存``删除`delete [] pvalue; // 删除 pvalue 所指向的数组`**多维数组分配内存**一位数组```cpp// 动态分配,数组长度为 mint *array=new int [m]； //释放内存delete [] array; 二维数组 123456789101112131415int **array// 假定数组第一维长度为 m， 第二维长度为 n// 动态分配空间array = new int *[m];for( int i=0; i&lt;m; i++ )&#123; array[i] = new int [n] ;&#125;//释放for( int i=0; i&lt;m; i++ )&#123; delete [] arrar[i];&#125;delete [] array; 二维数组实例： 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;int main()&#123; int **p; int i,j; p = new int *[4]; for(i = 0;i&lt;4;i++)&#123; p[i] = new int [8]; &#125; for(i=0;i&lt;4;i++)&#123; for(j=0;j&lt;8;j++)&#123; p[i][j] = j*i; &#125; &#125; //打印 for(i=0;i&lt;4;i++)&#123; for(j=0;j&lt;8;j++)&#123; if(j == 0) cout&lt;&lt;endl; cout&lt;&lt;p[i][j]&lt;&lt;endl; &#125; &#125; //释放内存 for(i=0;i&lt;4;i++)&#123; delete []p[i]; &#125; delete []p; return 0;&#125; 三维数组 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std; int main()&#123; int i,j,k; // p[2][3][4] int ***p; p = new int **[2]; for(i=0; i&lt;2; i++) &#123; p[i]=new int *[3]; for(j=0; j&lt;3; j++) p[i][j]=new int[4]; &#125; //输出 p[i][j][k] 三维数据 for(i=0; i&lt;2; i++) &#123; for(j=0; j&lt;3; j++) &#123; for(k=0;k&lt;4;k++) &#123; p[i][j][k]=i+j+k; cout&lt;&lt;p[i][j][k]&lt;&lt;" "; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl; &#125; // 释放内存 for(i=0; i&lt;2; i++) &#123; for(j=0; j&lt;3; j++) &#123; delete [] p[i][j]; &#125; &#125; for(i=0; i&lt;2; i++) &#123; delete [] p[i]; &#125; delete [] p; return 0;&#125; 对象的动态内存分配对象与简单的数据类型一样。 实例： 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std; class Box&#123; public: Box() &#123; cout &lt;&lt; "调用构造函数！" &lt;&lt;endl; &#125; ~Box() &#123; cout &lt;&lt; "调用析构函数！" &lt;&lt;endl; &#125;&#125;; int main( )&#123; Box* myBoxArray = new Box[4]; delete [] myBoxArray; // 删除数组 return 0;&#125; 如果要为一个包含四个 Box 对象的数组分配内存，构造函数将被调用 4 次，同样地，当删除这些对象时，析构函数也将被调用相同的次数（4次）。当上面的代码被编译和执行时，它会产生下列结果： 12345678调用构造函数！调用构造函数！调用构造函数！调用构造函数！调用析构函数！调用析构函数！调用析构函数！调用析构函数！ 四、命名空间命名空间作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。 定义命名空间命名空间的定义使用关键字 namespace，后跟命名空间的名称，如下所示： 123namespace namespace_name &#123; // 代码声明&#125; 为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示： name::code; // code 可以是变量或函数 实例 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std; // 第一个命名空间namespace first_space&#123; void func()&#123; cout &lt;&lt; "Inside first_space" &lt;&lt; endl; &#125;&#125;// 第二个命名空间namespace second_space&#123; void func()&#123; cout &lt;&lt; "Inside second_space" &lt;&lt; endl; &#125;&#125;int main ()&#123; // 调用第一个命名空间中的函数 first_space::func(); // 调用第二个命名空间中的函数 second_space::func(); return 0;&#125; using 指令可以使用 using namespace 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。 using 指令引入的名称遵循正常的范围规则。名称从使用 using 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。 不连续的命名空间命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素： 1234namespace namespace_name &#123; // 代码声明&#125; 嵌套的命名空间123456namespace namespace_name1 &#123; // 代码声明 namespace namespace_name2 &#123; // 代码声明 &#125;&#125; 可以通过使用 :: 运算符来访问嵌套的命名空间中的成员：// 访问 namespace_name2 中的成员using namespace namespace_name1::namespace_name2; // 访问 namespace:name1 中的成员using namespace namespace_name1; 五、C++ 模板模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。每个容器都有一个单一的定义，比如 向量，我们可以定义许多不同类型的向量，比如 vector &lt;int&gt; 或 vector &lt;string&gt;。 使用模板来定义函数和类。 函数模板模板函数定义的一般形式如下所示： 1234template &lt;class type&gt; ret-type func-name(parameter list)&#123; // 函数的主体&#125; 在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。 实例： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;template &lt;typename T&gt;inline T const&amp; Max (T const&amp; a,T const&amp; b)&#123; return a&lt;b ? b:a;&#125;int main()&#123; int a = 5; int b = 5; cout &lt;&lt; Max(a,b) &lt;&lt;endl; double f1 =1.1; double f2 =1.2; cout &lt;&lt;Max(f1,f2); string s1 = "sss"; string s2 = "aaa"; cout &lt;&lt;max(s1,s1); return 0;&#125; 结果： 5 1.2sss C++ 中 typename 和 class 的区别在 C++ Template 中很多地方都用到了 typename 与 class 这两个关键字，而且好像可以替换，是不是这两个关键字完全一样呢?相信学习 C++ 的人对 class 这个关键字都非常明白，class 用于定义类，在模板引入 c++ 后，最初定义模板的方法为： template&lt;class T&gt;......这里 class 关键字表明T是一个类型，后来为了避免 class 在这两个地方的使用可能给人带来混淆，所以引入了 typename 这个关键字，它的作用同class 一样表明后面的符号为一个类型，这样在定义模板的时候就可以使用下面的方式了： 123template&lt;typenameT&gt;...... 在模板定义语法中关键字 class 与 typename 的作用完全一样。 typename 难道仅仅在模板定义中起作用吗？其实不是这样，typename 另外一个作用为：使用嵌套依赖类型(nested depended name)，如下所示： 12345678910111213class MyArray &#123; public： typedef int LengthType;.....&#125;template&lt;class T&gt;void MyMethod( T myarr ) &#123; typedef typename T::LengthType LengthType; LengthType length = myarr.GetLength; &#125; 这个时候 typename 的作用就是告诉 c++ 编译器，typename 后面的字符串为一个类型名称，而不是成员函数或者成员变量，这个时候如果前面没有typename，编译器没有任何办法知道 T::LengthType 是一个类型还是一个成员名称(静态数据成员或者静态函数)，所以编译不能够通过。 类模板正如定义函数模板一样，也可以定义类模板。泛型类声明的一般形式如下所示： 12345template &lt;class type&gt; class class-name &#123;...&#125; 在这里，type 是占位符类型名称，可以在类被实例化的时候进行指定。可以使用一个逗号分隔的列表来定义多个泛型数据类型。 实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;template &lt;class T&gt;class Stack&#123;private: vector&lt;T&gt; elems; //元素public: void push(T const&amp;); void pop(); T top() const ; bool empty()&#123; return elems.empty(); &#125;&#125;;template&lt;class T&gt;void Stack&lt;T&gt;::push(T const&amp; elem) &#123; elems.push_back(elem);// 追加传入元素的副本&#125;template&lt;class T&gt;void Stack&lt;T&gt;::pop() &#123; if(elems.empty())&#123; throw out_of_range(" 空栈！"); &#125; //删除最后一个元素 elems.pop_back();&#125;template&lt;class T&gt;T Stack&lt;T&gt;::top() const &#123; if (elems.empty()) &#123; throw out_of_range("Stack&lt;&gt;::top(): empty stack"); &#125; // 返回最后一个元素的副本 return elems.back();&#125;int main()&#123; try &#123; Stack&lt;int&gt; intStack; //int 类型的栈 Stack&lt;string&gt; stringStack; //string 类型的栈 intStack.push(54); //入栈 cout&lt;&lt;intStack.top()&lt;&lt;endl; // 返回最后一个元素的副本 stringStack.push("ycpnb"); //入栈 cout&lt;&lt;"字符"&lt;&lt;stringStack.top()&lt;&lt;std::endl;// 返回最后一个元素的副本 stringStack.pop(); // 出栈 stringStack.pop(); // 出栈 &#125;catch(exception const&amp; e) &#123; cerr &lt;&lt;e.what()&lt;&lt;endl; return -1; &#125;&#125; 结果： 123454 空栈！字符ycpnb 六、C++ 预处理器处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令之前所有的实例中都有 #include 指令。这个宏用于把头文件包含到源文件中。C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等。 #define 预处理define 预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式是： #define macro-name replacement-text 当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。例如： 123456789101112#include &lt;iostream&gt;using namespace std; #define PI 3.14159 int main ()&#123; cout &lt;&lt; "Value of PI :" &lt;&lt; PI &lt;&lt; endl; return 0;&#125; 测试这段代码，看看预处理的结果。假设源代码文件已经存在，接下来使用 -E 选项进行编译，并把结果重定向到 test.p。现在，如果查看 test.p 文件，将会看到它已经包含大量的信息，而且在文件底部的值被改为如下： 12345678910$ gcc -E test.cpp &gt; test.p...int main ()&#123; cout &lt;&lt; "Value of PI :" &lt;&lt; 3.14159 &lt;&lt; endl; return 0;&#125; 参数宏可以使用 #define 来定义一个带有参数的宏 实例： 123456789101112131415#include &lt;iostream&gt;using namespace std; #define MIN(a,b) (a&lt;b ? a : b) int main ()&#123; int i, j; i = 100; j = 30; cout &lt;&lt;"较小的值为：" &lt;&lt; MIN(i, j) &lt;&lt; endl; return 0;&#125; 条件编译有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。条件预处理器的结构与 if 选择结构很像。如下面这段预处理器的代码： 123#ifndef NULL #define NULL 0#endif 可以只在调试时进行编译，调试开关可以使用一个宏来实现，如下所示： 123#ifdef DEBUG cerr &lt;&lt;"Variable x = " &lt;&lt; x &lt;&lt; endl;#endif 如果在指令 #ifdef DEBUG 之前已经定义了符号常量 DEBUG，则会对程序中的 cerr 语句进行编译。可以使用 #if 0 语句注释掉程序的一部分，如下所示： 1234#if 0 不进行编译的代码#endif 实例： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;#define DEBUG #define MIN(a,b) (((a)&lt;(b)) ? a : b) int main ()&#123; int i, j; i = 100; j = 30;#ifdef DEBUG cerr &lt;&lt;"Trace: Inside main function" &lt;&lt; endl;#endif #if 0 /* 这是注释部分 */ cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl;#endif cout &lt;&lt;"The minimum is " &lt;&lt; MIN(i, j) &lt;&lt; endl; #ifdef DEBUG cerr &lt;&lt;"Trace: Coming out of main function" &lt;&lt; endl;#endif return 0;&#125; #和## 运算符# 和## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把 replacement-text 令牌转换为用引号引起来的字符串。 C++ 中的预定义宏C++ 提供了下表所示的一些预定义宏： 宏 描述 LINE 这会在程序编译时包含当前行号。 FILE 这会在程序编译时包含当前文件名。 DATE 这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。 TIME 这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。 七、C++ 信号处理号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。 有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 中。 信号 描述 SIGABRT 程序的异常终止，如调用 abort。 SIGFPE 错误的算术运算，比如除以零或导致溢出的操作。 SIGILL 检测非法指令。 SIGINT 接收到交互注意信号。 SIGSEGV 非法访问内存。 SIGTERM 发送到程序的终止请求。 signal() 函数C++ 信号处理库提供了 signal 函数，用来捕获突发事件。以下是 signal() 函数的语法： void (*signal (int sig, void (*func)(int)))(int); 这个函数接收两个参数：第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。 八、C++ 多线程线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：基于进程和基于线程。 基于进程的多任务处理是程序的并发执行。 基于线程的多任务处理是同一程序的片段的并发执行。 多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。 九、C++ Web 编程什么是 CGI？ 公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。 CGI 规范目前是由 NCSA 维护的，NCSA 定义 CGI 如下： 公共网关接口（CGI），是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。 目前的版本是 CGI/1.1，CGI/1.2 版本正在推进中。 CGI 架构图 Web 服务器配置进行 CGI 编程之前，请确保 Web 服务器支持 CGI，并已配置成可以处理 CGI 程序。所有由 HTTP 服务器执行的 CGI 程序，都必须在预配置的目录中。该目录称为 CGI 目录，按照惯例命名为 /var/www/cgi-bin。虽然 CGI 文件是 C++ 可执行文件，但是按照惯例它的扩展名是 .cgi。默认情况下，Apache Web 服务器会配置在 /var/www/cgi-bin 中运行 CGI 程序。如果想指定其他目录来运行 CGI 脚本，可以在 httpd.conf 文件中修改以下部分： 12345678910&lt;Directory &quot;/var/www/cgi-bin&quot;&gt; AllowOverride None Options ExecCGI Order allow,deny Allow from all&lt;/Directory&gt; &lt;Directory &quot;/var/www/cgi-bin&quot;&gt;Options All&lt;/Directory&gt; 在这里，假设已经配置好 Web 服务器并能成功运行，可以运行任意的 CGI 程序，比如 Perl 或 Shell 等。 实例： 12345678910111213141516171819#include &lt;iostream&gt;using namespace std; int main ()&#123; cout &lt;&lt; "Content-type:text/html\r\n\r\n"; cout &lt;&lt; "&lt;html&gt;\n"; cout &lt;&lt; "&lt;head&gt;\n"; cout &lt;&lt; "&lt;title&gt;Hello World - 第一个 CGI 程序&lt;/title&gt;\n"; cout &lt;&lt; "&lt;/head&gt;\n"; cout &lt;&lt; "&lt;body&gt;\n"; cout &lt;&lt; "&lt;h2&gt;Hello World! 这是我的第一个 CGI 程序&lt;/h2&gt;\n"; cout &lt;&lt; "&lt;/body&gt;\n"; cout &lt;&lt; "&lt;/html&gt;\n"; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>多线程基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++面向对象]]></title>
    <url>%2F2018%2F07%2F22%2FC-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。 面向对象一、C++ 类 &amp; 对象C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。 C++ 类定义定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。类定义是以关键字 class 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，使用关键字 class 定义 man 数据类型，如下所示： 1234567class Man&#123; public: double name; // 名字 double wight; // 体重 double height; // 身高&#125;; 关键字 public 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。也可以指定类的成员为 private 或 protected. 定义 C++ 对象提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Man 的两个对象： Man Man1; // 声明 Man1，类型为 Man 访问数据成员类的对象的公共数据成员可以使用直接成员访问运算符 (.) 来访问 类 &amp; 对象详解下面的列表中还列出了其他一些 C++ 类和对象相关的概念. 概念 描述 类成员函数 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 类访问修饰符 类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。 构造函数 &amp; 析构函数 类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。 C++ 拷贝构造函数 拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 C++ 友元函数 友元函数可以访问类的 private 和 protected 成员。 C++ 内联函数 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。 C++ 中的 this 指针 每个对象都有一个特殊的指针 this，它指向对象本身。 C++ 中指向类的指针 指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。 C++ 类的静态成员 类的数据成员和函数成员都可以被声明为静态的。 C++ 类成员函数类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。 成员函数可以定义在类定义内部，或者单独使用范围解析运算符 :: 来定义。在类定义中定义的成员函数把函数声明为内联的，即便没有使用 inline 标识符。 也可以在类的外部使用范围解析运算符 :: 定义函数,需要强调一点，在 :: 运算符之前必须使用类名。调用成员函数是在对象上使用点运算符（.），这样它就能操作与该对象相关的数据 C++ 类访问修饰符数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记 public、private、protected 来指定的。关键字 public、private、protected 称为访问修饰符。一个类可以有多个 public、protected 或 private 标记区域。每个标记区域在下一个标记区域开始之前或者在遇到类主体结束右括号之前都是有效的。成员和类的默认访问修饰符是 private。 ####### 公有（public）成员 公有成员在程序中类的外部是可访问的。可以不使用任何成员函数来设置和获取公有变量的值 ####### 私有（private）成员 私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。默认情况下，类的所有成员都是私有的 实际操作中，我们一般会在私有区域定义数据，在公有区域定义相关的函数，以便在类的外部也可以调用这些函数 ####### 保护（protected）成员 保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的 继承中的特点有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。 public 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private private 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private 但无论哪种继承方式，上面两点都没有改变： private 成员只能被本类成员（类内）和友元访问，不能被派生类访问； protected 成员可以被派生类访问。 C++ 类构造函数 &amp; 析构函数####### 类的构造函数 类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。 ####### 类的析构函数 类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。 C++ 拷贝构造函数拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于： 通过使用另一个同类型的对象来初始化新创建的对象。 复制对象把它作为参数传递给函数。 复制对象，并从函数返回这个对象。 如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。拷贝构造函数的最常见形式如下： 123classname (const classname &amp;obj) &#123; // 构造函数的主体&#125; 在这里，obj 是一个对象引用，该对象是用于初始化另一个对象的。 C++ 友元函数类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend C++ 内联函数C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。 C++ this 指针在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。 C++ 指向类的指针一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 -&gt;，就像访问指向结构的指针一样。与所有的指针一样，您必须在使用指针之前，对指针进行初始化。 C++ 类的静态成员可以使用 static 关键字来把类成员定义为静态的。当声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化. ####### 静态成员函数 如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问。静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。 静态成员函数与普通成员函数的区别： 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。 普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。 二、C++ 继承面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。当创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。 基类 &amp; 派生类一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下： class derived-class: access-specifier base-class 其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。 实例：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt; using namespace std; // 基类class Shape &#123; public: void setWidth(int w) &#123; width = w; &#125; void setHeight(int h) &#123; height = h; &#125; protected: int width; int height;&#125;; // 派生类class Rectangle: public Shape&#123; public: int getArea() &#123; return (width * height); &#125;&#125;; int main(void)&#123; Rectangle Rect; Rect.setWidth(5); Rect.setHeight(7); // 输出对象的面积 cout &lt;&lt; "Total area: " &lt;&lt; Rect.getArea() &lt;&lt; endl; return 0;&#125; 输出： 总面积: 35 访问控制和继承派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。 根据访问权限总结出不同的访问类型，如下所示： 访问 public protected private 同一个类 yes yes yes 派生类 yes yes no 外部的类 yes no no 一个派生类继承了所有的基类方法，但下列情况除外： 基类的构造函数、析构函数和拷贝构造函数。 基类的重载运算符。 基类的友元函数。 继承类型当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。我们几乎不使用 protected 或 private继承，通常使用public 继承。当使用不同类型的继承时，遵循以下几个规则： 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。 多继承多继承即一个子类可以有多个父类，它继承了多个父类的特性。C++ 类可以从多个类继承成员，语法如下：1234class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…&#123;&lt;派生类类体&gt;&#125;; 其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示 三、C++ 重载运算符和重载函数C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。当调用一个重载函数或重载运算符时，编译器通过把你所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。 C++ 中的函数重载在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。不能仅通过返回类型的不同来重载函数。 实例： 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class printData&#123;public: void print(int i)&#123; cout &lt;&lt;"整数为："&lt;&lt; i&lt;&lt;endl; &#125; void print(double f)&#123; cout &lt;&lt;"浮点数为："&lt;&lt;f&lt;&lt;endl; &#125; void print(string c)&#123; cout &lt;&lt;"字符串为："&lt;&lt; c&lt;&lt;endl; &#125;&#125;;int main(void)&#123; printData prt; prt.print(1); prt.print(19.00); prt.print("ycp nb!");&#125; 结果 整数为：1 浮点数为：19 字符串为：ycp nb! C++ 中的运算符重载C++中可以重定义或重载大部分 C++ 内置的运算符。这样，就能使用自定义类型的运算符。重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。 Box operator+(const Box&amp;); 实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;using namespace std;class Box&#123;public: double getVolume()&#123; return length*breadth*height; &#125; void setLength(double len)&#123; length = len ; &#125; void setBreadth(double bre)&#123; breadth = bre ; &#125; void setHeight(double hei)&#123; height = hei ; &#125; // 重载 + 运算符，用于把两个 Box 对象相加 Box operator+(const Box&amp; b)&#123; Box box; box.length = this-&gt;length + b.length; box.breadth = this-&gt;breadth + b.breadth; box.height = this-&gt;height + b.height; return box; &#125;protected: double length; double breadth; double height;&#125;;int main()&#123; Box box1; Box box2; Box box3; double volume = 0.0; box1.setLength(6.0); box1.setBreadth(7.0); box1.setHeight(5.0); box2.setLength(12.0); box2.setBreadth(13.0); box2.setHeight(10.0); volume =box1.getVolume(); cout &lt;&lt;"box1体积为：" &lt;&lt; volume &lt;&lt;endl; volume =box2.getVolume(); cout &lt;&lt;"box2体积为：" &lt;&lt; volume &lt;&lt;endl; box3 = box1 +box2; volume =box3.getVolume(); cout &lt;&lt;"box3体积为：" &lt;&lt; volume &lt;&lt;endl;&#125; 结果 box1体积为：210 box2体积为：1560 box3体积为：5400 可重载运算符/不可重载运算符下面是可重载的运算符列表： 可重载运算符 描述 双目算术运算符 + (加)，-(减)，*(乘)，/(除)，% (取模) 关系运算符 ==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于) 逻辑运算符 (逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非) 单目运算符 + (正)，-(负)，*(指针)，&amp;(取地址) 自增自减运算符 ++(自增)，–(自减) 位运算符 (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移) 赋值运算符 =, +=, -=, *=, /= , % = , &amp;=, =, ^=, &lt;&lt;=, &gt;&gt;= 空间申请与释放 new, delete, new[ ] , delete[] 其他运算符 ()(函数调用)，-&gt;(成员访问)，,(逗号)， 下面是不可重载的运算符列表： .：成员访问运算符 ., -&gt;：成员指针访问运算符 ::：域运算符 sizeof：长度运算符 ?:：条件运算符 #： 预处理符号 四、C++多态多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。 实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;using namespace std;class Shape&#123;public: Shape(int a = 0, int b = 0)&#123; length = a; height = b; &#125; int area()&#123; cout &lt;&lt; "父类面积为："&lt;&lt;endl; return (length * height); &#125;protected: int length; int height;&#125;;class Rectangle:public Shape&#123;public: Rectangle(int a = 0 ,int b= 0):Shape(a,b)&#123;&#125; int area()&#123; cout &lt;&lt; "基类Rectangle面积为：" &lt;&lt;endl; return length * height; &#125;&#125;;class Triangle:public Shape&#123;public: Triangle(int a = 0 ,int b = 0):Shape(a,b)&#123;&#125; int area()&#123; cout &lt;&lt; "基类Triangle面积为：" &lt;&lt;endl; return (length * height/2); &#125;&#125;;int main()&#123; Shape *shape; Rectangle rec(10,7); Triangle tri(10,5); //储存矩形地址 shape = &amp;rec; //调用 shape-&gt;area(); //存储三角形地址 shape = &amp;tri; //调用 shape-&gt;area(); return 0;&#125; 结果 父类面积为： 父类面积为： 导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了。 改动： 在 Shape 类中，area() 的声明前放置关键字 virtual 结果： 基类Rectangle面积为：70 基类Triangle面积为：25 此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。每个子类都有一个函数 area() 的独立实现。这就是多态的一般使用方式。有了多态，可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。 虚函数虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。 纯虚函数 我们可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。 12345678910111213class Shape &#123; protected: int width, height; public: Shape( int a=0, int b=0) &#123; width = a; height = b; &#125; // pure virtual function virtual int area() = 0;&#125;; = 0 告诉编译器，函数没有主体，上面的虚函数是纯虚函数。 五、C++ 数据抽象数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。数据抽象是一种依赖于接口和实现分离的编程（设计）技术。 就 C++ 编程而言，C++ 类为数据抽象提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现 在 C++ 中，使用类来定义我们自己的抽象数据类型（ADT）。 访问标签强制抽象在 C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签： 使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。 使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。 访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。 数据抽象的好处数据抽象有两个重要的优势： 类的内部受到保护，不会因无意的用户级错误导致对象状态受损。 类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。 如果只在类的私有部分定义数据成员，编写该类的作者就可以随意更改数据。如果实现发生改变，则只需要检查类的代码，看看这个改变会导致哪些影响。如果数据是公有的，则任何直接访问旧表示形式的数据成员的函数都可能受到影响。 数据抽象的实例C++ 程序中，任何带有公有和私有成员的类都可以作为数据抽象的实例 实例 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;class Adder&#123;public: //构造函数 Adder(int i = 0)&#123; total = i; &#125; //对外接口 void addNum(int num)&#123; total += num; &#125; int getTotal()&#123; return total; &#125;protected: int total;&#125;;int main()&#123; Adder a; a.addNum(2); a.addNum(2); a.addNum(2); cout &lt;&lt;a.getTotal()&lt;&lt;endl; return 0;&#125; 结果： 6 设计策略抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可 六、C++ 数据封装所有的 C++ 程序都有以下两个基本要素： 程序语句（代码）：这是程序中执行动作的部分，它们被称为函数。 程序数据：数据是程序的信息，会受到程序函数的影响。 封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即数据隐藏。 数据封装是一种把数据和操作数据的函数捆绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。 C++ 通过创建类来支持封装和数据隐藏（public、protected、private）。 类包含私有成员（private）、保护成员（protected）和公有成员（public）成员。默认情况下，在类中定义的所有项目都是私有的 为了使类中的成员变成公有的（即，程序中的其他部分也能访问），必须在这些成员前使用 public 关键字进行声明。所有定义在 public 标识符后边的变量或函数可以被程序中所有其他的函数访问。 把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节 数据封装的实例和上一个例子一样 设计策略通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。这通常应用于数据成员，但它同样适用于所有成员，包括虚函数。 七、C++ 接口（抽象类）接口描述了类的行为和功能，而不需要完成类的特定实现。C++ 接口是使用抽象类来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的，如下所示： 123456789101112class Box&#123; public: // 纯虚函数 virtual double getVolume() = 0; private: double length; // 长度 double breadth; // 宽度 double height; // 高度&#125;; 设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。可用于实例化对象的类被称为具体类。 抽象类的实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt; using namespace std; // 基类class Shape &#123;public: // 提供接口框架的纯虚函数 virtual int getArea() = 0; void setWidth(int w) &#123; width = w; &#125; void setHeight(int h) &#123; height = h; &#125;protected: int width; int height;&#125;; // 派生类class Rectangle: public Shape&#123;public: int getArea() &#123; return (width * height); &#125;&#125;;class Triangle: public Shape&#123;public: int getArea() &#123; return (width * height)/2; &#125;&#125;; int main(void)&#123; Rectangle Rect; Triangle Tri; Rect.setWidth(5); Rect.setHeight(7); // 输出对象的面积 cout &lt;&lt; "Total Rectangle area: " &lt;&lt; Rect.getArea() &lt;&lt; endl; Tri.setWidth(5); Tri.setHeight(7); // 输出对象的面积 cout &lt;&lt; "Total Triangle area: " &lt;&lt; Tri.getArea() &lt;&lt; endl; return 0;&#125; 设计策略面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来。外部应用程序提供的功能（即公有函数）在抽象基类中是以纯虚函数的形式存在的。这些纯虚函数在相应的派生类中被实现。这个架构也使得新的应用程序可以很容易地被添加到系统中，即使是在系统被定义之后依然可以如此。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 基础]]></title>
    <url>%2F2018%2F07%2F22%2FC-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性： 基础特性C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性： 封装 抽象 继承 多态 标准库标准的 C++ 由三个重要部分组成： 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等。 标准模板库（STL），提供了大量的方法，用于操作数据结构等。 语法C++ 基本语法 对象 类 方法 即时变量 三字符组三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。 三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。 C++ 数据类型基本的内置类型 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 一些基本类型可以使用一个或多个类型修饰符进行修饰： signed unsigned short long typedef 声明可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法： typedef type newname; 枚举类型枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。 如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。 创建枚举，需要使用关键字 enum。枚举类型的一般形式为： 1234567enum 枚举名&#123; 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数]&#125; 枚举变量; C++ 变量类型C++ 中的变量定义变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示： type variable_list; type 必须是一个有效的 C++ 数据类型 C++ 中的变量声明变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。 C++ 修饰符类型C++ 允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。 下面列出了数据类型修饰符： signed unsigned long short C++ 存储类存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类： auto register static extern mutable thread_local (C++11) 从 C++ 11 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。 extern 存储类extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。 thread_local 存储类使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。thread_local 说明符可以与 static 或 extern 合并。可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。 C++ 循环循环类型C++ 编程语言提供了以下几种循环类型。 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件 for 循环 多次执行一个语句序列，简化管理循环变量的代码 do…while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似 嵌套循环 可以在 while、for 或 do..while 循环内使用一个或多个循环 循环控制语句循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。 C++ 提供了下列的控制语句。 循环类型 描述 break 语句 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 continue 语句 引起循环跳过主体的剩余部分，立即重新开始测试条件。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 C++ 函数函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat() 用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。函数还有很多叫法，比如方法、子例程或程序，等等。 在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分： 返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。 函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。 参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 函数主体：函数主体包含一组定义函数执行任务的语句。 函数参数如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。当调用函数时，有两种向函数传递参数的方式： 调用类型 描述 传值调用 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 指针调用 该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 引用调用 该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 Lambda 函数与表达式C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。 C++ 数组C++ 数组C++ 支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。 数组的声明并不是声明一个个单独的变量，比如 number0、number1、…、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。 所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素 声明数组在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示： type arrayName [ arraySize ]; 初始化数组在 C++ 中，可以逐个初始化数组，也可以使用一个初始化语句，如下所示：double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0}; 大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。如果省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0}; 创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：balance[4] = 50.0; 上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示： 访问数组元素 数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如： double salary = balance[9]; C++ 中数组详解 概念 描述 多维数组 C++ 支持多维数组。多维数组最简单的形式是二维数组。 指向数组的指针 可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 传递数组给函数 可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 从函数返回数组 C++ 允许从函数返回数组。 C++ 字符串C++ 提供了以下两种类型的字符串表示形式： C 风格字符串 C++ 引入的 string 类类型 C 风格字符串C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 null 字符 ‘\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 下面的声明和初始化创建了一个 “Hello” 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 “Hello” 的字符数多一个。 char greeting[6] = {&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\0&#39;}; 依据数组初始化规则，可以把上面的语句写成以下语句： char greeting[] = &quot;Hello&quot;; 以下是 C/C++ 中定义的字符串的内存表示： C++ 中有大量的函数用来操作以 null 结尾的字符串：supports a wide range of functions that manipulate null-terminated strings: 序号 函数 &amp; 目的 1 strcpy(s1, s2);复制字符串 s2 到字符串 s1。 2 strcat(s1, s2);连接字符串 s2 到字符串 s1 的末尾。 3 strlen(s1);返回字符串 s1 的长度。 4 strcmp(s1, s2);如果 s1 和 s2 是相同的，则返回 0；如果 s1s2 则返回值大于 0。 5 strchr(s1, ch);返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2);返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 C++ 中的 String 类C++ 标准库提供了 string 类类型，支持上述所有的操作，另外还增加了其他更多的功能。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; int main ()&#123; string str1 = "Hello"; string str2 = "World"; string str3; int len ; // 复制 str1 到 str3 str3 = str1; cout &lt;&lt; "str3 : " &lt;&lt; str3 &lt;&lt; endl; // 连接 str1 和 str2 str3 = str1 + str2; cout &lt;&lt; "str1 + str2 : " &lt;&lt; str3 &lt;&lt; endl; // 连接后，str3 的总长度 len = str3.size(); cout &lt;&lt; "str3.size() : " &lt;&lt; len &lt;&lt; endl; return 0;&#125; 结果： 十C++ 指针通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。 每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址 什么是指针？指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为： type *var-name; 在这里，type 是指针的基类型，它必须是一个有效的 C++ 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明： 1234int *ip; /* 一个整型的指针 */double *dp; /* 一个 double 型的指针 */float *fp; /* 一个浮点型的指针 */char *ch; /* 一个字符型的指针 */ 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。 C++ 中使用指针使用指针时会频繁进行以下几个操作： 定义一个指针变量、 把变量地址赋值给指针、 访问指针变量中可用地址的值。 这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main ()&#123; int var = 20; // 实际变量的声明 int *ip; // 指针变量的声明 ip = &amp;var; // 在指针变量中存储 var 的地址 cout &lt;&lt; "变量值: "; cout &lt;&lt; var &lt;&lt; endl; // 输出在指针变量中存储的地址 cout &lt;&lt; "变量地址 "; cout &lt;&lt; ip &lt;&lt; endl; // 访问指针中地址的值 cout &lt;&lt; "指针中地址的值: "; cout &lt;&lt; *ip &lt;&lt; endl; return 0;&#125; C++ 指针详解在 C++ 中，有很多指针相关的概念，这些概念都很简单，但是都很重要. 概念 描述 C++ Null 指针 C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 C++ 指针的算术运算 可以对指针进行四种算术运算：++、–、+、- C++ 指针 vs 数组 指针和数组之间有着密切的关系。 C++ 指针数组 可以定义用来存储指针的数组。 C++ 指向指针的指针 C++ 允许指向指针的指针。 C++ 传递指针给函数 通过引用或地址传递参数，使传递的参数在调用函数中被改变。 C++ 从函数返回指针 C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。 十C++ 引用引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 C++ 引用 vs 指针引用很容易与指针混淆，它们之间有三个主要的不同： 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 C++ 中创建引用变量名称是变量附属在内存位置中的标签，可以把引用当成是变量附属在内存位置中的第二个标签。因此可以通过原始变量名称或引用来访问变量的内容 引用通常用于函数参数列表和函数返回值。引用相关的重要概念： 概念 描述 把引用作为参数 C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 把引用作为返回值 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。 十 C++ 日期 &amp; 时间C++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 头文件。 有四个与时间相关的类型：clock_t、time_t、size_t 和 tm。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。 结构类型 tm 把日期和时间以 C 结构的形式保存，tm 结构的定义如下： 1234567891011struct tm &#123; int tm_sec; // 秒，正常范围从 0 到 59，但允许至 61 int tm_min; // 分，范围从 0 到 59 int tm_hour; // 小时，范围从 0 到 23 int tm_mday; // 一月中的第几天，范围从 1 到 31 int tm_mon; // 月，范围从 0 到 11 int tm_year; // 自 1900 年起的年数 int tm_wday; // 一周中的第几天，范围从 0 到 6，从星期日算起 int tm_yday; // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起 int tm_isdst; // 夏令时&#125; 下面是 C/C++ 中关于日期和时间的重要函数。所有这些函数都是 C/C++ 标准库的组成部分 序号 函数 &amp; 描述 1 time_t time(time_t *time);该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 .1。 2 char ctime(const time_t time);该返回一个表示当地时间的字符串指针，字符串形式 day month year hours:minutes:seconds year\n\0。 3 struct tm localtime(const time_t time);该函数返回一个指向表示本地时间的 tm 结构的指针。 4 clock_t clock(void);该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 .1。 5 char asctime ( const struct tm time );该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\n\0。 6 struct tm gmtime(const time_t time);该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 7 time_t mktime(struct tm *time);该函数返回日历时间，相当于 time 所指向结构中存储的时间。 8 double difftime ( time_t time2, time_t time1 );该函数返回 time1 和 time2 之间相差的秒数。 9 size_t strftime();该函数可用于格式化日期和时间为指定的格式。 当前日期和时间123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;ctime&gt; using namespace std; int main( )&#123; // 基于当前系统的当前日期/时间 time_t now = time(0); // 把 now 转换为字符串形式 char* dt = ctime(&amp;now); cout &lt;&lt; "本地日期和时间：" &lt;&lt; dt &lt;&lt; endl; // 把 now 转换为 tm 结构 tm *gmtm = gmtime(&amp;now); dt = asctime(gmtm); cout &lt;&lt; "UTC 日期和时间："&lt;&lt; dt &lt;&lt; endl;&#125; 使用结构 tm 格式化时间tm 结构在 C/C++ 中处理日期和时间相关的操作时，显得尤为重要。tm 结构以 C 结构的形式保存日期和时间。大多数与时间相关的函数都使用了 tm 结构。下面的实例使用了 tm 结构和各种与日期和时间相关的函数。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;ctime&gt; using namespace std; int main( )&#123; // 基于当前系统的当前日期/时间 time_t now = time(0); cout &lt;&lt; "1970 到目前经过秒数:" &lt;&lt; now &lt;&lt; endl; tm *ltm = localtime(&amp;now); // 输出 tm 结构的各个组成部分 cout &lt;&lt; "年: "&lt;&lt; 1900 + ltm-&gt;tm_year &lt;&lt; endl; cout &lt;&lt; "月: "&lt;&lt; 1 + ltm-&gt;tm_mon&lt;&lt; endl; cout &lt;&lt; "日: "&lt;&lt; ltm-&gt;tm_mday &lt;&lt; endl; cout &lt;&lt; "时间: "&lt;&lt; ltm-&gt;tm_hour &lt;&lt; ":"; cout &lt;&lt; ltm-&gt;tm_min &lt;&lt; ":"; cout &lt;&lt; ltm-&gt;tm_sec &lt;&lt; endl;&#125; 十 C++ 基本的输入输出C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。 I/O 库头文件 头文件 函数和描述 &lt;iostream&gt; 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 &lt;iomanip&gt; 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。 &lt;fstream&gt; 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 标准输出流（cout）定义的对象 cout 是 iostream 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与流插入运算符 &lt;&lt; 结合使用的 C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。流插入运算符 &lt;&lt; 在一个语句中可以多次使用 标准输入流（cin）预定义的对象 cin 是 iostream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 &gt;&gt; 结合使用的 标准错误流（cerr）预定义的对象 cerr 是 iostream 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。cerr 也是与流插入运算符 &lt;&lt; 结合使用的 标准日志流（clog）定义的对象 clog 是 iostream 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。clog 也是与流插入运算符 &lt;&lt; 结合使用的 我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出 十 C++ 数据结构C/C++ 数组允许定义可存储相同类型数据项的变量，但是结构是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。结构用于表示一条记录。 定义结构为了定义结构，必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下： 12345678struct type_name &#123;member_type1 member_name1;member_type2 member_name2;member_type3 member_name3;..&#125; object_names; type_name 是结构体类型的名称 member_type1 member_name1 是标准的变量定义，比如 int i; 或者 float f;或者其他有效的变量定义。 在结构定义的末尾，最后一个分号之前，可以指定一个或多个结构变量，这是可选的 访问结构成员为了访问结构的成员，使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。 结构作为函数参数可以把结构作为函数参数，传参方式与其他类型的变量或指针类似 实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstring&gt; using namespace std; // 声明一个结构体类型 Books struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;; int main( )&#123; Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, "C++ 教程"); strcpy( Book1.author, "ycp"); strcpy( Book1.subject, "编程语言"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, "CSS 教程"); strcpy( Book2.author, "ycp"); strcpy( Book2.subject, "前端技术"); Book2.book_id = 12346; // 输出 Book1 信息 cout &lt;&lt; "第一本书标题 : " &lt;&lt; Book1.title &lt;&lt;endl; cout &lt;&lt; "第一本书作者 : " &lt;&lt; Book1.author &lt;&lt;endl; cout &lt;&lt; "第一本书类目 : " &lt;&lt; Book1.subject &lt;&lt;endl; cout &lt;&lt; "第一本书 ID : " &lt;&lt; Book1.book_id &lt;&lt;endl; // 输出 Book2 信息 cout &lt;&lt; "第二本书标题 : " &lt;&lt; Book2.title &lt;&lt;endl; cout &lt;&lt; "第二本书作者 : " &lt;&lt; Book2.author &lt;&lt;endl; cout &lt;&lt; "第二本书类目 : " &lt;&lt; Book2.subject &lt;&lt;endl; cout &lt;&lt; "第二本书 ID : " &lt;&lt; Book2.book_id &lt;&lt;endl; return 0;&#125; 结构作为函数参数以把结构作为函数参数，传参方式与其他类型的变量或指针类似 实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstring&gt; using namespace std;void printBook( struct Books book ); // 声明一个结构体类型 Books struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;; int main( )&#123; Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, "C++ 教程"); strcpy( Book1.author, "ycp"); strcpy( Book1.subject, "编程语言"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, "CSS 教程"); strcpy( Book2.author, "ycp"); strcpy( Book2.subject, "前端技术"); Book2.book_id = 12346; // 输出 Book1 信息 printBook( Book1 ); // 输出 Book2 信息 printBook( Book2 ); return 0;&#125;void printBook( struct Books book )&#123; cout &lt;&lt; "书标题 : " &lt;&lt; book.title &lt;&lt;endl; cout &lt;&lt; "书作者 : " &lt;&lt; book.author &lt;&lt;endl; cout &lt;&lt; "书类目 : " &lt;&lt; book.subject &lt;&lt;endl; cout &lt;&lt; "书 ID : " &lt;&lt; book.book_id &lt;&lt;endl;&#125; 指向结构的指针可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示： struct Books *struct_pointer; 现在，可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，把 &amp; 运算符放在结构名称的前面，如下所示： struct_pointer = &amp;Book1; 为了使用指向该结构的指针访问结构的成员，必须使用 -&gt; 运算符，如下所示： struct_pointer-&gt;title; 重写上面的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstring&gt; using namespace std;void printBook( struct Books *book ); struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;; int main( )&#123; Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, "C++ 教程"); strcpy( Book1.author, "ycp"); strcpy( Book1.subject, "编程语言"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, "CSS 教程"); strcpy( Book2.author, "ycp"); strcpy( Book2.subject, "前端技术"); Book2.book_id = 12346; // 通过传 Book1 的地址来输出 Book1 信息 printBook( &amp;Book1 ); // 通过传 Book2 的地址来输出 Book2 信息 printBook( &amp;Book2 ); return 0;&#125;// 该函数以结构指针作为参数void printBook( struct Books *book )&#123; cout &lt;&lt; "书标题 : " &lt;&lt; book-&gt;title &lt;&lt;endl; cout &lt;&lt; "书作者 : " &lt;&lt; book-&gt;author &lt;&lt;endl; cout &lt;&lt; "书类目 : " &lt;&lt; book-&gt;subject &lt;&lt;endl; cout &lt;&lt; "书 ID : " &lt;&lt; book-&gt;book_id &lt;&lt;endl;&#125; typedef 关键字下面是一种更简单的定义结构的方式，可以为创建的类型取一个”别名”。例如：1234567typedef struct&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;Books; 现在，可以直接使用 Books 来定义 Books 类型的变量，而不需要使用 struct 关键字。下面是实例： Books Book1, Book2; 基础特性C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性： 封装 抽象 继承 多态 标准库标准的 C++ 由三个重要部分组成： 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等。 标准模板库（STL），提供了大量的方法，用于操作数据结构等。 语法C++ 基本语法 对象 类 方法 即时变量 三字符组三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。 三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。 C++ 数据类型基本的内置类型 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 一些基本类型可以使用一个或多个类型修饰符进行修饰： signed unsigned short long typedef 声明可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法： typedef type newname; 枚举类型枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。 如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。 创建枚举，需要使用关键字 enum。枚举类型的一般形式为： 1234567enum 枚举名&#123; 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数]&#125; 枚举变量; C++ 变量类型C++ 中的变量定义变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示： type variable_list; type 必须是一个有效的 C++ 数据类型 C++ 中的变量声明变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。 C++ 修饰符类型C++ 允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。 下面列出了数据类型修饰符： signed unsigned long short C++ 存储类存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类： auto register static extern mutable thread_local (C++11) 从 C++ 11 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。 extern 存储类extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。 thread_local 存储类使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。thread_local 说明符可以与 static 或 extern 合并。可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。 C++ 循环#####循环类型 C++ 编程语言提供了以下几种循环类型。 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件 for 循环 多次执行一个语句序列，简化管理循环变量的代码 do…while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似 嵌套循环 可以在 while、for 或 do..while 循环内使用一个或多个循环 循环控制语句循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。 C++ 提供了下列的控制语句。 循环类型 描述 break 语句 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 continue 语句 引起循环跳过主体的剩余部分，立即重新开始测试条件。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 C++ 函数函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat() 用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。函数还有很多叫法，比如方法、子例程或程序，等等。 在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分： 返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。 函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。 参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 函数主体：函数主体包含一组定义函数执行任务的语句。 函数参数如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。当调用函数时，有两种向函数传递参数的方式： 调用类型 描述 传值调用 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 指针调用 该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 引用调用 该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 Lambda 函数与表达式C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。 C++ 数组#####C++ 数组 C++ 支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。 数组的声明并不是声明一个个单独的变量，比如 number0、number1、…、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。 所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素 声明数组在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示： type arrayName [ arraySize ]; 初始化数组在 C++ 中，可以逐个初始化数组，也可以使用一个初始化语句，如下所示：double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0}; 大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。如果省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0}; 创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：balance[4] = 50.0; 上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示： 访问数组元素 数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如： double salary = balance[9]; C++ 中数组详解 概念 描述 多维数组 C++ 支持多维数组。多维数组最简单的形式是二维数组。 指向数组的指针 可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 传递数组给函数 可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 从函数返回数组 C++ 允许从函数返回数组。 C++ 字符串C++ 提供了以下两种类型的字符串表示形式： C 风格字符串 C++ 引入的 string 类类型 C 风格字符串C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 null 字符 ‘\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 下面的声明和初始化创建了一个 “Hello” 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 “Hello” 的字符数多一个。 char greeting[6] = {&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\0&#39;}; 依据数组初始化规则，可以把上面的语句写成以下语句： char greeting[] = &quot;Hello&quot;; 以下是 C/C++ 中定义的字符串的内存表示： C++ 中有大量的函数用来操作以 null 结尾的字符串：supports a wide range of functions that manipulate null-terminated strings: 序号 函数 &amp; 目的 1 strcpy(s1, s2);复制字符串 s2 到字符串 s1。 2 strcat(s1, s2);连接字符串 s2 到字符串 s1 的末尾。 3 strlen(s1);返回字符串 s1 的长度。 4 strcmp(s1, s2);如果 s1 和 s2 是相同的，则返回 0；如果 s1s2 则返回值大于 0。 5 strchr(s1, ch);返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2);返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 C++ 中的 String 类C++ 标准库提供了 string 类类型，支持上述所有的操作，另外还增加了其他更多的功能。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; int main ()&#123; string str1 = "Hello"; string str2 = "World"; string str3; int len ; // 复制 str1 到 str3 str3 = str1; cout &lt;&lt; "str3 : " &lt;&lt; str3 &lt;&lt; endl; // 连接 str1 和 str2 str3 = str1 + str2; cout &lt;&lt; "str1 + str2 : " &lt;&lt; str3 &lt;&lt; endl; // 连接后，str3 的总长度 len = str3.size(); cout &lt;&lt; "str3.size() : " &lt;&lt; len &lt;&lt; endl; return 0;&#125; 结果： C++ 指针通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。 每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址 什么是指针？指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为： type *var-name; 在这里，type 是指针的基类型，它必须是一个有效的 C++ 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明： 1234int *ip; /* 一个整型的指针 */double *dp; /* 一个 double 型的指针 */float *fp; /* 一个浮点型的指针 */char *ch; /* 一个字符型的指针 */ 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。 C++ 中使用指针使用指针时会频繁进行以下几个操作： 定义一个指针变量、 把变量地址赋值给指针、 访问指针变量中可用地址的值。 这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main ()&#123; int var = 20; // 实际变量的声明 int *ip; // 指针变量的声明 ip = &amp;var; // 在指针变量中存储 var 的地址 cout &lt;&lt; "变量值: "; cout &lt;&lt; var &lt;&lt; endl; // 输出在指针变量中存储的地址 cout &lt;&lt; "变量地址 "; cout &lt;&lt; ip &lt;&lt; endl; // 访问指针中地址的值 cout &lt;&lt; "指针中地址的值: "; cout &lt;&lt; *ip &lt;&lt; endl; return 0;&#125; C++ 指针详解在 C++ 中，有很多指针相关的概念，这些概念都很简单，但是都很重要. 概念 描述 C++ Null 指针 C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 C++ 指针的算术运算 可以对指针进行四种算术运算：++、–、+、- C++ 指针 vs 数组 指针和数组之间有着密切的关系。 C++ 指针数组 可以定义用来存储指针的数组。 C++ 指向指针的指针 C++ 允许指向指针的指针。 C++ 传递指针给函数 通过引用或地址传递参数，使传递的参数在调用函数中被改变。 C++ 从函数返回指针 C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。 C++ 引用引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 C++ 引用 vs 指针引用很容易与指针混淆，它们之间有三个主要的不同： 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 C++ 中创建引用变量名称是变量附属在内存位置中的标签，可以把引用当成是变量附属在内存位置中的第二个标签。因此可以通过原始变量名称或引用来访问变量的内容 引用通常用于函数参数列表和函数返回值。引用相关的重要概念： 概念 描述 把引用作为参数 C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 把引用作为返回值 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。 C++ 日期 &amp; 时间C++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 头文件。 有四个与时间相关的类型：clock_t、time_t、size_t 和 tm。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。 结构类型 tm 把日期和时间以 C 结构的形式保存，tm 结构的定义如下： 1234567891011struct tm &#123; int tm_sec; // 秒，正常范围从 0 到 59，但允许至 61 int tm_min; // 分，范围从 0 到 59 int tm_hour; // 小时，范围从 0 到 23 int tm_mday; // 一月中的第几天，范围从 1 到 31 int tm_mon; // 月，范围从 0 到 11 int tm_year; // 自 1900 年起的年数 int tm_wday; // 一周中的第几天，范围从 0 到 6，从星期日算起 int tm_yday; // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起 int tm_isdst; // 夏令时&#125; 下面是 C/C++ 中关于日期和时间的重要函数。所有这些函数都是 C/C++ 标准库的组成部分 序号 函数 &amp; 描述 1 time_t time(time_t *time);该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 .1。 2 char ctime(const time_t time);该返回一个表示当地时间的字符串指针，字符串形式 day month year hours:minutes:seconds year\n\0。 3 struct tm localtime(const time_t time);该函数返回一个指向表示本地时间的 tm 结构的指针。 4 clock_t clock(void);该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 .1。 5 char asctime ( const struct tm time );该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\n\0。 6 struct tm gmtime(const time_t time);该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 7 time_t mktime(struct tm *time);该函数返回日历时间，相当于 time 所指向结构中存储的时间。 8 double difftime ( time_t time2, time_t time1 );该函数返回 time1 和 time2 之间相差的秒数。 9 size_t strftime();该函数可用于格式化日期和时间为指定的格式。 当前日期和时间123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;ctime&gt; using namespace std; int main( )&#123; // 基于当前系统的当前日期/时间 time_t now = time(0); // 把 now 转换为字符串形式 char* dt = ctime(&amp;now); cout &lt;&lt; "本地日期和时间：" &lt;&lt; dt &lt;&lt; endl; // 把 now 转换为 tm 结构 tm *gmtm = gmtime(&amp;now); dt = asctime(gmtm); cout &lt;&lt; "UTC 日期和时间："&lt;&lt; dt &lt;&lt; endl;&#125; 使用结构 tm 格式化时间tm 结构在 C/C++ 中处理日期和时间相关的操作时，显得尤为重要。tm 结构以 C 结构的形式保存日期和时间。大多数与时间相关的函数都使用了 tm 结构。下面的实例使用了 tm 结构和各种与日期和时间相关的函数。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;ctime&gt; using namespace std; int main( )&#123; // 基于当前系统的当前日期/时间 time_t now = time(0); cout &lt;&lt; "1970 到目前经过秒数:" &lt;&lt; now &lt;&lt; endl; tm *ltm = localtime(&amp;now); // 输出 tm 结构的各个组成部分 cout &lt;&lt; "年: "&lt;&lt; 1900 + ltm-&gt;tm_year &lt;&lt; endl; cout &lt;&lt; "月: "&lt;&lt; 1 + ltm-&gt;tm_mon&lt;&lt; endl; cout &lt;&lt; "日: "&lt;&lt; ltm-&gt;tm_mday &lt;&lt; endl; cout &lt;&lt; "时间: "&lt;&lt; ltm-&gt;tm_hour &lt;&lt; ":"; cout &lt;&lt; ltm-&gt;tm_min &lt;&lt; ":"; cout &lt;&lt; ltm-&gt;tm_sec &lt;&lt; endl;&#125; C++ 基本的输入输出C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。 I/O 库头文件 头文件 函数和描述 &lt;iostream&gt; 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 &lt;iomanip&gt; 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。 &lt;fstream&gt; 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 标准输出流（cout）定义的对象 cout 是 iostream 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与流插入运算符 &lt;&lt; 结合使用的 C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。流插入运算符 &lt;&lt; 在一个语句中可以多次使用 标准输入流（cin）预定义的对象 cin 是 iostream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 &gt;&gt; 结合使用的 标准错误流（cerr）预定义的对象 cerr 是 iostream 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。cerr 也是与流插入运算符 &lt;&lt; 结合使用的 标准日志流（clog）定义的对象 clog 是 iostream 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。clog 也是与流插入运算符 &lt;&lt; 结合使用的 我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出 C++ 数据结构C/C++ 数组允许定义可存储相同类型数据项的变量，但是结构是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。结构用于表示一条记录。 定义结构为了定义结构，必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下： 12345678struct type_name &#123;member_type1 member_name1;member_type2 member_name2;member_type3 member_name3;..&#125; object_names; type_name 是结构体类型的名称 member_type1 member_name1 是标准的变量定义，比如 int i; 或者 float f;或者其他有效的变量定义。 在结构定义的末尾，最后一个分号之前，可以指定一个或多个结构变量，这是可选的 访问结构成员为了访问结构的成员，使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。 结构作为函数参数可以把结构作为函数参数，传参方式与其他类型的变量或指针类似 实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstring&gt; using namespace std; // 声明一个结构体类型 Books struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;; int main( )&#123; Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, "C++ 教程"); strcpy( Book1.author, "ycp"); strcpy( Book1.subject, "编程语言"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, "CSS 教程"); strcpy( Book2.author, "ycp"); strcpy( Book2.subject, "前端技术"); Book2.book_id = 12346; // 输出 Book1 信息 cout &lt;&lt; "第一本书标题 : " &lt;&lt; Book1.title &lt;&lt;endl; cout &lt;&lt; "第一本书作者 : " &lt;&lt; Book1.author &lt;&lt;endl; cout &lt;&lt; "第一本书类目 : " &lt;&lt; Book1.subject &lt;&lt;endl; cout &lt;&lt; "第一本书 ID : " &lt;&lt; Book1.book_id &lt;&lt;endl; // 输出 Book2 信息 cout &lt;&lt; "第二本书标题 : " &lt;&lt; Book2.title &lt;&lt;endl; cout &lt;&lt; "第二本书作者 : " &lt;&lt; Book2.author &lt;&lt;endl; cout &lt;&lt; "第二本书类目 : " &lt;&lt; Book2.subject &lt;&lt;endl; cout &lt;&lt; "第二本书 ID : " &lt;&lt; Book2.book_id &lt;&lt;endl; return 0;&#125; 结构作为函数参数以把结构作为函数参数，传参方式与其他类型的变量或指针类似 实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstring&gt; using namespace std;void printBook( struct Books book ); // 声明一个结构体类型 Books struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;; int main( )&#123; Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, "C++ 教程"); strcpy( Book1.author, "ycp"); strcpy( Book1.subject, "编程语言"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, "CSS 教程"); strcpy( Book2.author, "ycp"); strcpy( Book2.subject, "前端技术"); Book2.book_id = 12346; // 输出 Book1 信息 printBook( Book1 ); // 输出 Book2 信息 printBook( Book2 ); return 0;&#125;void printBook( struct Books book )&#123; cout &lt;&lt; "书标题 : " &lt;&lt; book.title &lt;&lt;endl; cout &lt;&lt; "书作者 : " &lt;&lt; book.author &lt;&lt;endl; cout &lt;&lt; "书类目 : " &lt;&lt; book.subject &lt;&lt;endl; cout &lt;&lt; "书 ID : " &lt;&lt; book.book_id &lt;&lt;endl;&#125; 指向结构的指针可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示： struct Books *struct_pointer; 现在，可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，把 &amp; 运算符放在结构名称的前面，如下所示： struct_pointer = &amp;Book1; 为了使用指向该结构的指针访问结构的成员，必须使用 -&gt; 运算符，如下所示： struct_pointer-&gt;title; 重写上面的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstring&gt; using namespace std;void printBook( struct Books *book ); struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;; int main( )&#123; Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, "C++ 教程"); strcpy( Book1.author, "ycp"); strcpy( Book1.subject, "编程语言"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, "CSS 教程"); strcpy( Book2.author, "ycp"); strcpy( Book2.subject, "前端技术"); Book2.book_id = 12346; // 通过传 Book1 的地址来输出 Book1 信息 printBook( &amp;Book1 ); // 通过传 Book2 的地址来输出 Book2 信息 printBook( &amp;Book2 ); return 0;&#125;// 该函数以结构指针作为参数void printBook( struct Books *book )&#123; cout &lt;&lt; "书标题 : " &lt;&lt; book-&gt;title &lt;&lt;endl; cout &lt;&lt; "书作者 : " &lt;&lt; book-&gt;author &lt;&lt;endl; cout &lt;&lt; "书类目 : " &lt;&lt; book-&gt;subject &lt;&lt;endl; cout &lt;&lt; "书 ID : " &lt;&lt; book-&gt;book_id &lt;&lt;endl;&#125; typedef 关键字下面是一种更简单的定义结构的方式，可以为创建的类型取一个”别名”。例如：1234567typedef struct&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;Books; 现在，可以直接使用 Books 来定义 Books 类型的变量，而不需要使用 struct 关键字。下面是实例： Books Book1, Book2; 可以使用 typedef 关键字来定义非结构类型，如下所示：typedef long int *pint32; pint32 x, y, z; x, y 和 z 都是指向长整型 long int 的指针。可以使用 typedef 关键字来定义非结构类型，如下所示：typedef long int *pint32; pint32 x, y, z; x, y 和 z 都是指向长整型 long int 的指针。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel中的服务容器]]></title>
    <url>%2F2018%2F07%2F16%2Flaravel%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[控制反转（IoC）和依赖注入（DI）几乎所有php框架，或者对php程序来说，都是单一入口，都是以index.php开始的。那么laravel的入口文件都干了些什么事呢？ IoC 容器 —— Laravel 的核心laravel 的请求生命周期几乎所有php框架，或者对php程序来说，都是单一入口，都是以index.php开始的。那么laravel的 入口文件都干了些什么事呢？ 所有请求通过web服务器（apapache/nignx）引导至 public/index.php。 第一件事就是从bootstrap/app.php脚本中检索laravel应用程序的实例。 引入app.php（创建一个新的应用）$app = require_once __DIR__.&#39;/../bootstrap/app.php&#39;; app.php文件当中，第一件事就是创建一个新的实例; $app = new Illuminate\Foundation\Application( realpath(__DIR__.&#39;/../&#39;) ); 实例化Application 123456789101112131415 class Application extends Container implements ApplicationContract, HttpKernelInterface&#123; public function __construct($basePath = null) &#123; if ($basePath) &#123; $this-&gt;setBasePath($basePath); &#125; $this-&gt;registerBaseBindings(); $this-&gt;registerBaseServiceProviders(); $this-&gt;registerCoreContainerAliases(); &#125;&#125; 实例化的时候干了4件事 绑定当前实例路径 注册基本绑定 注册所有基本服务提供者 注册所有核心依赖到容器中 (2)将重要的接口绑定到容器12345678910111213$app-&gt;singleton( Illuminate\Contracts\Http\Kernel::class, App\Http\Kernel::class);$app-&gt;singleton( Illuminate\Contracts\Console\Kernel::class, App\Console\Kernel::class);$app-&gt;singleton( Illuminate\Contracts\Debug\ExceptionHandler::class, App\Exceptions\Handler::class); 绑定单例到容器（http,kernel,debug） (3)返回应用程序(当前实例)启动应用程序$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class); 这里 Illuminate\Contracts\Http\Kernel::class只是一个接口，这里的$app-&gt;make() 这里有深入研究 Laravel 执行流程（五）之 认识 Make 简单来说就是从容器中解析给定的类型。那么这行代码可以理解为实例化位于app/Http/Kernel.php这个类。 HTTP／控制器内核所有请求都会Http的核心类（kernel）中的handle方法处理 这个handle方法长这个样子 1234567891011121314151617181920212223public function handle($request) &#123; try &#123; $request-&gt;enableHttpMethodParameterOverride(); $response = $this-&gt;sendRequestThroughRouter($request); &#125; catch (Exception $e) &#123; $this-&gt;reportException($e); $response = $this-&gt;renderException($request, $e); &#125; catch (Throwable $e) &#123; $this-&gt;reportException($e = new FatalThrowableError($e)); $response = $this-&gt;renderException($request, $e); &#125; $this-&gt;app['events']-&gt;dispatch( new Events\RequestHandled($request, $response) ); return $response; &#125; 简单来说就是创建了一个新的HTTP内核实例，并且实例化了一些重要的组件 应用程序的请求类型将传入的请求发送到 HTTP 内核或控制台内核。而这两个内核是用来作为所 有请求都要通过的中心位置。一个处理http请求，一个处理控制台请求。我们一般用到的是HTTP 内核。 $response = $kernel-&gt;handle( $request = Illuminate\Http\Request::capture() );实例化了kernel传入了请求类 1234class Request extends SymfonyRequest implements Arrayable, ArrayAccess&#123;&#125; 继承了symfony的Request然后实现了一些接口。 从请求入口后面就可以开始处理自己业务逻辑了 返回$response-&gt;send(); 服务容器与服务提供器服务提供器 最重要的内核引导操作之一是加载应用程序的 服务提供器。应用程序的所有服务提供器都在 config/app.php 配置文件的 providers 数组中配置。首先，所有提供器都会调用 register 方法，接着，由 boot 方法负责调用所有被注册提供器。 服务提供器负责引导所有框架的各种组件，如数据库、队列、验证和路由组件。也就是说，框架提供的每个功能都它们来引导并配置。因此也可以说，服务提供器是整个 Laravel 引导过程中最重要的方面。 简单来说就是在容器中注册需要的类 服务容器服务容器通过构造函数或者某些情况下通过 set 方法将类依赖注入到类中。说得专业点就是用于管理类依赖和执行依赖注入的强大工具 依赖注入与控制反转 我的理解：当一个类A需要实例化另一个类B，我们不在类A里面实例化，让其他类(专门的)来实例化,这个就叫控制反转。那怎么把实例化的类B放到类A,可以通过构造函数,或者set方法注入，这个就叫依赖注入。 在php当中一般使用类型提示注入依赖，比如管理员控制器需要注入，角色和权限 1234567891011class AdminController extends controller&#123; protected $user; protected $role; public function __construct(UserServices $userServices,RoleServices $roleServices) &#123; $this-&gt;user=$userServices; $this-&gt;role=$roleServices; &#125; &#125; 这里的UserService,RoleServices为接口 在laravel中服务容器有一个强大的功能，就是将接口绑定到给定实现。如果需要用到服务容器，一般是注入接口，如果不是就接口，也就没有必要使用了。直接注入就行了，可以使用Repository模式，事实证明，服务容器很麻烦，如果不是超大型项目，根本没有必要使用。 Laravel 的核心就是一个 IoC 容器，高级的IOC容器，他会根据类的依赖需求，自动在注册、绑定的一堆实例中搜寻符合的依赖需求，并自动注入到构造函数参数中去。这种自动搜寻依赖需求的功能，是通过反射（Reflection）实现的。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>IOC</tag>
        <tag>依赖注入</tag>
        <tag>控制反转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel 技巧总结]]></title>
    <url>%2F2018%2F07%2F16%2Flaravel-%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一些使用laravel时用到的一些小技巧建立文件夹，放在app目录下，比如：然后再 conposer.json文件中的自动加载项加入你添加的自定义文件： 添加自定义函数建立文件夹，放在app目录下，比如： 然后再 conposer.json文件中的自动加载项加入你添加的自定义文件： 123456789101112"autoload": &#123; "classmap": [ "database" ], "files":[ "app/Helpers/Helpers.php" ], "psr-4": &#123; "App\\": "app/" &#125; &#125;, 然后运行： composer dump-autoload 开发项目必备 1.ide-hlper composer require --dev barryvdh/laravel-ide-helper 然后在 app/Providers/AppServiceProvider.php file, 添加 12345678public function register()&#123; if ($this-&gt;app-&gt;environment() !== 'production') &#123; $this-&gt;app-&gt;register(\Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider::class); &#125; // ...&#125; 2.laravel-debugbar 1). 使用 Composer 安装该扩展包： composer require barryvdh/laravel-debugbar 2). 安装完成后，修改 config/app.php 在 providers 数组内追加 Debugbar 的 Provider 12345'providers' =&gt; [ ... Barryvdh\Debugbar\ServiceProvider::class,], 同时在 aliases 数组内追加如下内容 12345'aliases' =&gt; [ ... 'Debugbar' =&gt; Barryvdh\Debugbar\Facade::class,] 3). 接下来运行以下命令生成此扩展包的配置文件 config/debugbar.php： php artisan vendor:publish --provider=&quot;Barryvdh\Debugbar\ServiceProvider&quot; 打开 config/debugbar.php，将 enabled 的值设置为： &#39;enabled&#39; =&gt; env(&#39;APP_DEBUG&#39;, false), 修改完以后, Debugbar 分析器的启动状态将由 .env文件中 APP_DEBUG 值决定。 加密解密函数 laravel 当中提供了两种加密解密方式 ###encrypt和decrypt 你可以使用辅助函数 encrypt 来加密一个值。所有加密值都使用 OpenSSL 与 AES-256-CBC 来进行加密。此外，所有加密过的值都会使用消息认证码（MAC）进行签名，以检测加密字符串是否被篡改过： 1234567891011121314151617181920212223242526&lt;?phpnamespace App\Http\Controllers;use App\User;use Illuminate\Http\Request;use App\Http\Controllers\Controller;class UserController extends Controller&#123; /** * 存储用户保密信息 * * @param Request $request * @param int $id * @return Response */ public function storeSecret(Request $request, $id) &#123; $user = User::findOrFail($id); $user-&gt;fill([ 'secret' =&gt; encrypt($request-&gt;secret) ])-&gt;save(); &#125;&#125; 无序列化加密加密值在加密期间通过 serialize 传递，这允许对象和数组的加密。因此，接收加密值的非PHP客户端将需要 unserialize 数据。如果想在不序列化的情况下加密和解密值，可以使用 Crypt Facade 的 encryptString 和 decryptString 方法： use Illuminate\Support\Facades\Crypt; $encrypted = Crypt::encryptString(&#39;Hello world.&#39;); $decrypted = Crypt::decryptString($encrypted); 解密一个值你可以使用辅助函数 decrypt 来解密一个值。如果该值不能被正确解密，例如当 MAC 无效时，会抛出异常 Illuminate\Contracts\Encryption\DecryptException： 12345678use Illuminate\Contracts\Encryption\DecryptException;try &#123; $decrypted = decrypt($encryptedValue);&#125; catch (DecryptException $e) &#123; //&#125; 哈希Laravel Hash Facade 提供安全的 Bcrypt 哈希保存用户密码。 如果应用程序中使用了 Laravel 内置的 LoginController 和 RegisterController 类，它们将自动使用 Bcrypt 进行注册和身份验证 如果用到了laravel auth认证模块，默认是采用这种加密方式 基本用法你可以通过调用 Hash Facade 的 make 方法来填写密码： 1234567891011121314151617181920212223242526&lt;?phpnamespace App\Http\Controllers;use Illuminate\Http\Request;use Illuminate\Support\Facades\Hash;use App\Http\Controllers\Controller;class UpdatePasswordController extends Controller&#123; /** * 更新用户密码 * * @param Request $request * @return Response */ public function update(Request $request) &#123; // Validate the new password length... $request-&gt;user()-&gt;fill([ 'password' =&gt; Hash::make($request-&gt;newPassword) ])-&gt;save(); &#125;&#125; make 方法还能使用 rounds 选项来管理 bcrypt 哈希算法的加密系数。然而，大多数应用程序还是能接受默认值的： 123$hashed = Hash::make('password', [ 'rounds' =&gt; 12]); 根据哈希值验证密码check 方法可以验证给定的纯文本字符串对应于给定的散列。 如果使用 Laravel 内置的 LoginController，则不需要直接使用该方法，因为该控制器会自动调用此方法： 1234if (Hash::check('plain-text', $hashedPassword)) &#123; // 密码对比...&#125; 检查密码是否需要重新加密needsRehash 函数允许你检查已加密的密码所使用的加密系数是否被修改： 1234if (Hash::needsRehash($hashed)) &#123; $hashed = Hash::make('plain-text');&#125; ###PHPSTORM最新注册码 http://www.0-php.com:1017 –2018/3/12（可用）]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>技巧总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT常用命令]]></title>
    <url>%2F2018%2F07%2F16%2FGIT%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[总结了下用的比较多的git命令 1.建立项目文件夹，添加初始代码，比如如果安装了laravel 安装器。可以通过 laravel new test ,创建一个新的项目。 2.在github上面添加一个新的代码仓库，然后复制仓库地址 初始化项目 1.建立项目文件夹，添加初始代码，比如如果安装了laravel 安装器。可以通过 laravel new test ,创建一个新的项目。 2.在github上面添加一个新的代码仓库，然后复制仓库地址 https://github.com/ycp19940225/test.git 通过GIT提交项目 git init 初始化本地代码仓库 git add -A 将所有代码纳入版本控制 git commit -m &#39;init&#39; 此次版本更新说明注释 git remote add origin https://github.com/ycp19940225/test.git 链接到远程仓库 git push -u origin master 上传到主分支 远程服务器更新时发生版本冲突 解决办法：强制覆盖服务器文件 命令 ： git fetch --all git reset --hard origin/master git pull 删除代码仓库进入到代码仓库，点击setting，拉到最下面，点击删除 PHPSTORM当中使用GIT 找到VCS,点击inport into version control ,选择share project on github ,然后输入你的github账号。 这个是真的好用，有代码对比版本记录等等方便的功能，，谁用谁知道 本地服务器发生版本冲突 解决办法：强制覆盖本地文件 git checkout master git reset --hard develop //先将本地的master分支重置成develop git push origin master --force //再推送到远程仓库]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[~~~ 坐在空荡荡的车厢里，望着车窗外的车水马龙，觥筹交错，莫名的空虚感弥漫上心头。每次放假都不想回家，对于家的概念一直不强烈，但是潜意识里不是抗拒它，而是每次回家，总是无尽的争吵，一切不和谐的画面烙在年少的记忆当中。但其实想想自己其实更多的时候是一个被爱的角色，尽管有很多的争吵，但是好像从小我想要的，一切都会尽力为我满足。而我一直没有搞清楚自己想要的是什么。高考之前只是想着一心好好学习，能考上一个好一点的大学。但是当我真的进入了大学这个环境，它不像初中高中，没人约束着你每天都必须要干什么，一切都是靠自己的自觉。当一个人陷入迷茫，大多数选择都是会找到一个精神寄托，或好或坏。 时间真是一个奇妙的东西，它让坚不可摧的东西变得柔软，把你曾经觉得无比重要的一点点消磨。曾经觉得自己其实容易多愁善感的，但是到现在才发觉我只是对自己的情感看的最重要，回想过去多少的决定显得很自私。却固执的认为自己再来一次还是会坚持当时的决定。 阅尽世间繁华，愿归来仍是少年 – 献给未来的自己]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>-feeling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP基础整理（三）]]></title>
    <url>%2F2018%2F07%2F16%2FPHP%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[类与对象（1） PHP 5完全重写了对象模型以得到更佳性能和更多特性,具有完整的对象模型。 PHP 对待对象的方式与引用和句柄相同，即每个变量都持有对象的引用，而不是整个对象的拷贝。 我们都知道PHP对象赋值默认情况下是通过引用传递的，但这并不完全正确。 PHP中的类与对象简介 PHP 5完全重写了对象模型以得到更佳性能和更多特性,具有完整的对象模型。 PHP 对待对象的方式与引用和句柄相同，即每个变量都持有对象的引用，而不是整个对象的拷贝。 我们都知道PHP对象赋值默认情况下是通过引用传递的，但这并不完全正确。 比如： 123456789101112131415class A &#123; public $i = 1;&#125;$a = new A();$b = $a ; //此时，$a,$b是同一个标识符的拷贝，即 ($a) = ($b) = &lt;id&gt;$c = &amp;$a; //此时，$a,$b是引用 即 ($c,$d) = &lt;id&gt;function foo($obj)&#123; $obj-&gt;i = 2 ;&#125;foo($a); //此时传递$a 对象，是标识符拷贝 ，即 // ($obj) = ($e) = &lt;id&gt; ###类型提示 PHP是弱类型语言，向方法传递参数时候也不太区分类型。这样的使用会引起很多的问题，PHP开发者认为，这些问题应该是由代码书写者在书写代码时进行检验以避免。没有类型提示很危险 下面的代码可能会出现问题。 123456789101112131415161718192021222324class NormalUser&#123; /* * 其它相关代码..省略........ */ private $age; public function setAge($_age)&#123; $this-&gt;age = $_age; &#125; public function getAge()&#123; return $this-&gt;age ; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657$normalUser = new NormalUser();$normalUser-&gt;setAge("I am ycp"); //这里我们传输一个非数值.echo "age is " .$normalUser-&gt;getAge();``` //注意输出结果不是我想要的类型.?&gt;程序运行结果：1`age is I am ycp`####原始类型的类型判断PHP中提供了一些函数，来判断数值的类型。我们可使用is_numeric()。判断是否是一个数值或者可转换为数值的字符串。其它相关的还有`is_bool()、is_int()、is_float()、is_integer()、is_numeric()、is_string()、is_array() 和 is_object()`。于是代码有了修改：```php&lt;?class NormalUser&#123; /* * 其它相关代码..省略........ */ private $age; public function setAge($_age)&#123; if(is_numeric($_age))&#123; $this-&gt;age = $_age; &#125; public function getAge()&#123; return $this-&gt;age ; &#125;&#125; 1234567891011121314$normalUser = new NormalUser();$normalUser-&gt;setAge("I am tom"); //这里我们传输一个非数值.echo "age is " .$normalUser-&gt;getAge();//看到这里的结果为空.echo "&lt;br&gt;";$normalUser-&gt;setAge("100");echo "age is ".$normalUser-&gt;getAge();// 这里就有了结果.?&gt; 程序运行结果：12341age is2age is 100 向方法内传递对象如果传递的参数是一个对象呢？下面的代码用起来很正常。 12345678910111213141516171819202122&lt;?class NormalUser &#123; private $name; public function setName($_name)&#123; $this-&gt;name = $_name; &#125; public function getName()&#123; return $this-&gt;name; &#125;&#125; 12345678910111213141516171819202122class UserAdmin&#123; //这里定义的参数,第一个是User类的实例,第二是要设置的名字. public static function changeName($_user,$_name)&#123; $_user-&gt;setName($_name); &#125;&#125;$normalUser = new NormalUser();UserAdmin::changeName($normalUser,"Tom");echo "userName is " . $normalUser-&gt;getName();?&gt; 程序运行结果：121userName is Tom 我们还有一个类，和图书相关的类，在图书类中也可以设置图书的书名setName($name)。如果我向，刚才代码中的方法changeName() 中传入一个Book的实例，原定于改变人名的方法现在改变了书的书名。这有什么风险？能把脏衣服扔到洗衣机里面去洗，同样的清洗，把盘子和碗都扔进洗衣机里面洗洗试试。下面的代码演示我们不想看到的一幕。 12345678910111213141516171819&lt;?class NormalUser&#123; private $name; public function setName($_name)&#123; $this-&gt;name = $_name; &#125; public function getName()&#123; return $this-&gt;name; &#125;&#125; 1234567891011121314151617181920 class Book&#123; private $bookName; public function setName($_name)&#123; $this-&gt;bookName = $_name; &#125; public function getName()&#123; return $this-&gt;bookName; &#125; &#125; 1234567891011121314151617181920212223class UserAdmin&#123; public static function changeName($_user,$_name)&#123; $_user-&gt;setName($_name); &#125;&#125; $book = new Book();UserAdmin::changeName($book,"Tom");echo "bookName is " . $book-&gt;getName(); ?&gt; 程序运行结果：121bookName is Tom 类型提示保障数据安全为了避免对象类型不规范引起的问题，PHP5中引入了类型提示这个概念。在定义方法参数时，同时定义参数的对象类型。如果在调用的时候，传入参数的类型不对会报错。这样保证了数据的安全性。 12345678910111213141516171819202122&lt;?class NormalUser &#123; private $name; public function setName($_name)&#123; $this-&gt;name = $_name; &#125; public function getName()&#123; return $this-&gt;name; &#125;&#125; 123456789101112131415class UserAdmin&#123; public static function changeName(NormalUser $_user,$_name)&#123; $_user-&gt;setName($_name); &#125;&#125;UserAdmin::changeName("anyType","Tom");?&gt; 程序运行结果：121Catchable fatal error: Argument 1 passed to UserAdmin::changeName() must be an instance of NormalUser, string given, called in E:\PHPProjects\NowaMagic\php\php_TypeTips.php on line 221 and defined in E:\PHPProjects\NowaMagic\php\php_TypeTips.php on line 217 建议在定义方法参数时，要使用类型提示。如果类型不是对象，要采用代码进行类型建议，以增强安全性。]]></content>
      <categories>
        <category>PHP基础</category>
      </categories>
      <tags>
        <tag>php基础</tag>
        <tag>类与对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP基础整理（二）]]></title>
    <url>%2F2018%2F07%2F16%2FPHP%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这里记录一些PHP常见的，自己以前理解不到位的一些小问题。时不时会更新 汇总1.$i++和++$i 先看2个例子12345678910&lt;?phpfor($i=0;$i&lt;3;++$i)&#123; $j=$i; echo $j.'-'.$i.'&lt;br/&gt;';&#125;for($i=0;$i&lt;3;$i++)&#123; $j=$i; echo $j.'-'.$i.'&lt;br/&gt;';&#125; 结果为 1234560-01-12-20-01-12-2 以前总是记住$i++是先用再自增，++$i是先自增再用。并没有想过其实现原理。 底层实现应该是这样子的 12345$temp = $i; $i = $i + 1; $j = $temp; 返回的是$j,$i自增。 所以无论运行$i++,++$i,都会使得$i 加1，但是如果要直接使用$i++,或者++$i,可以将其看成一个函数，2者返回值一个是本身，一个是自增后的值。这样上面最开始的例子就好理解了。 第二个： 12345$a=1;echo $a+$a++.'&lt;br/&gt;';$a=1;echo $a+$a+$a++; 结果：12333 这里$i++,++$i会改变局部结合顺序，但仅仅是局部. 通常而言++优先级高,所以$a+$a++ 是先使用后者$a值,又因为是同一变量,本着从左到右结合,在使用第一个$a时值变成了2,所以结果2+1 得3但无论是i++,还是++i(只能改变局部结合顺序),都是加法运算(优先级相同),显然加运算整体从左到右,($a+$a)+$a++,后者$a++ 不影响,后者表达式前2个$a的值.]]></content>
      <categories>
        <category>PHP基础</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>php基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP基础整理（一）]]></title>
    <url>%2F2018%2F07%2F16%2FPHP%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[PHP赋值语句的引用传递与按值传递之前对于php当中的引用传递与按值传递，并没有深入了解 php中对变量赋值有2种方式：这2个主要应用于变量或者函数赋值，计数赋值用于对象赋值。 赋值语句的引用传递与按值传递 之前对于php当中的引用传递与按值传递，并没有深入了解。 php中对变量赋值有2种方式： 按值传递 引用传递 这2个主要应用于变量或者函数赋值，计数赋值用于对象赋值。 ###按值传递 简单来说就是将变量进行复制，然后开辟一块新的内存空间存储。比如： 1234$b = 1;$a = $b;$a = 2;dd($a,$b); 结果为 2 1 $a的改变并不会影响$b的数值。变量相当于一个内存中的地址别名，当$a = $b，就开辟一个新的内存空间，将$a地址内存的数据取出来放在$b所指向的地址中。因为是不同的地址内存中，所以互相不会影响。按值赋值php7之前有个copy on write(写时复制)机制，貌似到php7废除了（以待以后考证）。 ###引用传递 引用传递则是拷贝一份变量的引用。关于变量的引用，有一篇解释的非常好的文章http://www.cnblogs.com/mushan/p/4330386.html。简单来说，php中的变量与值是2个不同的概念，变量存于一个符号表中，并有作用域，而值则在php内部（zend引擎中），存于一个zval结构体当中。 is_ref 代表他是否为引用，是一个bool值，用来标识这个值是否是一个引用。第二个额外字节是refcount，用来表示指向这个值的变量（也称符号即symbol）的个数。如果refcount为0，那么这个值就可以被回收了。 测试代码如下： 123456789101112$b = 1;$a = $b;$a = 2;xdebug_debug_zval('a');xdebug_debug_zval('b');$c = 1;$d = &amp;$c;$d = 2;xdebug_debug_zval('c');xdebug_debug_zval('d');dd($a,$b); 测试结果： 123456789101112a: (refcount=0, is_ref=0)int 2b: (refcount=0, is_ref=0)int 1c: (refcount=2, is_ref=1)int 2d: (refcount=2, is_ref=1)int 2 2 1 2 2 这里我的php版本为7.0.12，a b 变量的refcount都为0了，这是在php7当中对于在zval的value字段中能保存下的值，不在进行引用计数的原因。这里暂时不深入研究，不然又跑远了。 看一下c d 变量使用应用传递的时候，refcount数量都为2，有2个变量指向它，is_ref为1，这就说明c`d都指向了同一个变量，且变量被标记为引用值。当改变了d的的值，c`也会随之改变，因为2者指向同一个zval容器。 默认传值方式 总结 搞清楚PHP引用赋值与按值赋值的过程当中，查了很多资料，也让自己由以前对2者模糊的印象，变得清晰。值得注意的是由于PHP版本不同，让自己测试当中遇到一些困难。PHP7数据结构发生了变化，性能也得到了提升。鸟哥的博客当中对这一块也有过解释，但是我自己的环境运行代码，与他得到的结果也不一样，和php手册上的也不一样。 总的来说，变量与数组一般都是按值赋值，对象默认是引用传递。当需要修改一个内存存储大量数据的变量，或者需要在函数内部修改变量，并返回修改的变量，使用引用传递（&amp;）。 参考资料： php手册：引用的解释 http://php.net/manual/zh/language.references.php php手册：引用计数基本知识 http://php.net/manual/zh/features.gc.refcounting-basics.php 鸟哥博客：深入理解PHP原理之变量分离/引用(Variables Separation) http://www.laruence.com/2008/09/19/520.html php的三种变量赋值方式 http://blog.csdn.net/sanwenyublog/article/details/13021975 –END]]></content>
      <categories>
        <category>PHP基础</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>php基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用php反射机制 获取权限]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%88%A9%E7%94%A8php%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6-%E8%8E%B7%E5%8F%96%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[之前实现了一个基于角色的权限控制，需要后台手动添加权限，当系统庞大的时候，一条条的加无疑是一场灾难…后来看到公司的权限系统利用php反射机制获取权限，感觉很不错，自己查了下php的反射机制，应用在了自己博客中。 数据库表结构截个图吧… pri_name:权限名 pri_desc:权限描述 module_name:模块名 controller:控制器名 action_name:方法名 一些约定1.代码编写时需要以下的格式 12345678910111213141516/** * @name 添加操作 * @desc 添加操作 * @param Request $request * @return \Illuminate\Http\JsonResponse */ public function addOperate(Request $request) &#123; if($this-&gt;user-&gt;checkUnique($request-&gt;input('adminname')))&#123; return response()-&gt;json(msg('error','该管理员已存在！')); &#125; if($this-&gt;user-&gt;saveUser($request))&#123; return response()-&gt;json(msg('success','添加成功!')); &#125; return response()-&gt;json(msg('error','添加失败！')); &#125; 需要注释加上@name @desc，@name是必须的 2.还需要配置你需要控制的模块，在config/app.php 加上1234567/** * 自定义配置 */ 'ACCESS_CHECK_MODULE' =&gt; env('ACCESS_CHECK_MODULE','admin'), 'name_space' =&gt;'App\Http\Controllers', ` .env 文件写上哪些模块需要权限控制 ACCESS_CHECK_MODULE = &#39;Admin 3.被控制的模块路由地址必须和控制器方法名吻合，比如： 1234567 //角色Route::any('/role/add','RoleController@add');Route::post('/role/addOperate','RoleController@addOperate');Route::get('/role/index','RoleController@index');Route::get('/role/edit/&#123;id&#125;','RoleController@edit')-&gt;where('id', '[0-9]+');Route::post('/role/editOperate','RoleController@editOperate');Route::post('/role/delete','RoleController@delete'); 实现PBAC类 这个类的功能只是获取并返回权限 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101 &lt;?php/** * @name 利用反射获取权限树(路由) * @author [ycp] &lt;[820363773@qq.com]&gt; * Author: ycp * Date: 2017/6/14 * Time: 10:35 * Created by PhpStorm. */namespace App\Models;use ReflectionClass;class Rbac&#123; public function getAccess()&#123; //1.获取所有控制器 $modules = config('app.ACCESS_CHECK_MODULE'); $modules = explode(',',$modules); $controllers =[]; $pris = []; //获取基础控制器的方法 $base_controller = config('app.name_space').'\\'.'Controller'; $reflection = new ReflectionClass($base_controller); $action_base_names = $reflection-&gt;getMethods(); $action_base_name=[]; foreach ($action_base_names as $v)&#123; $action_base_name[]=$v-&gt;name; &#125; //循环模块 foreach ($modules as $mk=&gt;$mv)&#123; $controllers = $this-&gt;getController($mv); if($controllers == null)&#123; continue; &#125; //循环控制器 foreach ($controllers as $con)&#123; $con_name = str_replace('Controller','',basename($con)); $reflection2 = new ReflectionClass($con); $action_names = $reflection2-&gt;getMethods(); //循环方法 foreach ($action_names as $ak=&gt;$av)&#123; $av_real = $av-&gt;name; $desc = $av-&gt;getDocComment(); //控制器名称 if (!preg_match('/@name\s+(\w+)/u', $desc, $catch)) continue; $name = $catch[1]; //控制器描述 $description = preg_match('/@desc\s+(\w+)/u', $desc, $catch) ? $catch[1] : ''; if(in_array($av_real,$action_base_name) || $av_real == '__construct')&#123; continue; &#125;else&#123; $pris[] = [ 'module_name' =&gt;$mv, 'controller' =&gt;$con_name, 'action_name' =&gt;$av_real, 'pri_name' =&gt;$name, 'pri_desc' =&gt;$description ]; &#125; &#125; &#125; &#125; return $pris; &#125; /** * 获取所有控制器名称 * @param string $module * @return array */ protected function getController($module)&#123; if(empty($module))&#123; return null; &#125; $module_path = app_path('Http\Controllers').'/'.$module;//模块路径 $module_path = str_replace('\\','/',$module_path); if(!is_dir($module_path)) &#123; return null; &#125;; $module_path .= '/*.php'; $ary_files = glob($module_path); $files= []; foreach ($ary_files as $file)&#123; if(is_dir($file) || basename($file,'.php') =='LoginController')&#123; continue; &#125;else&#123; $files[]=config('app.name_space').'\\'.$module.'\\'.basename($file,'.php'); &#125; &#125; return $files; &#125;&#125; 添加权限123456789101112131415161718192021222324252627282930/** * @name 系统权限添加入库 * @desc 系统权限添加入库 * @return mixed */ public function refreshPri() &#123; $rbac = new Rbac(); $pris = $rbac-&gt;getAccess(); $ids = [] ; //更新或者添加的ID foreach ($pris as $k=&gt;$v)&#123; //添加或者更新已有权限 $pri = $this-&gt;updateOrCreate([ 'module_name' =&gt;$v['module_name'], 'controller' =&gt;$v['controller'], 'action_name' =&gt;$v['action_name'] ],[ 'pri_name' =&gt;$v['pri_name'], 'pri_desc' =&gt;$v['pri_desc'] ]); $ids[] = $pri-&gt;id; &#125; //去掉删除的权限 $old_ids = json_decode($this-&gt;pluck('id'),true); $delete_ids = array_diff($old_ids,$ids); foreach ($delete_ids as $v)&#123; $this-&gt;destroy($v); &#125; return true; &#125; 到这里php处理得就差不多了，然后就是前段展示的问题 展示权限截个图… 权限控制权限检测都在中间件中进行，定义AdminNeedsPermission中间件 12345678910111213141516171819202122232425262728293031&lt;?phpnamespace App\Http\Middleware;use Closure;class AdminNeedsPermission&#123; /** * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure $next * @return mixed */ public function handle($request, Closure $next) &#123; //公共包不做权限验证 if($request-&gt;is('common/*'))&#123; return $next($request); &#125; if(checkPri($request-&gt;path()))&#123; if(\Request::ajax())&#123; return response()-&gt;json(msg('error','您没有权限访问！')); &#125; return redirect('admin')-&gt;with(['SYS_INFO'=&gt;'您没有权限访问！']); &#125; return $next($request); &#125;&#125; checkPri方法：添加到辅助方法helper中 1234567891011121314151617181920212223242526/** * 检测权限 */if ( ! function_exists('checkPri'))&#123; function checkPri($url)&#123; if($url == 'admin')&#123;//首页不验证 return false; &#125; $pris = SC::getUserAccess(); if(count($pris)&gt;0)&#123; if(!is_array($url))&#123; $url = explode('/',$url); &#125; foreach ($pris as $pri)&#123; if($pri-&gt;admin_id ===1)&#123; return false; &#125; if(strtolower($url[0]) == strtolower($pri-&gt;module_name) &amp;&amp; strtolower($url[1]) == strtolower($pri-&gt;controller) &amp;&amp; strtolower($url[2]) == strtolower($pri-&gt;action_name))&#123; return false; &#125; &#125; &#125; return true; &#125;&#125; 总结：实现起来并不复杂，从此不必手动一个个添加权限了 以上代码都在项目https://github.com/ycp19940225/blog可以找到 ——END]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PBAC</tag>
        <tag>reflection</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel Eloquent ORM 模型关联 使用总结]]></title>
    <url>%2F2018%2F07%2F16%2Flaravel-Eloquent-ORM-%E6%A8%A1%E5%9E%8B%E5%85%B3%E8%81%94-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在lavaral中可以直接使用DB查询构建器写sql关联语句，其实挺方便，程序执行效率也会更高。ORM主要应该使用于关联查询比较多的情景。主要是前3种关联用的多。返回的数据是集合类型。 简介laravel当中主要有以下几种关联关系： 一对一 一对多 多对多 远程一对多 多态关联 多对多的多态关联主要是前3种关联用的多。返回的数据是集合类型。 定义关联关系简单定义使用在模型中定义一个函数，比如：1234567891011121314class Users extends Base&#123; protected $table = 'blog_admin'; protected $dateFormat = 'U'; /** * 关联模型 * 属于该用户的身份。 */ public function roles() &#123; return $this-&gt;belongsToMany('App\Models\Admin\Role','blog_admin_role','admin_id','role_id'); &#125;&#125; 使用:按正常查询数据，然后在后面跟上roles属性就行了。需要注意的是，必须是单条记录才能直接使用roles属性。 1$data-&gt;roles; 多条记录需要遍历： 123foreach($data as $v)&#123; $v-&gt;roles;&#125; 关联关系 每种关联关系都有正向关联和反向关联 一对一正向： $this-&gt;hasOne(&#39;要关联的模型名&#39;,&#39;foreign_key&#39;,&#39;local_key&#39;); 反向： $this-&gt;belongsTo(&#39;要关联的模型名&#39;,&#39;local_key&#39;,&#39;foreign_key&#39;); foreign_key:关联模型名对应的外键 local_key:本模型被关联的ID 一对多正向： $this-&gt;hasMany(&#39;要关联的模型名&#39;,&#39;foreign_key&#39;,&#39;local_key&#39;); 反向： $this-&gt;belongsTo(&#39;要关联的模型名&#39;,&#39;local_key&#39;,&#39;foreign_key&#39;); foreign_key:关联模型名对应的外键 local_key:本模型被关联的ID 比如：一个分类对应多篇文章，一个文章只属于一个分类，我在文章模型中定义 正向关联： 12345678/** * 关联模型 * 属于该文章的分类。 */public function cat()&#123; return $this-&gt;hasMany('App\Models\Admin\Cat','id','cat_id');&#125; 反向关联： 12345678/** * 关联模型 * 属于该文章的分类。 */public function cat()&#123; return $this-&gt;belongsTo('App\Models\Admin\Cat','cat_id','id');&#125; 总结来说,第一个参数就是外键，无论正向反向关联，这里填写数据表中的外键即可 多对多比如一个管理员和角色多对多，中间表明为blog_admin_role,可以这样定义：12345678/** * 关联模型 * 属于该用户的身份。 */ public function roles() &#123; return $this-&gt;belongsToMany('App\Models\Admin\Role','blog_admin_role','admin_id','role_id'); &#125; 插入 &amp; 更新关联模型插入关联模型首先需要获取到模型，比如，添加一片文章，然后添加标签 添加文章 1$this_article = $this-&gt;create($data); 添加标签 1$this_article-&gt;tag()-&gt;attach($tags_id); 移除关联模型获取文章 1$this_article = $this-&gt;find($id); 移除标签 1$this_article-&gt;tag()-&gt;detach($tags_id); 更新关联模型1$this_article-&gt;tag()-&gt;sync($tags_id); sync方法会接受一组数据，他会保存新添加的数据，移除删除掉的数据。 以上便是简单使用orm后，自己的一些理解。 —-更新（2017/12/24） 多对多添加更新中间表当多对多中间表需要添加额外字段，可以这样做 12$this_article-&gt;tag()-&gt;attach($tags_id,['key'=&gt;$value]); 或者将$tags_id改造成以下格式（假如额外字段位tag_val） 123[ &apos;1&apos;=&gt;[&apos;tag_val&apos;=&gt;&apos;tag_1&apos;], &apos;2&apos;=&gt;[&apos;tag_val&apos;=&gt;&apos;tag_2&apos;]] 参考： http://laravelacademy.org/post/6996.html – END]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>orm</tag>
        <tag>关联模型</tag>
      </tags>
  </entry>
</search>
