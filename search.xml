<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[利用php反射机制 获取权限]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%88%A9%E7%94%A8php%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6-%E8%8E%B7%E5%8F%96%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[之前实现了一个基于角色的权限控制，需要后台手动添加权限，当系统庞大的时候，一条条的加无疑是一场灾难…后来看到公司的权限系统利用php反射机制获取权限，感觉很不错，自己查了下php的反射机制，应用在了自己博客中。 数据库表结构截个图吧… pri_name:权限名 pri_desc:权限描述 module_name:模块名 controller:控制器名 action_name:方法名 一些约定1.代码编写时需要以下的格式 12345678910111213141516/** * @name 添加操作 * @desc 添加操作 * @param Request $request * @return \Illuminate\Http\JsonResponse */ public function addOperate(Request $request) &#123; if($this-&gt;user-&gt;checkUnique($request-&gt;input('adminname')))&#123; return response()-&gt;json(msg('error','该管理员已存在！')); &#125; if($this-&gt;user-&gt;saveUser($request))&#123; return response()-&gt;json(msg('success','添加成功!')); &#125; return response()-&gt;json(msg('error','添加失败！')); &#125; 需要注释加上@name @desc，@name是必须的 2.还需要配置你需要控制的模块，在config/app.php 加上1234567/** * 自定义配置 */ 'ACCESS_CHECK_MODULE' =&gt; env('ACCESS_CHECK_MODULE','admin'), 'name_space' =&gt;'App\Http\Controllers', ` .env 文件写上哪些模块需要权限控制 ACCESS_CHECK_MODULE = &#39;Admin 3.被控制的模块路由地址必须和控制器方法名吻合，比如： 1234567 //角色Route::any('/role/add','RoleController@add');Route::post('/role/addOperate','RoleController@addOperate');Route::get('/role/index','RoleController@index');Route::get('/role/edit/&#123;id&#125;','RoleController@edit')-&gt;where('id', '[0-9]+');Route::post('/role/editOperate','RoleController@editOperate');Route::post('/role/delete','RoleController@delete'); 实现PBAC类 这个类的功能只是获取并返回权限 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101 &lt;?php/** * @name 利用反射获取权限树(路由) * @author [ycp] &lt;[820363773@qq.com]&gt; * Author: ycp * Date: 2017/6/14 * Time: 10:35 * Created by PhpStorm. */namespace App\Models;use ReflectionClass;class Rbac&#123; public function getAccess()&#123; //1.获取所有控制器 $modules = config('app.ACCESS_CHECK_MODULE'); $modules = explode(',',$modules); $controllers =[]; $pris = []; //获取基础控制器的方法 $base_controller = config('app.name_space').'\\'.'Controller'; $reflection = new ReflectionClass($base_controller); $action_base_names = $reflection-&gt;getMethods(); $action_base_name=[]; foreach ($action_base_names as $v)&#123; $action_base_name[]=$v-&gt;name; &#125; //循环模块 foreach ($modules as $mk=&gt;$mv)&#123; $controllers = $this-&gt;getController($mv); if($controllers == null)&#123; continue; &#125; //循环控制器 foreach ($controllers as $con)&#123; $con_name = str_replace('Controller','',basename($con)); $reflection2 = new ReflectionClass($con); $action_names = $reflection2-&gt;getMethods(); //循环方法 foreach ($action_names as $ak=&gt;$av)&#123; $av_real = $av-&gt;name; $desc = $av-&gt;getDocComment(); //控制器名称 if (!preg_match('/@name\s+(\w+)/u', $desc, $catch)) continue; $name = $catch[1]; //控制器描述 $description = preg_match('/@desc\s+(\w+)/u', $desc, $catch) ? $catch[1] : ''; if(in_array($av_real,$action_base_name) || $av_real == '__construct')&#123; continue; &#125;else&#123; $pris[] = [ 'module_name' =&gt;$mv, 'controller' =&gt;$con_name, 'action_name' =&gt;$av_real, 'pri_name' =&gt;$name, 'pri_desc' =&gt;$description ]; &#125; &#125; &#125; &#125; return $pris; &#125; /** * 获取所有控制器名称 * @param string $module * @return array */ protected function getController($module)&#123; if(empty($module))&#123; return null; &#125; $module_path = app_path('Http\Controllers').'/'.$module;//模块路径 $module_path = str_replace('\\','/',$module_path); if(!is_dir($module_path)) &#123; return null; &#125;; $module_path .= '/*.php'; $ary_files = glob($module_path); $files= []; foreach ($ary_files as $file)&#123; if(is_dir($file) || basename($file,'.php') =='LoginController')&#123; continue; &#125;else&#123; $files[]=config('app.name_space').'\\'.$module.'\\'.basename($file,'.php'); &#125; &#125; return $files; &#125;&#125; 添加权限123456789101112131415161718192021222324252627282930/** * @name 系统权限添加入库 * @desc 系统权限添加入库 * @return mixed */ public function refreshPri() &#123; $rbac = new Rbac(); $pris = $rbac-&gt;getAccess(); $ids = [] ; //更新或者添加的ID foreach ($pris as $k=&gt;$v)&#123; //添加或者更新已有权限 $pri = $this-&gt;updateOrCreate([ 'module_name' =&gt;$v['module_name'], 'controller' =&gt;$v['controller'], 'action_name' =&gt;$v['action_name'] ],[ 'pri_name' =&gt;$v['pri_name'], 'pri_desc' =&gt;$v['pri_desc'] ]); $ids[] = $pri-&gt;id; &#125; //去掉删除的权限 $old_ids = json_decode($this-&gt;pluck('id'),true); $delete_ids = array_diff($old_ids,$ids); foreach ($delete_ids as $v)&#123; $this-&gt;destroy($v); &#125; return true; &#125; 到这里php处理得就差不多了，然后就是前段展示的问题 展示权限截个图… 权限控制权限检测都在中间件中进行，定义AdminNeedsPermission中间件 12345678910111213141516171819202122232425262728293031&lt;?phpnamespace App\Http\Middleware;use Closure;class AdminNeedsPermission&#123; /** * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure $next * @return mixed */ public function handle($request, Closure $next) &#123; //公共包不做权限验证 if($request-&gt;is('common/*'))&#123; return $next($request); &#125; if(checkPri($request-&gt;path()))&#123; if(\Request::ajax())&#123; return response()-&gt;json(msg('error','您没有权限访问！')); &#125; return redirect('admin')-&gt;with(['SYS_INFO'=&gt;'您没有权限访问！']); &#125; return $next($request); &#125;&#125; checkPri方法：添加到辅助方法helper中 1234567891011121314151617181920212223242526/** * 检测权限 */if ( ! function_exists('checkPri'))&#123; function checkPri($url)&#123; if($url == 'admin')&#123;//首页不验证 return false; &#125; $pris = SC::getUserAccess(); if(count($pris)&gt;0)&#123; if(!is_array($url))&#123; $url = explode('/',$url); &#125; foreach ($pris as $pri)&#123; if($pri-&gt;admin_id ===1)&#123; return false; &#125; if(strtolower($url[0]) == strtolower($pri-&gt;module_name) &amp;&amp; strtolower($url[1]) == strtolower($pri-&gt;controller) &amp;&amp; strtolower($url[2]) == strtolower($pri-&gt;action_name))&#123; return false; &#125; &#125; &#125; return true; &#125;&#125; 总结：实现起来并不复杂，从此不必手动一个个添加权限了 以上代码都在项目https://github.com/ycp19940225/blog可以找到 ——END]]></content>
      <tags>
        <tag>PBAC</tag>
        <tag>reflection</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel Eloquent ORM 模型关联 使用总结]]></title>
    <url>%2F2018%2F07%2F16%2Flaravel-Eloquent-ORM-%E6%A8%A1%E5%9E%8B%E5%85%B3%E8%81%94-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在lavaral中可以直接使用DB查询构建器写sql关联语句，其实挺方便，程序执行效率也会更高。ORM主要应该使用于关联查询比较多的情景。 简介laravel当中主要有以下几种关联关系： 一对一 一对多 多对多 远程一对多 多态关联 多对多的多态关联 主要是前3种关联用的多。返回的数据是集合类型。 定义关联关系简单定义使用在模型中定义一个函数，比如：1234567891011121314class Users extends Base&#123; protected $table = 'blog_admin'; protected $dateFormat = 'U'; /** * 关联模型 * 属于该用户的身份。 */ public function roles() &#123; return $this-&gt;belongsToMany('App\Models\Admin\Role','blog_admin_role','admin_id','role_id'); &#125;&#125; 使用:按正常查询数据，然后在后面跟上roles属性就行了。需要注意的是，必须是单条记录才能直接使用roles属性。 1$data-&gt;roles; 多条记录需要遍历： 123foreach($data as $v)&#123; $v-&gt;roles;&#125; 关联关系 每种关联关系都有正向关联和反向关联 一对一正向： $this-&gt;hasOne(&#39;要关联的模型名&#39;,&#39;foreign_key&#39;,&#39;local_key&#39;); 反向： $this-&gt;belongsTo(&#39;要关联的模型名&#39;,&#39;local_key&#39;,&#39;foreign_key&#39;); foreign_key:关联模型名对应的外键 local_key:本模型被关联的ID 一对多正向： $this-&gt;hasMany(&#39;要关联的模型名&#39;,&#39;foreign_key&#39;,&#39;local_key&#39;); 反向： $this-&gt;belongsTo(&#39;要关联的模型名&#39;,&#39;local_key&#39;,&#39;foreign_key&#39;); foreign_key:关联模型名对应的外键 local_key:本模型被关联的ID 比如：一个分类对应多篇文章，一个文章只属于一个分类，我在文章模型中定义 正向关联： 12345678/** * 关联模型 * 属于该文章的分类。 */public function cat()&#123; return $this-&gt;hasMany('App\Models\Admin\Cat','id','cat_id');&#125; 反向关联： 12345678/** * 关联模型 * 属于该文章的分类。 */public function cat()&#123; return $this-&gt;belongsTo('App\Models\Admin\Cat','cat_id','id');&#125; 总结来说,第一个参数就是外键，无论正向反向关联，这里填写数据表中的外键即可 多对多比如一个管理员和角色多对多，中间表明为blog_admin_role,可以这样定义：12345678/** * 关联模型 * 属于该用户的身份。 */ public function roles() &#123; return $this-&gt;belongsToMany('App\Models\Admin\Role','blog_admin_role','admin_id','role_id'); &#125; 插入 &amp; 更新关联模型插入关联模型首先需要获取到模型，比如，添加一片文章，然后添加标签 添加文章 1$this_article = $this-&gt;create($data); 添加标签 1$this_article-&gt;tag()-&gt;attach($tags_id); 移除关联模型获取文章 1$this_article = $this-&gt;find($id); 移除标签 1$this_article-&gt;tag()-&gt;detach($tags_id); 更新关联模型1$this_article-&gt;tag()-&gt;sync($tags_id); sync方法会接受一组数据，他会保存新添加的数据，移除删除掉的数据。 以上便是简单使用orm后，自己的一些理解。 —-更新（2017/12/24） 多对多添加更新中间表当多对多中间表需要添加额外字段，可以这样做 12$this_article-&gt;tag()-&gt;attach($tags_id,['key'=&gt;$value]); 或者将$tags_id改造成以下格式（假如额外字段位tag_val） 123[ &apos;1&apos;=&gt;[&apos;tag_val&apos;=&gt;&apos;tag_1&apos;], &apos;2&apos;=&gt;[&apos;tag_val&apos;=&gt;&apos;tag_2&apos;]] 参考： http://laravelacademy.org/post/6996.html – END]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>orm</tag>
        <tag>关联模型</tag>
      </tags>
  </entry>
</search>
