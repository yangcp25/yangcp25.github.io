+++
date = '2025-08-01T09:10:00+08:00'
title = 'Gc'
draft = false
tag = ['go', 'gc']
+++
### 什么是GC
gc就是内存垃圾回收。c/c++这类语言可以由程序员申请内存，分配到堆上，堆上的数据随着函数结束并不会自动被清零，需要程序员手动清理。
这会给编程增加负担和隐患。高级语言如java/go支持gc,自动分析没有被引用的变量，进行内存回收。
#### 常见的GC方法
##### 引用计数法
对变量对象的引用次数进行计数，当计数为0就会被回收。它实现简单，但效率不高无法解决循环引用的问题。
##### 标记清除法
扫描所有对象，将有引用的进行标记。优点是实现简单，但可能出现很多内存碎片，不利于内存重新分配。
##### 复制法
准备2个大小一样的内存块，将存活的对象放到新的内存块。优点是解决了内存碎片问题，但内存复制比较消耗资源，还需要将引用关系进行复制。
##### 分代法
将对象创建的不同时间分为青年代、中年代、老年代。
##### 三色标记法
stw可以是start the world 或者 stop zhe world的缩写，他指的是stop the word 到 start the world 这个间隔的时间。在gc过程总需要暂停用户
代码执行，进行内存扫描，这个stw时间越短，对程序的性能提升越高。
### go的GC实现
go因为内存分配是采用tcmalloc分配法，所有不需要处理内存碎片问题，同时go团队更加希望的是gc操作可以和用户代码一起执行，不仅是减少
stw的时间。go采用三色标记法对内存进行回收，并采用混合屏障提升并发时的回收效率。
#### 扫描过程
分为4步
1. 所有根对象标记为白色
2. 将根对象放入待扫描队列，标记成灰色
3. 扫描队列所有的灰色对象，标记成黑色，并将引用对象标记成灰色。
4. 重复步骤三，直到待扫描的灰色对象为空，所有对象标记成黑色或者白色。白色对象不可达，进行回收。
根对象在垃圾回收术语中被称为根集合，它包含
* 全局对象，程序在编译阶段就能确定的存在于程序整个生命周期的对象
* 执行栈，每个goroutine都有自己的内存栈
* 寄存器，可以是指向变量的指针
#### 没有stw可能得问题
1. 对象被错误删除
假设以下场景：扫描到某个节点，存在a灰色对象引用白色对象b,存在一个黑色对象c。此时现将删除a对b的引用，同时添加
c对b的引用。b本来应该被正确标记成黑色的，由于对象c为黑色不会对它进行扫描，而a又删除了对b的引用，就会造成c始终不可达
造成误删除。
#### 混合写屏障
作用是减少stw的时间，具体的做法如下：
* 插入对象直接置为黑色对象
* 
### 分析工具和分析方法

#### 如何针对GC进行优化
