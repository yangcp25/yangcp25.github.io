+++
date = '2025-08-01T09:10:00+08:00'
title = 'Gc'
draft = false
tag = ['go', 'gc']
+++
### 什么是GC
gc就是内存垃圾回收。c/c++这类语言可以由程序员申请内存，分配到堆上，堆上的数据随着函数结束并不会自动被清零，需要程序员手动清理。
这会给编程增加负担和隐患。高级语言如java/go支持gc,自动分析没有被引用的变量，进行内存回收。
#### 常见的GC方法
##### 引用计数法
对变量对象的引用次数进行计数，当计数为0就会被回收。它实现简单，但效率不高无法解决循环引用的问题。
##### 标记清除法
扫描所有对象，将有引用的进行标记。优点是实现简单，但可能出现很多内存碎片，不利于内存重新分配。
##### 复制法
准备2个大小一样的内存块，将存活的对象放到新的内存块。优点是解决了内存碎片问题，但内存复制比较消耗资源，还需要将引用关系进行复制。
##### 分代法
将对象创建的不同时间分为青年代、老年代。分代发基于一种实践思想，大多数对象的生命周期都很短。
##### 三色标记法
stw可以是start the world 或者 stop zhe world的缩写，他指的是stop the word 到 start the world 这个间隔的时间。在gc过程需要暂停用户
代码执行，进行内存扫描，这个stw时间越短，对程序的性能提升越高。
### go的GC实现
go因为内存分配是采用tcmalloc分配法，所有不需要处理内存碎片问题，同时go团队更加希望的是gc操作可以和用户代码一起执行，不仅是减少
stw的时间。go采用三色标记法对内存进行回收，并采用混合屏障提升并发时的回收效率。
#### tcmalloc内存分配
首先每个协程都有自己的内存分配器，由一系列递增的内存大小块组成，每次内存申请回优先在本地分配器进行申请，当内存不足会向更高一级的内存分配器进行申请。
内存分类器会定时整理内存碎片，当空闲内存超过一定数量时会进行内存回收，不足时会进行内存分配。
#### go为什么采用三色标记法
* go采用tcmalloc所以对内存碎片优化的方案的gc算法并不会带来明显的性能提升
* go团队的目标不仅仅是减少stw的时候，还希望回收过程可以和用户代码共同执行，提升程序性能。
#### 定义
go的gc扫描器将所有对象分为三类，分别是：
1. 白色对象（可能存活的对象）：一开始所有对象都标记成白色对象，当扫描完成后，白色对象不可达
2. 灰色对象（波面）：正在被访问器访问到的对象，他可能指向白色对象
3. 黑色对象（确定存活）：已经被回收期扫描。
#### 扫描过程
分为4步
1. 所有根对象标记为白色
2. 将根对象放入待扫描队列，标记成灰色
3. 扫描队列所有的灰色对象，标记成黑色，并将引用对象标记成灰色。
4. 重复步骤三，直到待扫描的灰色对象为空，所有对象标记成黑色或者白色。白色对象不可达，进行回收。
根对象在垃圾回收术语中被称为根集合，它包含
* 全局对象，程序在编译阶段就能确定的存在于程序整个生命周期的对象
* 执行栈，每个goroutine都有自己的内存栈，会有自己的栈对象和指向堆区块的指针
* 寄存器，计算过程中可能指向的一些堆区块的指针
#### 没有stw可能得问题，对象被错误删除
假设以下场景：扫描到某个节点，存在a灰色对象引用白色对象b,存在一个黑色对象c。此时现将删除a对b的引用，同时添加
c对b的引用。b本来应该被正确标记成黑色的，由于对象c为黑色不会对它进行扫描，而a又删除了对b的引用，就会造成c始终不可达
造成误删除。  
当同时满足以下2个条件时，会出现误删除：
1. 赋值器创建一个黑色对象对白色对象的引用
2. 删除灰色对象对这个白色的引用
只要破坏任意条件就可以避免误删除
* 避免条件一，也就避免了修改对象池当中需要被删除的对象的存活状态，应该存活的对象均可达。出现条件二，删除了灰色对象对白色对象的引用
这个白色对象也应该被删除。
* 避免条件二，白色对象最终可以由灰色访问到，进行正常标记。就算创建了黑色对象对白色对象的引用，也可以由灰色对象触达。
### 屏障机制
分成2种赋值器，插入时使用灰色赋值器，删除时使用黑色赋值器
#### 插入屏障
当添加一新的对象引用时，会先将插入对象赋值成灰色。破坏条件一，破坏了增加了一个黑色对象对白色对象的引用。有个一个细节，由于对所有对象进行插入屏障会比较
影响性能，golang团队后来决定只对堆区的对象启用插入屏障，栈区的对象会在第一次gc完成之后stw重新扫描一次栈区。
#### 删除屏障
当删除一个对象时，现将对象赋值为黑色。破坏条件二，破坏了删除一个灰色对象对白色对象的引用。
#### 混合屏障
* 栈区：
  * gc开始阶段栈区所有的对象都被遍历并标记为黑色
  * gc进行阶段，增加和删除的对象也都被标记成黑色
* 堆区：删除或添加对象都标记为灰色
### 分析工具和分析方法
go的垃圾回收算法是按比例，无分代，与用户代码并发执行，无内存移动并主动向操作系统归还内存的回收算法，所以需要关注的点是：
* CPU利用率
* stw的时间和频率
#### 如何针对GC进行优化
* 调整gc CPU使用率
* 逃逸分析尽可能将变量分配到栈上