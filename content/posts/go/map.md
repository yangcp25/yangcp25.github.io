+++
date = '2025-07-29T09:23:59+08:00'
draft = false
title = 'Map'
+++
### go的哈希实现
#### 通用哈希实现
哈希表是一个高效的数据结构，通过对key经过哈希函数计算的值和存储数据的数组的长度，两者求余得到在数组插入的位置。高效的查找效率
时间复杂度为O(1)。
##### 哈希函数
* 任意长度的输入有固定输出
* 同一输入会产生同一个输出
* 输入的细小改变会造成输入的完全不一样
* 速度快
* 单项不可逆
#### go的哈希底层实现
通过底层结构体hmap来实例化map对象，hmap 包含指向[]bucket数组的指针。bucket结构里面会存储真实的数据
以key1key2 val1value2 的形式进行排列，方便内存对齐。头部有top哈希方便bucket内部进行数据定位，底部有指向溢出bucket的指针。
当发生哈希冲突，冲突的数据会存放到溢出bucket链表。
##### 插入过程
首先用哈希函数对key计算，得到64位数据（64位机器上）。低B位决定数据落入哪个桶。B是log2count，也就是以2为底bucket元素的长度的对数。
高8位决定落入bucket具体的位置。如果发送哈希冲突，就把数据存入溢出桶。
##### 遍历过程、查找过程
* 遍历：从0-bucket长度随机一个数字选择bucket进行遍历。所以go的map是无序。如果bucket遍历完，溢出桶不为空，继续遍历溢出桶。
* 查找：哈希函数对key计算，低8位找到具体的桶。高8位拿来和bucket的top哈希进行比较，如果一致，再比较具体的key,如果相同就返回，
否则再看溢出桶是否为空，不会空对链表进行遍历。如果都没有就返回查找失败。
#### go的扩容过程
当哈希函数产生过多的哈希碰撞时，就会导致查询效率低下，为了减少哈希碰撞，需要对底层数组的容量扩容或者对数据进行从新排列。
当满足一下任意条件会触发扩容
* 当碰撞因子>6.5, 碰撞因子=count(实际元素个数)/2的B次方（bucket数组总的元素长度）
* 当溢出桶过多时，当B < 15 , 当溢出桶的个数>B次方，触发扩容。当B>15时，overflow超过2的15次方。
#### 为什么是线程不安全的
#### sync.map使用
##### sync.map如何实现的
#### 注意事项
