+++
date = '2025-10-31T18:10:00+08:00'
draft = false
title = '内存分配'
+++
## go的内存分配

根据对象大小的不同，go的内存分配有3种类型：
Tiny(size < 16B): Objects of size less than 16 bytes are allocated using the mcache’s tiny allocator. This is efficient and multiple tiny allocations are done on a single 16-byte block. 
Small(size 16B ~ 32KB): Objects of size between 16 bytes and 32 Kilobytes are allocated on the corresponding size class(mspan) on mcache of the P where the G is running. In both tiny and small allocation if the mspan’s list is empty the allocator will obtain a run of pages from the mheap to use for the mspan. If the mheap is empty or has no page runs large enough then it allocates a new group of pages (at least 1MB) from the OS. 
Large(size > 32KB): Objects of size greater than 32 kilobytes are allocated directly on the corresponding size class of mheap. If the mheap is empty or has no page runs large enough then it allocates a new group of pages (at least 1MB) from the OS. 
总结一下Go是如何进行内存分配: mcache中如果有空闲的空间， 那么直接在mcache分配 mcache如果没有，那么尝试去mcentral中获取一个空闲的mspan mcentral中也咩有可用的mspan，那么直接去mheap向操作系统申请可用的mspan



## 和 **mcache、mcentral、mheap** 之间的联系

### 1. **mspan 与大小分类的关系**

首先要明确一点：**mspan** 并不是直接和每个对象大小一一对应的，而是用于管理一定范围内大小的内存块的。每个 `mspan` 可以包含多个对象，并且一个 `mspan` 的大小通常是多个相同大小的对象一起构成的。

#### 对象大小与 `mspan` 的关系：

* **Tiny 分配**（小于 16B）：

    * 对于 `< 16B` 的小对象，Go 不会为每个对象单独分配一个 8KB 或 16KB 的 `mspan`。相反，这些小对象会被 **批量分配到一个固定大小的内存区域**，通常是一个 **16 字节的块**，也就是 **tiny allocator** 的内存池。
    * `mspan` 对于这些小对象的作用是：**一块小内存块可以包含多个小对象**，而 `mspan` 本身并不是用于存储单一的 16B 或更小的对象。多个小对象（比如多个小于 16B 的对象）会在一个 `mspan` 中共享这块内存。

* **Small 分配**（16B ~ 32KB）：

    * 对于这类对象，Go 会根据对象大小将它们划分到不同的大小类（size class）中，并为每个大小类创建一个 `mspan`。比如，16B、32B、64B 等对象大小就会分别分配到对应的 `mspan`（每个 `mspan` 的大小可能是 8KB、16KB 或其他）。
    * 这些 `mspan` 用来存储多个相同大小的对象，每个 `mspan` 会有多个空闲的对象块，直到这些 `mspan` 被填满或者空闲对象用完。

* **Large 分配**（大于 32KB）：

    * 对于大于 32KB 的对象，Go 直接在 `mheap` 中分配内存，不会使用 `mcache` 或 `mspan`。这些对象会直接向操作系统请求大的内存页（通常是 4KB 或更大的页面），并在 **mheap** 中进行管理。

---

### 2. **mcache、mcentral 和 mheap 的关系**

这些分配区域和 **Tiny、Small、Large** 内存分配类别之间有很大的关系，下面是它们如何协作：

* **mcache**：

    * 每个处理器（`P`）都有一个 `mcache`，它用于快速分配小对象。它有多个 **mspan**，这些 `mspan` 存储着多个相同大小的对象。
    * **Tiny 分配**：如果你分配的对象小于 16B，`mcache` 会直接在 **tiny allocator** 中分配内存（这个区域用于非常小的对象），这些对象不会占用一个完整的 `mspan`，而是在一个 16 字节大小的块中共享内存。
    * **Small 分配**：如果你分配的对象大小在 16B 到 32KB 之间，`mcache` 会查看其对应的 `mspan`，如果 `mspan` 空闲且符合条件，它会直接分配。如果没有空闲的 `mspan`，`mcache` 会请求 `mcentral` 获取新的 `mspan`。

* **mcentral**：

    * `mcentral` 是一个更大的缓存池，用于存储多个 `mspan`，如果 `mcache` 中没有足够的内存块来满足请求，它会向 `mcentral` 请求新的 `mspan`。这通常发生在中等大小的对象（16B ~ 32KB）分配时。
    * `mcentral` 会缓存各个大小类的 `mspan`，并将它们分发给不同的 `mcache`。当 `mcache` 的空间不足时，它会从 `mcentral` 获取更多的 `mspan`。

* **mheap**：

    * **Large 分配**：对于大于 32KB 的对象，Go 会直接在 **mheap** 中分配内存，`mheap` 管理的是操作系统的内存页（每页 4KB）。当 `mcache` 和 `mcentral` 没有足够的空闲空间时，`mheap` 会向操作系统申请新的内存区域（通常至少为 1MB），并将这些内存划分为多个 `mspan` 进行管理。

---

### 3. 总结
：
* **Tiny 分配（< 16B）**：这类小对象会在 `mcache` 中的 **tiny allocator** 中分配，而不会直接占用一个 8KB 的 `mspan`。这些小对象可以在 16 字节的小块内存区域中分配。
* **Small 分配（16B ~ 32KB）**：这类对象会根据大小分配到 `mcache` 的 `mspan` 中，`mspan` 会缓存多个相同大小的对象。如果没有空闲的 `mspan`，会从 `mcentral` 获取。
* **Large 分配（> 32KB）**：这类大对象直接在 `mheap` 中分配内存。

总的来说，**mspan** 用于存储相同大小的多个对象，**mcache** 用来缓存小对象，**mcentral** 是更大的内存池，用于缓存多个 `mspan`，**mheap** 是整个堆内存的管理区。

