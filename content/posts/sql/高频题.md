+++
date = '2025-10-27T10:26:15+08:00'
draft = false
title = 'sql高频题'
+++


分为六个维度：**基础聚合 → 子查询 → TopN → 窗口函数 → 业务建模 → 性能优化**。


---

# 🎯 高频 SQL 题库（含答案与思路）

---

## 一、基础聚合与分组（GROUP BY / HAVING）

### 🧩 题 1：查询每个部门的平均工资

**表结构：**

```sql
employee(emp_id, emp_name, dept_id, salary)
```

**SQL：**

```sql
SELECT dept_id, AVG(salary) AS avg_salary
FROM employee
GROUP BY dept_id;
```

📘 **考点：** 聚合函数 + 分组

---

### 🧩 题 2：查询带学生数超过 10 人的老师

```sql
teacher(teacher_id, name)
student(student_id, teacher_id)
```

**SQL：**

```sql
SELECT teacher_id, COUNT(*) AS student_count
FROM student
GROUP BY teacher_id
HAVING COUNT(*) > 10;
```

📘 **考点：** `HAVING` 与 `WHERE` 的区别（`HAVING` 针对聚合后过滤）

---

## 二、子查询（Subquery）

### 🧩 题 3：查询工资高于本部门平均工资的员工

```sql
SELECT e.emp_name, e.salary
FROM employee e
JOIN (
  SELECT dept_id, AVG(salary) AS avg_salary
  FROM employee
  GROUP BY dept_id
) d ON e.dept_id = d.dept_id
WHERE e.salary > d.avg_salary;
```

📘 **考点：** 相关子查询 vs 非相关子查询

---

### 🧩 题 4：查询至少有一笔订单金额超过 1000 的用户

```sql
SELECT user_id
FROM orders
WHERE amount > 1000
GROUP BY user_id;
```

📘 **变形题：** 可以写成 `EXISTS`：

```sql
SELECT DISTINCT u.user_id
FROM users u
WHERE EXISTS (
  SELECT 1 FROM orders o 
  WHERE o.user_id = u.user_id AND o.amount > 1000
);
```

---

## 三、Top N 查询（分组取最大 / 最小）

### 🧩 题 5：查询每个部门工资最高的员工

```sql
SELECT e.*
FROM employee e
JOIN (
  SELECT dept_id, MAX(salary) AS max_salary
  FROM employee
  GROUP BY dept_id
) t ON e.dept_id = t.dept_id AND e.salary = t.max_salary;
```

📘 **考点：** group by + join 拿分组最大值

---

### 🧩 题 6：查询销售额排名前三的商品

```sql
SELECT product_id, SUM(amount) AS total_sales
FROM orders
GROUP BY product_id
ORDER BY total_sales DESC
LIMIT 3;
```

📘 **考点：** 聚合 + 排序 + limit

---

## 四、窗口函数（Window Function）

### 🧩 题 7：查询每个部门工资第二高的员工

```sql
SELECT *
FROM (
  SELECT emp_id, dept_id, salary,
         ROW_NUMBER() OVER (PARTITION BY dept_id ORDER BY salary DESC) AS rn
  FROM employee
) t
WHERE rn = 2;
```

📘 **考点：** `ROW_NUMBER()` / `RANK()` / `DENSE_RANK()` 区别

---

### 🧩 题 8：统计用户连续签到 >= 3 天的情况

```sql
SELECT user_id
FROM (
  SELECT user_id,
         DATE_SUB(sign_date, INTERVAL ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY sign_date) DAY) AS grp
  FROM sign_log
) t
GROUP BY user_id, grp
HAVING COUNT(*) >= 3;
```

📘 **考点：** 窗口函数 + 日期差分连续性判断

---

## 五、业务建模类题（JOIN + 分组 + 条件）

### 🧩 题 9：查询每个课程的平均评分

```sql
SELECT course_id, AVG(score) AS avg_score
FROM course_rating
GROUP BY course_id
ORDER BY avg_score DESC;
```

---

### 🧩 题 10：查询下过订单但从未付款的用户

```sql
SELECT DISTINCT o.user_id
FROM orders o
LEFT JOIN payments p ON o.order_id = p.order_id
WHERE p.order_id IS NULL;
```

📘 **考点：** 左连接 + null 判断（反查）

---

### 🧩 题 11：查询每个用户最后一次下单时间

```sql
SELECT user_id, MAX(order_time) AS last_order_time
FROM orders
GROUP BY user_id;
```

---

### 🧩 题 12：查询下单金额最高的前 10 个用户及他们的平均下单额

```sql
WITH ranked AS (
  SELECT user_id, SUM(amount) AS total_amount
  FROM orders
  GROUP BY user_id
  ORDER BY total_amount DESC
  LIMIT 10
)
SELECT AVG(total_amount) FROM ranked;
```

---

## 六、性能优化与索引设计（开放题）

### 🧩 题 13：为什么这条 SQL 很慢？

```sql
SELECT * FROM orders WHERE DATE(create_time) = '2025-10-24';
```

📘 **原因：**

* 使用了函数 `DATE()` 导致索引失效。

✅ **优化：**

```sql
SELECT * FROM orders 
WHERE create_time >= '2025-10-24 00:00:00'
  AND create_time < '2025-10-25 00:00:00';
```

---

### 🧩 题 14：分页查询优化

**问题：**

```sql
SELECT * FROM orders ORDER BY id LIMIT 100000, 20;
```

太慢，因为 offset 过大。

✅ **优化思路：**

* 使用「**游标分页**」：

```sql
SELECT * FROM orders 
WHERE id > last_id
ORDER BY id 
LIMIT 20;
```

---

### 🧩 题 15：高并发下防止库存超卖

📘 **思路：**

1. SQL 层面：

```sql
UPDATE product SET stock = stock - 1 WHERE id = 1 AND stock > 0;
```

* 受影响行数 = 1 表示成功，0 表示库存不足；
* 无需显式事务锁。

2. 业务层：

    * 可结合 Redis 分布式锁 / MQ 异步削峰。

---

## 七、事务与锁机制（理解类）

### 🧩 题 16：MySQL 死锁的常见原因？

**回答思路：**

* 不同事务访问相同资源但顺序不一致；
* 长事务未及时提交；
* 大量间隙锁（next-key lock）。

✅ **解决：**

* 缩小事务范围；
* 固定访问顺序；
* 事务重试；
* 使用较低隔离级别（如 READ COMMITTED）。

---

### 🧩 题 17：Explain 常见字段

| 字段              | 说明                                                      |
| --------------- | ------------------------------------------------------- |
| `type`          | 连接类型（`ALL`, `index`, `range`, `ref`, `eq_ref`, `const`） |
| `possible_keys` | 可用索引                                                    |
| `key`           | 实际使用的索引                                                 |
| `rows`          | 预计扫描行数                                                  |
| `Extra`         | 额外信息（Using index, Using temporary, Using filesort）      |

面试高频问法：

> “Explain 里出现 Using filesort 是什么意思？怎么优化？”

✅ **答：** 排序未走索引，可通过复合索引 `(a, b)` 或 `order by` 顺序优化。

---

# ✅ 八、总结

| 类型   | 高频考点                | 建议              |
| ---- | ------------------- | --------------- |
| 聚合统计 | group by + having   | 多练业务类场景         |
| TopN | 分组内最大值              | 会写 join + group |
| 窗口函数 | row_number / rank   | 重点              |
| 子查询  | exists / not exists | 多表条件判断          |
| 性能优化 | explain + 索引失效      | 常见面试 killer 题   |
| 事务理解 | 死锁、MVCC、锁等待         | 二面必问            |

