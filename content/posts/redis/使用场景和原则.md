+++
date = '2026-02-05T14:09:54+08:00'
draft = false
title = '使用场景和原则'
+++


## 一、Redis 常见 & 真实可用的使用场景

### 1️⃣ 缓存（Cache）——最核心，但不是“随便加”

**典型用途**

* 热点数据缓存（配置、用户信息、商品信息）
* 接口结果缓存（读多写少）
* 计算结果缓存（排行榜、聚合结果）

**工程要点**

* TTL 一定要有（防雪崩）
* 要有 cache miss 回源策略
* 不要缓存“强一致性要求”的数据

**Go 示例**

```go
user, ok := cache.Get(uid)
if !ok {
    user = db.GetUser(uid)
    cache.Set(uid, user, time.Minute*5)
}
```

---

### 2️⃣ 分布式锁（非常常用）

**典型场景**

* 防止重复下单
* 防止任务并发执行
* 防止重复消费

**推荐方式**

* `SET key value NX PX`
* 不推荐简单 `SETNX + EXPIRE`（非原子）

**工程原则**

* 锁一定要有过期时间
* value 用 UUID，防误删
* 解锁要校验 value

---

### 3️⃣ 计数器 / 限流器

**典型场景**

* 接口 QPS 限流
* 短时间访问次数统计
* 点赞 / 浏览量

**常用结构**

* String（INCR）
* Hash（多维统计）
* Sorted Set（滑动窗口）

**优点**

* 原子性
* 性能极高
* 延迟可控

---

### 4️⃣ Session / 登录态 / Token 存储

**典型场景**

* Web 登录态
* JWT 黑名单
* 临时授权信息

**为什么 Redis 合适**

* 天然 TTL
* 快速校验
* 内存级性能

**不适合**

* 永久凭证
* 强审计数据（要落 DB）

---

### 5️⃣ 消息队列（轻量级）

**方式**

* List（LPUSH + BRPOP）
* Stream（推荐）
* Pub/Sub（不可靠）

**适合**

* 简单异步任务
* 允许丢数据
* 非核心链路

**不适合**

* 强一致
* 高可靠投递
* 金融级场景（Kafka / RocketMQ）

---

### 6️⃣ 排行榜 / TopN

**典型场景**

* 积分榜
* 热度榜
* AI 推荐打分排序

**使用结构**

* Sorted Set（ZSET）

**为什么 Redis 无敌**

* 排序天然支持
* 更新 & 查询都是 O(logN)
* DB 很难优雅实现

---

### 7️⃣ 状态机 / 业务中间态

**典型场景**

* 订单流程状态
* AI 推理任务状态
* 视频处理进度

**特点**

* 状态变化频繁
* 生命周期短
* 不需要永久保存

---

### 8️⃣ 去重 / 幂等控制

**典型场景**

* 防止重复请求
* 防止消息重复消费
* 防止任务重复执行

**方案**

* SET + TTL
* Bloom Filter（Redis Module）

---

### 9️⃣ 实时数据 & 临时数据

**典型场景**

* 在线用户列表
* 房间成员
* 实时协作状态

**结构**

* Set / Hash / ZSet

---

### 🔟 AI 应用里的 Redis 场景（你现在非常 relevant）

#### ✅ Prompt / 上下文缓存

* 用户最近对话
* 系统 prompt
* RAG 检索结果

#### ✅ Embedding 结果缓存

* 避免重复 embedding
* Key = hash(text)

#### ✅ 推理限流 & 排队

* 控制模型并发
* 防止打爆 GPU

---

## 二、哪些场景**不适合** Redis（重要）

很多项目 Redis 用烂了，是因为**不该用的地方硬用**。

❌ 不适合：

* 强一致金融数据
* 永久数据存储
* 大字段（几 MB 文本）
* 复杂关联查询
* 事务密集型系统

一句话：

> **Redis 是“快 + 临时 + 简单结构”，不是数据库替代品**

---

## 三、Redis 适用场景的「判断原则」（重点）

你问的这个问题，本质是**架构判断能力**，给你一套**工程可复用的判断标准**👇

---

## ✅ 只要满足这些原则，就应该考虑 Redis

### 原则 1️⃣：数据是不是 **临时的 / 可丢的**

* 能重建？
* 能从 DB 回源？
* 丢了不会“炸系统”？

👉 是 → Redis 非常适合

---

### 原则 2️⃣：是不是 **读多写少 / 高频访问**

* QPS 高？
* 延迟敏感？

👉 是 → Redis

---

### 原则 3️⃣：是否需要 **TTL / 自动过期**

* 登录态
* 验证码
* 限流窗口

👉 是 → Redis 天然优势

---

### 原则 4️⃣：是否需要 **原子操作**

* 计数
* 限流
* 排序

👉 是 → Redis 比 DB 简单可靠

---

### 原则 5️⃣：数据结构是否 **简单**

* KV / List / Set / ZSet / Hash
* 不需要 join

👉 是 → Redis

---

### 原则 6️⃣：是否属于 **系统“加速层”或“协调层”**

* 锁
* 状态
* 中间态
* 控制并发

👉 是 → Redis 非常合适

---

### 原则 7️⃣：是否允许 **最终一致性**

* 短时间不一致 OK？
* 异步修正 OK？

👉 是 → Redis

---

## 四、一句总结

> **凡是“高频访问 + 临时存在 + 结构简单 + 可丢失 + 对延迟敏感”的数据，都应该第一时间考虑 Redis。**

---

