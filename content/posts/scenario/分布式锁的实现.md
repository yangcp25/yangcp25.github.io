+++
date = '2025-09-11T09:23:32+08:00'
draft = false
title = '分布式锁的实现'
+++
### 分布式锁的实现
分布式锁需要满足几个要点
1. 高性能、互斥，redis高性能，处理模型单线程天然支持互斥
2. 原子性操作（主要是redis），高并发情况下，需要保证加锁、删除、自动续期的并发安全，所以需要原子性保证
3. 安全释放锁、锁的删除，在并发情况下，可能出现A执行任务过长，锁已经自动过期了，B拿到锁在执行了，A执行完毕，释放锁，如果不进行锁的Val判断，会导致锁的异常释放。
4. 自动过期/自动续期
5. 可重入
### 基于redis的实现
`cache.go`
```go
package cache

import (
"context"
"github.com/redis/go-redis/v9"
"time"
)

type Cache interface {

// 通用封装 需要解决
//（1）缓存三大问题 a 穿透 b 击穿 c 缓存雪崩
//（2）缓存不一致的问题
//（3）分布式锁
// 设置通用前缀 app_name , 数据类型 data, 模块名字 ，
SetPrefix(prefix ...string) Cache
Set(ctx context.Context, key, value string, short bool) error
Get(ctx context.Context, key string, handler func(context.Context) (string, error)) (string, error)
// 增加 删除 修改的时候调用
Flush(ctx context.Context, handler func(context.Context) error) error
FlushWithConsistency(ctx context.Context, handler func(context.Context) error) error

// 以下是简单封装
SimpleSet(ctx context.Context, key string, data any, expiration time.Duration) (err error)
SimpleGet(ctx context.Context, key string) (data string, err error)
SimpleIncr(ctx context.Context, key string) (count int64, err error)
SimpleDel(ctx context.Context, keys ...string) (deletedCount int64, err error)
Pipelined(ctx context.Context, callback func(redis.Pipeliner) error) (cmder []redis.Cmder, err error)
// 批量删除 key 比如 app_name:*
DeleteKeysByPattern(ctx context.Context, pattern string) (err error)

// 集合操作
SAdd(ctx context.Context, key string, members ...string) (err error)
SMembers(ctx context.Context, key string) (members []string, err error)

// 过期集合 设置获取
AddMemberWithTTL(ctx context.Context, setKey, member string, ttl time.Duration) error
GetValidMembers(ctx context.Context, setKey string) ([]string, error)
RemoveMember(ctx context.Context, setKey string, members ...string) (int64, error)

// 分布式加解锁
DistributedLock(ctx context.Context, key string, ttl time.Duration) error
DistributedUnlock(ctx context.Context, key string) error
}

```
`redis.go`
```go
package cache

import (
	"codeup.aliyun.com/619b3cb12f595dbd1b9b0b3e/go/common.git/log"
	"context"
	"fmt"
	"github.com/go-kratos/kratos/v2/errors"
	"github.com/redis/go-redis/v9"
	"math/rand"
	"strings"
	"time"
)

type RedisCache struct {
	Redis      redis.UniversalClient
	Prefix     []string
	RootPrefix []string
	Locks      map[string]*Lock // key: 业务锁名, value: Lock实例
}

func (c *RedisCache) DistributedLock(ctx context.Context, key string, ttl time.Duration) error {
	if c.Locks == nil {
		c.Locks = make(map[string]*Lock)
	}
	lockKey := c.getKey(key)
	lock := NewLock(c.Redis, lockKey)
	err := lock.Lock(ctx, ttl)
	if err != nil {
		return err
	}
	c.Locks[lockKey] = lock
	return nil
}

func (c *RedisCache) DistributedUnlock(ctx context.Context, key string) error {
	if c.Locks == nil {
		return fmt.Errorf("no lock map found")
	}
	lockKey := c.getKey(key)
	lock, ok := c.Locks[lockKey]
	if !ok || lock == nil {
		return fmt.Errorf("no lock found for key: %s", lockKey)
	}
	err := lock.UnLock(ctx)
	if err != nil {
		return err
	}
	delete(c.Locks, lockKey)
	return nil
}

func (c *RedisCache) SetPrefix(prefix ...string) Cache {
	return &RedisCache{
		Redis:      c.Redis,
		Prefix:     prefix,
		RootPrefix: c.RootPrefix,
		Locks:      c.Locks,
	}
}

func (c *RedisCache) Set(ctx context.Context, key, value string, short bool) error {
	// 默认五分钟 如果空数据 设置 1 分钟
	// set random expiration avoid a large number of keys expire at the same time
	seconds := rand.New(rand.NewSource(time.Now().UnixNano())).Int63n(300) + 300
	if short { // 防止缓存穿透
		// if record not found, set a short expiration
		seconds = 60 + rand.New(rand.NewSource(time.Now().UnixNano())).Int63n(60)
	}
	return c.Redis.Set(ctx, c.getKey(key), value, time.Duration(seconds)*time.Second).Err()
}

func (c *RedisCache) Get(ctx context.Context, key string, handler func(context.Context) (string, error)) (result string, err error) {
	// 分布式锁解决 缓存击穿
	currentKey := c.getKey(key)
	result, err = c.Redis.Get(ctx, currentKey).Result()
	if err == nil {
		return
	}
	// 加锁 去 数据库 读 数据
	lock := NewLock(c.Redis, currentKey)
	err = c.GetLock(ctx, lock, currentKey)
	if err != nil {
		return "", err
	}
	defer lock.UnLock(ctx)
	// 双重检测
	result, err = c.Redis.Get(ctx, currentKey).Result()
	if err == nil {
		return
	}
	//
	result, err = handler(ctx)
	if err != nil {
		return "", err
	}
	// 数据回填
	if result == "" {
		err = c.Set(ctx, key, result, true)
	} else {
		err = c.Set(ctx, key, result, false)
	}
	if err != nil {
		return "", err
	}
	return
}
func (c *RedisCache) GetLock(ctx context.Context, lock *Lock, key string) (err error) {
	// 自旋 1s
	retry := 0
	for retry < 20 {
		err = lock.Lock(ctx, 5*time.Second)
		if err == nil {
			return
		}
		time.Sleep(50 * time.Millisecond)
		retry++
		if err := ctx.Err(); err != nil {
			return err
		}
	}
	return errors.Errorf(500, "not get lock", "")
}

func (c *RedisCache) Flush(ctx context.Context, handler func(context.Context) error) error {
	err := c.DeleteKeysByPattern(ctx, c.getKey("*"))
	if err != nil {
		return err
	}
	return handler(ctx)
}

func (c *RedisCache) getKey(key string) string {
	temp := append(c.RootPrefix, c.Prefix...)
	if key != "" {
		temp = append(temp, key)
	}
	return strings.Join(temp, ":")
}

// FlushWithConsistency 缓存双删
func (c *RedisCache) FlushWithConsistency(ctx context.Context, handler func(context.Context) error) (err error) {
	err = c.DeleteKeysByPattern(ctx, c.getKey("*"))
	if err != nil {
		return err
	}
	err = handler(ctx)
	if err != nil {
		return err
	}
	go func() {
		ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
		defer cancel()
		time.Sleep(1 * time.Second)
		err = c.DeleteKeysByPattern(ctx, c.getKey("*"))
		if err != nil {
			log.Info(err.Error())
		}
	}()
	return
}

func NewRedisCache(redis redis.UniversalClient, prefix string) Cache {
	return &RedisCache{
		Redis:      redis,
		Prefix:     []string{prefix},
		RootPrefix: []string{prefix},
	}
}

func (c *RedisCache) Pipelined(ctx context.Context, callback func(redis.Pipeliner) error) (cmder []redis.Cmder, err error) {
	return c.Redis.Pipelined(ctx, callback)
}

func (c *RedisCache) DeleteKeysByPattern(ctx context.Context, pattern string) (err error) {

	iter := c.Redis.Scan(ctx, 0, pattern, 0).Iterator()

	// 删除计数器
	deleted := 0

	// 分批删除键以避免一次删除太多键
	var keys []string
	pipe := c.Redis.Pipeline()
	for iter.Next(ctx) {
		keys = append(keys, iter.Val())

		// 每积累100个键执行一次删除操作
		if len(keys) >= 100 {
			for _, k := range keys {
				pipe.Unlink(ctx, k)
			}
			_, err := pipe.Exec(ctx)
			if err != nil {
				return err
			}
			deleted += len(keys)
			keys = []string{}
		}
	}

	// 删除剩余的键
	if len(keys) > 0 {
		for _, k := range keys {
			pipe.Unlink(ctx, k)
		}
		_, err := pipe.Exec(ctx)
		if err != nil {
			return err
		}
		deleted += len(keys)
	}

	// 检查迭代过程中是否有错误
	if err := iter.Err(); err != nil {
		return err
	}
	log.Info("成功删除 %d 个匹配 '%s' 的键\n", deleted, pattern)
	return nil
}

func (c *RedisCache) RemoveMember(ctx context.Context, setKey string, members ...string) (int64, error) {
	// 返回成功删除的成员数量
	return c.Redis.ZRem(ctx, setKey, members).Result()
}

func (c *RedisCache) AddMemberWithTTL(ctx context.Context, setKey, member string, ttl time.Duration) error {
	expireTs := time.Now().Add(ttl).Unix() // 过期时间戳（秒）
	// ZADD myzset expireTs member
	if err := c.Redis.ZAdd(ctx, setKey, redis.Z{
		Score:  float64(expireTs),
		Member: member,
	}).Err(); err != nil {
		return err
	}
	return nil
}

func (c *RedisCache) GetValidMembers(ctx context.Context, setKey string) ([]string, error) {
	now := time.Now().Unix()
	// 只取 score > now 的成员
	members, err := c.Redis.ZRangeByScore(ctx, setKey, &redis.ZRangeBy{
		Min: fmt.Sprintf("(%d", now), // (now 表示严格大于 now
		Max: "+inf",
	}).Result()
	if err != nil {
		return nil, err
	}
	go func() {
		subCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()
		err := c.CleanupExpired(subCtx, setKey)
		if err != nil {
			log.Info(err)
		}
	}()
	return members, nil
}

func (c *RedisCache) CleanupExpired(ctx context.Context, setKey string) error {
	now := time.Now().Unix()
	// 删除所有 score ≤ now 的成员
	_, err := c.Redis.ZRemRangeByScore(ctx, setKey, "-inf", fmt.Sprintf("%d", now)).Result()
	return err
}

func (c *RedisCache) SAdd(ctx context.Context, key string, members ...string) (err error) {
	return c.Redis.SAdd(ctx, key, members).Err()
}

func (c *RedisCache) SMembers(ctx context.Context, key string) (members []string, err error) {
	return c.Redis.SMembers(ctx, key).Result()
}

func (c *RedisCache) SimpleDel(ctx context.Context, keys ...string) (deletedCount int64, err error) {
	// 7. Del: 删除键
	return c.Redis.Del(ctx, keys...).Result()
}

func (c *RedisCache) SimpleIncr(ctx context.Context, key string) (count int64, err error) {
	// 6. Incr: 对数字进行原子递增
	return c.Redis.Incr(ctx, key).Result()
}

func (c *RedisCache) SimpleSet(ctx context.Context, key string, data any, expiration time.Duration) (err error) {
	// 2. Set: 设置键值对 (key: "mykey", value: "hello Redis")，没有过期时间
	return c.Redis.Set(ctx, key, data, expiration).Err()
}

func (c *RedisCache) SimpleGet(ctx context.Context, key string) (data string, err error) {
	// 4. Get: 获取键的值
	data, err = c.Redis.Get(ctx, key).Result()
	if errors.Is(err, redis.Nil) || err != nil {
		return "", err
	} else {
		return data, nil
	}
}

```

`redislock.go`

```go

package cache

import (
	//"codeup.aliyun.com/619b3cb12f595dbd1b9b0b3e/go/common.git/id"
	"codeup.aliyun.com/619b3cb12f595dbd1b9b0b3e/go/common.git/log"
	"context"
	"github.com/google/uuid"
	"github.com/pkg/errors"
	"github.com/redis/go-redis/v9"
	"sync"
	"time"
)

// 实现分布式锁

// 几个 要点
// 互斥 redis 天然支持
// 1.set nx px 设置过期时间 5.0之后可以一条命令设置
// 2.释放锁的时候需要判断，线程卡住，自动过期，其他线程加锁，你再删除九五删除了
// 3.需要 lua 脚本 执行删除操作 因为判断和删除是2个操作 。 判断和删除的过程中，锁过期，刚好其他线程上锁，
//   就会导致误删除。
// 4.可重入（看具体业务）、 自动续期（看门狗）

type Lock struct {
	client redis.UniversalClient
	key    string
	uuID   string
	MaxTtl int
	wg     *sync.WaitGroup
	cancel context.CancelFunc
}

func NewLock(client redis.UniversalClient, key string) *Lock {
	//sf := id.NewSonyflake()
	uuID := uuid.NewString()
	return &Lock{
		client: client,
		uuID:   uuID,
		MaxTtl: 5,
		key:    key + ":lock",
		wg:     &sync.WaitGroup{},
	}
}

func (l *Lock) Lock(ctx context.Context, expire time.Duration) (err error) {
	ok, _ := l.client.SetNX(ctx, l.key, l.uuID, expire).Result()
	if !ok {
		return errors.New("lock failed")
	}
	// 设置最大延期时间
	// 在 Lock 方法中修正 maxTtl 的计算
	maxTtl := time.Duration(l.MaxTtl) * expire
	ctx, cancel := context.WithCancel(ctx)
	l.cancel = cancel
	go l.startWatchdog(ctx, expire, maxTtl)
	return
}

func (l *Lock) startWatchdog(ctx context.Context, expire time.Duration, maxTtl time.Duration) {
	l.wg.Add(1)
	defer l.wg.Done()
	ctx, cancel := context.WithTimeout(ctx, maxTtl)
	defer cancel()
	timer := time.NewTicker(expire / 3)
	defer timer.Stop()
	for {
		select {
		case <-timer.C:
			// 延期
			extensionScript := `
    if redis.call("GET", KEYS[1]) == ARGV[1] then
        return redis.call("PEXPIRE", KEYS[1], ARGV[2])
    else
        return 0
    end
    `
			expireMs := int64(expire.Milliseconds())
			err := l.client.Eval(ctx, extensionScript, []string{l.key}, l.uuID, expireMs).Err()
			if err != nil {
				log.Info(err.Error())
				return
			}
		case <-ctx.Done():
			return
		}
	}
}

func (l *Lock) UnLock(ctx context.Context) (err error) {
	if l.cancel == nil {
		return errors.New("lock not held")
	}

	// 释放watchdog
	l.cancel()
	l.wg.Wait()

	script := `
    if redis.call("GET", KEYS[1]) == ARGV[1] then
        return redis.call("DEL", KEYS[1])
    else
        return 0
    end
    `
	ok, err := l.client.Eval(ctx, script, []string{l.key}, l.uuID).Result()
	if err != nil {
		return err
	}
	if ok.(int64) != 1 {
		return errors.New("unlock failed: lock not held")
	}

	return nil
}

```