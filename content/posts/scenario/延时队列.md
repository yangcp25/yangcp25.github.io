+++
date = '2025-11-10T14:37:09+08:00'
draft = false
title = '延时队列'
+++

使用 **Redis Sorted Set (ZSet)** 实现延时队列（Delay Queue）是一种高效且常用的方法，因为它利用了 ZSet 的核心特性：**元素有序**。

以下是基于 Redis ZSet 设计延时队列的详细步骤、关键操作和代码逻辑。

-----

## 基于 Redis ZSet 的延时队列设计

### 1\. 核心数据结构

| 组件 | Redis 数据结构 | 存储内容 | ZSet Score (分数) | ZSet Member (成员) | 作用 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **延迟队列** | Sorted Set (ZSet) | 待执行任务 | **任务执行时间戳** (毫秒或秒) | **任务的唯一 ID** (例如：`order:123`, `task:456`) | 核心结构，按执行时间排序 |
| **任务详情** | Hash 或 String | 任务的具体内容 | N/A | 任务 ID | 存储任务执行所需的所有数据 |

### 2\. 三个核心操作

一个完整的延时队列系统由三个主要角色构成：**生产者（Producer）**、**消费者/扫描器（Consumer/Scanner）** 和 **任务处理器（Executor）**。

#### 2.1 生产者：投递任务（将任务放入队列）

生产者负责将一个任务及其计划执行时间写入 Redis。

**操作步骤：**

1.  **确定执行时间：** 计算任务应被执行的精确时间戳 `T`。
2.  **存储任务详情：** 将任务的全部信息（如订单号、用户ID等）存储到 Redis 的 Hash 或 String 结构中，以任务 ID 为 Key。
3.  **加入 ZSet：** 将任务的 ID 作为 Member，将时间戳 `T` 作为 Score，存入延迟队列 ZSet 中。

**Redis 命令示例：**

```
# 假设延迟 30 分钟，当前时间为 1678886400 (秒级时间戳)
# 计划执行时间 T = 1678886400 + 1800 = 1678888200

# 1. 存储任务详情（使用 Hash 结构）
HSET task_detail:order:123 "order_id" "123" "user_id" "A" "action" "cancel"

# 2. 加入延迟队列 ZSet
ZADD delay_queue 1678888200 order:123
```

#### 2.2 消费者/扫描器：轮询和提取任务（定时拉取）

消费者/扫描器是一个后台常驻进程，它定时（例如每秒）查询 ZSet 中哪些任务已到期。

**关键在于原子性地取出任务。**

**操作步骤：**

1.  **查询到期任务：** 使用 `ZRANGEBYSCORE` 命令，查询 Score (时间戳) 小于或等于**当前时间戳 `Now`** 的所有任务 ID。因为 ZSet 是有序的，这些就是最早到期的任务。

2.  **原子性移除：** 使用 `ZREM` 命令，从 ZSet 中移除上一步查询到的所有任务 ID。

    * **注意：** 在分布式环境中，为了确保只有一个 Worker 拿到并处理任务，通常需要使用 Lua 脚本将 **查询** 和 **移除** 这两步合并成一个原子操作。

**Redis 命令示例（使用 Lua 脚本实现原子性 Pop）：**

```lua
-- Lua 脚本：
local key = KEYS[1] -- delay_queue 的 Key
local now_timestamp = ARGV[1] -- 当前时间戳

-- 1. 查询所有 Score 小于等于当前时间戳的 Member（最多查询 N 个，这里假设 100 个）
local expired_members = redis.call('ZRANGEBYSCORE', key, '-inf', now_timestamp, 'LIMIT', 0, 100)

if #expired_members > 0 then
    -- 2. 移除这些 Member
    redis.call('ZREM', key, unpack(expired_members))
    return expired_members
else
    return {}
end
```

这个 Lua 脚本保证了任务的**原子性获取**：查询到到期任务后，立即将其移除，避免了多个扫描器进程同时拿到同一个任务。

#### 2.3 任务处理器：执行任务

拿到任务 ID 后，任务处理器执行实际的业务逻辑。

**操作步骤：**

1.  **获取任务详情：** 根据任务 ID，从存储任务详情的 Hash 或 String 中取出任务的全部内容。
2.  **执行业务：** 执行取消订单、发放奖励等业务逻辑。
3.  **清理详情：** 业务逻辑执行成功后，删除任务详情 Key。

**Redis 命令示例：**

```
# 假设拿到任务 ID: order:123

# 1. 获取任务详情
HGETALL task_detail:order:123

# 2. 执行业务逻辑...

# 3. 清理详情
DEL task_detail:order:123
```

-----

### 3\. 分布式环境下的关键设计点

在实际的生产环境中，系统通常是分布式的，需要解决以下问题：

#### A. 扫描器的高可用和去重

* **问题：** 多个服务器都在运行扫描器进程，如何确保只有一个进程在工作，或者如何避免任务被重复处理？
* **解决方案：**
    * **分布式锁（推荐）：** 在多个扫描器进程启动时，竞争一个**分布式锁**（如 Redisson 提供的 Reentrant Lock）。只有获得锁的进程才执行 `ZRANGEBYSCORE` 和 `ZREM` 操作。
    * **原子性消费（Lua 脚本）：** 使用上面提到的 **Lua 脚本**，将“查询”和“移除”原子化。只要脚本执行成功，任务就会立即被移除，其他扫描器就不会再拿到。这是更轻量级和高效的解决方案。

#### B. 任务执行的幂等性

* **问题：** 尽管使用了原子性移除，但由于网络波动，任务执行结果可能未及时反馈，导致任务被再次取出并执行。
* **解决方案：** 任务处理器必须实现**幂等性**。例如，在取消订单时，首先检查订单状态是否已经是“已取消”。如果是，则直接退出，不重复执行取消操作。

#### C. Redis 的持久化和高可用

* **问题：** Redis 宕机或重启会导致内存中的 ZSet 数据丢失。
* **解决方案：**
    * **持久化：** 开启 Redis 的 **AOF (Append-Only File)** 持久化，确保数据在重启后能恢复。
    * **高可用：** 使用 **Redis Sentinel（哨兵）** 或 **Redis Cluster（集群）** 模式，确保即使主节点宕机，备用节点也能迅速接管，保障服务的连续性。
