+++
date = '2025-10-22T22:38:00+08:00'
draft = false
title = 'Go 场景题模版 — 答案版'
+++

---
## 🟢 初级场景题（语言特性与陷阱）

### 1. 切片在函数参数传递时，什么时候会影响外部数据？
**思路：** 切片是三元组（指针、len、cap）。传参时会拷贝这三项，但底层数组仍然共享。只有当 append 导致扩容（新的底层数组分配）或修改通过索引直接写入时，外部可见。
- 直接 `s[i] = x` 会影响外部；
- `s = append(s, x)` 当 cap 不足时会分配新数组，外部不会看到新元素。

**示例代码：**
```go
package main

import "fmt"

func appendMaybe(s []int) []int {
    s = append(s, 100) // 若 cap 不足，这里会分配新底层数组
    return s
}

func modify(s []int) {
    if len(s) > 0 {
        s[0] = 999 // 修改共享底层数组
    }
}

func main() {
    a := make([]int, 1, 1)
    a[0] = 1
    b := appendMaybe(a)
    fmt.Println("a:", a) // 如果扩容发生，a 不包含 100
    fmt.Println("b:", b)

    c := make([]int, 1, 2)
    c[0] = 1
    d := appendMaybe(c)
    fmt.Println("c:", c) // cap 足够，c 会看到 append 的结果 (如果 append reuses)
    fmt.Println("d:", d)

    modify(a)
    fmt.Println("a after modify:", a) // 被修改
}
```

---
### 2. `for range` vs `for i := 0; i < len(slice); i++`
**思路：** `for range` 会在每次迭代时把元素拷贝到新的变量（v），因此直接修改 v 不会影响切片。索引访问 `slice[i]` 直接访问底层数组可以修改原值。性能上两者差异很小，除非元素为大结构体，range 会拷贝整个结构体。

**示例：**
```go
package main

import "fmt"

type Big struct{ X [100]int }

func main() {
    s := []Big{{}, {}}

    for i, v := range s {
        v.X[0] = 1 // 修改的是 v 的拷贝，不会影响 s[i]
        fmt.Println("range modified v:", i, v.X[0])
    }

    for i := range s {
        s[i].X[0] = 2 // 直接修改底层数组
        fmt.Println("index modified:", i, s[i].X[0])
    }
    fmt.Println("final:", s[0].X[0], s[1].X[0])
}
```

---
### 3. map 初始化的正确写法
**思路：** 未初始化的 `var m map[K]V` 为 nil，写入会 panic。正确方式：`m := make(map[string]int)` 或 `m := map[string]int{}`。在并发场景使用 `sync.Mutex` 或 `sync.Map`。

**示例：**
```go
package main

import "fmt"

func main() {
    var a map[string]int
    // a["x"] = 1 // panic: assignment to entry in nil map

    b := make(map[string]int)
    b["x"] = 1
    fmt.Println(b)

    c := map[string]int{"y":2}
    fmt.Println(c)
}
```

---
### 4. defer 的执行顺序与 return
**思路：** defer 按 LIFO（后进先出）顺序执行。函数返回时会先计算返回值（若有命名返回值则是赋值过程），然后执行 defer，最后真正返回。若 defer 修改了命名返回值，则返回值会变。

**示例：**
```go
package main

import "fmt"

func f() (r int) {
    defer func() {
        r += 1 // 修改命名返回值
    }()
    return 1 // 会先将 r=1，然后执行 defer，使得 r=2，最终返回 2
}

func main() {
    fmt.Println(f()) // 输出 2
}
```

---
### 5. append 扩容与避免复制
**思路：** 当 slice 的 len < cap 时 append 不会分配新数组；若需要避免复制可以提前 `make` 出合适的 cap 或使用 `append(make([]T,0,needed), ...)`。

**示例：**
```go
package main

import "fmt"

func main() {
    s := make([]int, 0, 5)
    for i := 0; i < 5; i++ {
        s = append(s, i)
    }
    fmt.Println(cap(s), s)
}
```

---
### 6. string 与 []byte 转换优化
**思路：** 频繁转换会产生内存拷贝。可以使用 `strings.Builder` / `bytes.Buffer` 来构建字符串，或用 `unsafe` 做零拷贝转换（有风险，不推荐在面试时随意使用，需注明安全性问题）。

**示例：**
```go
package main

import (
    "bytes"
    "fmt"
)

func main() {
    var b bytes.Buffer
    for i := 0; i < 1000; i++ {
        b.WriteString("x")
    }
    s := b.String()
    fmt.Println(len(s))
}
```

---
### 7. 实现一个线程安全的简单 map
**思路：** 使用 `sync.RWMutex` 提供并发安全的 Get/Set/Delete。

**示例：**
```go
package main

import (
    "fmt"
    "sync"
)

type SafeMap struct {
    mu sync.RWMutex
    m  map[string]interface{}
}

func NewSafeMap() *SafeMap {
    return &SafeMap{m: make(map[string]interface{})}
}

func (s *SafeMap) Set(k string, v interface{}) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.m[k] = v
}

func (s *SafeMap) Get(k string) (interface{}, bool) {
    s.mu.RLock()
    defer s.mu.RUnlock()
    v, ok := s.m[k]
    return v, ok
}

func (s *SafeMap) Delete(k string) {
    s.mu.Lock()
    defer s.mu.Unlock()
    delete(s.m, k)
}

func main() {
    sm := NewSafeMap()
    sm.Set("a", 1)
    v, ok := sm.Get("a")
    fmt.Println(v, ok)
    sm.Delete("a")
}
```

---
## 🟡 中级场景题（并发与控制）

### 1. WaitGroup 控制并发任务
**思路：** 使用 `sync.WaitGroup` 的 Add/Done/Wait。注意：Add 应在启动 goroutine 之前或在主 goroutine 中，避免竞态。Done 次数必须与 Add 对应。

**示例：**
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()
    time.Sleep(100 * time.Millisecond)
    fmt.Println("worker", id, "done")
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go worker(i, &wg)
    }
    wg.Wait()
    fmt.Println("all done")
}
```

---
### 2. 固定大小的 goroutine 池（worker pool）
**思路：** 使用任务 channel 和固定数量的 worker goroutine，提供 Submit 接口并可关闭池。

**示例：**
```go
package main

import (
    "fmt"
    "sync"
)

type Task func()

type Pool struct {
    tasks chan Task
    wg    sync.WaitGroup
}

func NewPool(workerCount, queueSize int) *Pool {
    p := &Pool{tasks: make(chan Task, queueSize)}
    p.wg.Add(workerCount)
    for i := 0; i < workerCount; i++ {
        go func() {
            defer p.wg.Done()
            for t := range p.tasks {
                t()
            }
        }()
    }
    return p
}

func (p *Pool) Submit(t Task) {
    p.tasks <- t
}

func (p *Pool) Shutdown() {
    close(p.tasks)
    p.wg.Wait()
}

func main() {
    p := NewPool(3, 10)
    for i := 0; i < 10; i++ {
        n := i
        p.Submit(func() { fmt.Println("task", n) })
    }
    p.Shutdown()
    fmt.Println("pool shutdown")
}
```

---
### 3. 生产者-消费者模型（优雅退出）
**思路：** 使用带缓冲 channel，生产者在关闭时关闭 channel，消费者 range channel 直到结束。或者使用 context 控制多生产者多消费者的退出。

**示例：**
```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

func producer(ctx context.Context, ch chan<- int, id int) {
    defer fmt.Println("producer", id, "exit")
    for i := 0; i < 5; i++ {
        select {
        case <-ctx.Done():
            return
        case ch <- i:
            time.Sleep(10 * time.Millisecond)
        }
    }
}

func consumer(ctx context.Context, ch <-chan int, id int, wg *sync.WaitGroup) {
    defer wg.Done()
    for {
        select {
        case <-ctx.Done():
            return
        case v, ok := <-ch:
            if !ok {
                return
            }
            fmt.Println("consumer", id, "got", v)
        }
    }
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    ch := make(chan int, 10)
    var wg sync.WaitGroup

    // start consumers
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go consumer(ctx, ch, i, &wg)
    }

    // producers
    for i := 0; i < 2; i++ {
        go producer(ctx, ch, i)
    }

    time.Sleep(100 * time.Millisecond)
    cancel() // graceful shutdown
    close(ch)
    wg.Wait()
    fmt.Println("all done")
}
```

---
### 4. 两个 goroutine 交替打印 1~100
**思路：** 使用两个无缓冲 channel 交替通知，或使用 sync.Cond。下面示例使用 channel。

**示例：**
```go
package main

import "fmt"

func main() {
    ch1 := make(chan struct{})
    ch2 := make(chan struct{})

    go func() {
        for i := 1; i <= 100; i += 2 {
            <-ch1
            fmt.Println(i)
            ch2 <- struct{}{}
        }
    }()

    go func() {
        for i := 2; i <= 100; i += 2 {
            <-ch2
            fmt.Println(i)
            ch1 <- struct{}{}
        }
    }()

    // start
    ch1 <- struct{}{}
    // wait finishing by receiving last signal
    <-ch2
}
```

---
### 5. 限制并发数量（比如最多 10 个任务）
**思路：** 使用带缓冲的信号量 channel 或者 sync.WaitGroup + 有限 worker pool。

**示例（信号量）：**
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    sem := make(chan struct{}, 10) // 最大 10 并发
    var wg sync.WaitGroup
    for i := 0; i < 50; i++ {
        wg.Add(1)
        sem <- struct{}{}
        go func(n int) {
            defer wg.Done()
            defer func() { <-sem }()
            time.Sleep(50 * time.Millisecond)
            fmt.Println("task", n)
        }(i)
    }
    wg.Wait()
    fmt.Println("all tasks done")
}
```

---
### 6. context 控制任务超时与取消
**思路：** 使用 `context.WithTimeout` 或 `WithCancel`，在 goroutine 内选择 `ctx.Done()`。

**示例：**
```go
package main

import (
    "context"
    "fmt"
    "time"
)

func do(ctx context.Context) {
    select {
    case <-time.After(2 * time.Second):
        fmt.Println("work done")
    case <-ctx.Done():
        fmt.Println("cancelled:", ctx.Err())
    }
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
    defer cancel()
    do(ctx)
}
```

---
## 🔴 高级场景题（系统设计与性能）

### 1. 本地缓存系统（TTL + 并发安全 + 清理）
**思路：** map 存储 key -> {value, expireAt}，使用 RWMutex 保护。启动后台 goroutine 周期性清理过期项。提供 Get/Set/Delete 接口。

**示例：**
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type item struct {
    value    interface{}
    expireAt int64
}

type Cache struct {
    mu    sync.RWMutex
    m     map[string]*item
    stop  chan struct{}
    wg    sync.WaitGroup
}

func NewCache() *Cache {
    c := &Cache{m: make(map[string]*item), stop: make(chan struct{})}
    c.wg.Add(1)
    go c.periodicClean(1 * time.Second)
    return c
}

func (c *Cache) Set(k string, v interface{}, ttl time.Duration) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.m[k] = &item{value: v, expireAt: time.Now().Add(ttl).UnixNano()}
}

func (c *Cache) Get(k string) (interface{}, bool) {
    c.mu.RLock()
    it, ok := c.m[k]
    c.mu.RUnlock()
    if !ok {
        return nil, false
    }
    if time.Now().UnixNano() > it.expireAt {
        c.mu.Lock()
        delete(c.m, k)
        c.mu.Unlock()
        return nil, false
    }
    return it.value, true
}

func (c *Cache) periodicClean(interval time.Duration) {
    defer c.wg.Done()
    ticker := time.NewTicker(interval)
    defer ticker.Stop()
    for {
        select {
        case <-ticker.C:
            now := time.Now().UnixNano()
            c.mu.Lock()
            for k, v := range c.m {
                if now > v.expireAt {
                    delete(c.m, k)
                }
            }
            c.mu.Unlock()
        case <-c.stop:
            return
        }
    }
}

func (c *Cache) Close() {
    close(c.stop)
    c.wg.Wait()
}
func main() {
    c := NewCache()
    c.Set("a", 1, 2*time.Second)
    v, ok := c.Get("a")
    fmt.Println(v, ok)
    time.Sleep(3 * time.Second)
    v, ok = c.Get("a")
    fmt.Println(v, ok)
    c.Close()
}
```

---
### 2. LRU 缓存（map + 双向链表，线程安全）
**思路：** 用 map 保存 key->node，双向链表维护访问顺序。Get 将节点移到头部；Set 插入并在超容量时移除尾部。加锁保证并发安全。

**示例：**
```go
package main

import "container/list"
import "sync"

type LRUCache struct {
    mu       sync.Mutex
    capacity int
    ll       *list.List
    cache    map[string]*list.Element
}

type entry struct {
    key   string
    value interface{}
}

func NewLRU(cap int) *LRUCache {
    return &LRUCache{
        capacity: cap,
        ll:       list.New(),
        cache:    make(map[string]*list.Element),
    }
}

func (l *LRUCache) Get(k string) (interface{}, bool) {
    l.mu.Lock()
    defer l.mu.Unlock()
    if ele, ok := l.cache[k]; ok {
        l.ll.MoveToFront(ele)
        return ele.Value.(*entry).value, true
    }
    return nil, false
}

func (l *LRUCache) Set(k string, v interface{}) {
    l.mu.Lock()
    defer l.mu.Unlock()
    if ele, ok := l.cache[k]; ok {
        l.ll.MoveToFront(ele)
        ele.Value.(*entry).value = v
        return
    }
    ele := l.ll.PushFront(&entry{key: k, value: v})
    l.cache[k] = ele
    if l.ll.Len() > l.capacity {
        last := l.ll.Back()
        if last != nil {
            l.ll.Remove(last)
            delete(l.cache, last.Value.(*entry).key)
        }
    }
}
```

---
### 3. 简易消息队列（发布/订阅）
**思路：** 使用 channel + map[channel] 为每个订阅者提供接收通道。持久化需要额外将消息写入磁盘/数据库并做确认机制。

**示例：**
```go
package main

import (
    "fmt"
    "sync"
)

type Broker struct {
    mu    sync.RWMutex
    subs  map[string][]chan string
}

func NewBroker() *Broker {
    return &Broker{subs: make(map[string][]chan string)}
}

func (b *Broker) Subscribe(topic string) chan string {
    ch := make(chan string, 10)
    b.mu.Lock()
    b.subs[topic] = append(b.subs[topic], ch)
    b.mu.Unlock()
    return ch
}

func (b *Broker) Publish(topic, msg string) {
    b.mu.RLock()
    subs := b.subs[topic]
    b.mu.RUnlock()
    for _, ch := range subs {
        select {
        case ch <- msg:
        default:
            // drop or buffer full handling
        }
    }
}

func (b *Broker) Unsubscribe(topic string, ch chan string) {
    b.mu.Lock()
    defer b.mu.Unlock()
    subs := b.subs[topic]
    for i, c := range subs {
        if c == ch {
            b.subs[topic] = append(subs[:i], subs[i+1:]...)
            close(c)
            break
        }
    }
}

func main() {
    b := NewBroker()
    ch := b.Subscribe("t1")
    go func() {
        for m := range ch {
            fmt.Println("recv", m)
        }
    }()

    b.Publish("t1", "hello")
    b.Unsubscribe("t1", ch)
}
```

---
### 4. 秒杀系统防超卖（关键思路）
**思路：** 在高并发下避免超卖：使用 Redis 做库存预减（Lua 脚本保证原子性），引入本地内存售罄标记 + 消息队列异步下单，打散写库压力。

**关键 Lua 伪码：**
```text
-- KEYS[1] stock key
-- ARGV[1] amount
local stock = tonumber(redis.call('get', KEYS[1]) or '0')
if stock <= 0 then return 0 end
if stock < tonumber(ARGV[1]) then return 0 end
redis.call('decrby', KEYS[1], ARGV[1])
return 1
```

**Go 示例调用（简化）：**
```go
// 省略 redis 客户端初始化，示例伪码
script := `...` // 上面的 lua
res, err := redisClient.Eval(ctx, script, []string{"stock:1"}, 1).Result()
if err != nil { /* handle */ }
if res.(int64) == 1 {
    // push order info to MQ for async processing
}
```

---
### 5. 限流组件（令牌桶）
**思路：** 用 goroutine 持续按速率向 channel 放 token，业务处理前尝试取 token，取不到则拒绝或等待。

**示例：**
```go
package main

import (
    "fmt"
    "time"
)

type TokenBucket struct {
    tokens chan struct{}
}

func NewTokenBucket(rate int, capacity int) *TokenBucket {
    tb := &TokenBucket{tokens: make(chan struct{}, capacity)}
    ticker := time.NewTicker(time.Second / time.Duration(rate))
    go func() {
        for range ticker.C {
            select {
            case tb.tokens <- struct{}{}:
            default:
            }
        }
    }()
    return tb
}

func (tb *TokenBucket) Allow() bool {
    select {
    case <-tb.tokens:
        return true
    default:
        return false
    }
}

func main() {
    tb := NewTokenBucket(5, 10) // 每秒 5 个，桶容量 10
    for i := 0; i < 20; i++ {
        if tb.Allow() {
            fmt.Println("allowed", i)
        } else {
            fmt.Println("rejected", i)
        }
        time.Sleep(100 * time.Millisecond)
    }
}
```

---
## ⚙️ 实战 Debug 场景题（排障与优化）

### 1. goroutine 泄漏排查
**思路：** 使用 `pprof` 获取 goroutine 堆栈，定位阻塞点（例如 channel 阻塞、select 没有 default 等）。检查所有 goroutine 启动位置并确保有退出路径或 context 控制。

**pprof 示例：**
```go
// 在程序 main 中引入 net/http/pprof
import _ "net/http/pprof"
import "net/http"

go func() {
    http.ListenAndServe("localhost:6060", nil)
}()
// 然后在终端使用: go tool pprof http://localhost:6060/debug/pprof/goroutine
```

---
### 2. 死锁定位与修复
**示例死锁代码：**
```go
package main

import "sync"

func main() {
    var mu sync.Mutex
    mu.Lock()
    // do something
    mu.Lock() // deadlock: same goroutine locks twice
}
```

**修复：** 不要在同一 goroutine 重复加普通 Mutex，或改用 `sync.RWMutex`/设计避免重入场景，或使用可重入锁（需要自行实现）。

---
### 3. 内存暴涨分析与优化
**思路：** 用 pprof 的 heap 分析哪个对象占用内存最多；检查切片/缓存是否无限制增长，检查 goroutine 堆栈是否过多导致占用。优化：限制缓存大小、复用对象（sync.Pool）、避免大对象拷贝。

---
### 4. 锁竞争诊断与优化
**思路：** 用 `pprof` 的 mutex profile 或 runtime/trace 找到热点锁，分析是短临界区还是长临界区，考虑分段锁、减少锁持有时间、使用读写锁或 lock-free 结构。

---
### 5. pprof 找到热点后改进示例
**示例：** 假设热点在字符串拼接，优化前用 `+` 频繁拼接，优化后使用 `strings.Builder`：
```go
// before: using + inside loop -> lots of allocations
// after:
import "strings"
var b strings.Builder
for _, s := range parts {
    b.WriteString(s)
}
res := b.String()
```

---
