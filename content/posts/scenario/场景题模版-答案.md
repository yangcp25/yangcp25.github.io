+++
date = '2025-10-22T22:38:00+08:00'
draft = false
title = 'Go åœºæ™¯é¢˜æ¨¡ç‰ˆ â€” ç­”æ¡ˆç‰ˆ'
+++

---
## ğŸŸ¢ åˆçº§åœºæ™¯é¢˜ï¼ˆè¯­è¨€ç‰¹æ€§ä¸é™·é˜±ï¼‰

### 1. åˆ‡ç‰‡åœ¨å‡½æ•°å‚æ•°ä¼ é€’æ—¶ï¼Œä»€ä¹ˆæ—¶å€™ä¼šå½±å“å¤–éƒ¨æ•°æ®ï¼Ÿ
**æ€è·¯ï¼š** åˆ‡ç‰‡æ˜¯ä¸‰å…ƒç»„ï¼ˆæŒ‡é’ˆã€lenã€capï¼‰ã€‚ä¼ å‚æ—¶ä¼šæ‹·è´è¿™ä¸‰é¡¹ï¼Œä½†åº•å±‚æ•°ç»„ä»ç„¶å…±äº«ã€‚åªæœ‰å½“ append å¯¼è‡´æ‰©å®¹ï¼ˆæ–°çš„åº•å±‚æ•°ç»„åˆ†é…ï¼‰æˆ–ä¿®æ”¹é€šè¿‡ç´¢å¼•ç›´æ¥å†™å…¥æ—¶ï¼Œå¤–éƒ¨å¯è§ã€‚
- ç›´æ¥ `s[i] = x` ä¼šå½±å“å¤–éƒ¨ï¼›
- `s = append(s, x)` å½“ cap ä¸è¶³æ—¶ä¼šåˆ†é…æ–°æ•°ç»„ï¼Œå¤–éƒ¨ä¸ä¼šçœ‹åˆ°æ–°å…ƒç´ ã€‚

**ç¤ºä¾‹ä»£ç ï¼š**
```go
package main

import "fmt"

func appendMaybe(s []int) []int {
    s = append(s, 100) // è‹¥ cap ä¸è¶³ï¼Œè¿™é‡Œä¼šåˆ†é…æ–°åº•å±‚æ•°ç»„
    return s
}

func modify(s []int) {
    if len(s) > 0 {
        s[0] = 999 // ä¿®æ”¹å…±äº«åº•å±‚æ•°ç»„
    }
}

func main() {
    a := make([]int, 1, 1)
    a[0] = 1
    b := appendMaybe(a)
    fmt.Println("a:", a) // å¦‚æœæ‰©å®¹å‘ç”Ÿï¼Œa ä¸åŒ…å« 100
    fmt.Println("b:", b)

    c := make([]int, 1, 2)
    c[0] = 1
    d := appendMaybe(c)
    fmt.Println("c:", c) // cap è¶³å¤Ÿï¼Œc ä¼šçœ‹åˆ° append çš„ç»“æœ (å¦‚æœ append reuses)
    fmt.Println("d:", d)

    modify(a)
    fmt.Println("a after modify:", a) // è¢«ä¿®æ”¹
}
```

---
### 2. `for range` vs `for i := 0; i < len(slice); i++`
**æ€è·¯ï¼š** `for range` ä¼šåœ¨æ¯æ¬¡è¿­ä»£æ—¶æŠŠå…ƒç´ æ‹·è´åˆ°æ–°çš„å˜é‡ï¼ˆvï¼‰ï¼Œå› æ­¤ç›´æ¥ä¿®æ”¹ v ä¸ä¼šå½±å“åˆ‡ç‰‡ã€‚ç´¢å¼•è®¿é—® `slice[i]` ç›´æ¥è®¿é—®åº•å±‚æ•°ç»„å¯ä»¥ä¿®æ”¹åŸå€¼ã€‚æ€§èƒ½ä¸Šä¸¤è€…å·®å¼‚å¾ˆå°ï¼Œé™¤éå…ƒç´ ä¸ºå¤§ç»“æ„ä½“ï¼Œrange ä¼šæ‹·è´æ•´ä¸ªç»“æ„ä½“ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import "fmt"

type Big struct{ X [100]int }

func main() {
    s := []Big{{}, {}}

    for i, v := range s {
        v.X[0] = 1 // ä¿®æ”¹çš„æ˜¯ v çš„æ‹·è´ï¼Œä¸ä¼šå½±å“ s[i]
        fmt.Println("range modified v:", i, v.X[0])
    }

    for i := range s {
        s[i].X[0] = 2 // ç›´æ¥ä¿®æ”¹åº•å±‚æ•°ç»„
        fmt.Println("index modified:", i, s[i].X[0])
    }
    fmt.Println("final:", s[0].X[0], s[1].X[0])
}
```

---
### 3. map åˆå§‹åŒ–çš„æ­£ç¡®å†™æ³•
**æ€è·¯ï¼š** æœªåˆå§‹åŒ–çš„ `var m map[K]V` ä¸º nilï¼Œå†™å…¥ä¼š panicã€‚æ­£ç¡®æ–¹å¼ï¼š`m := make(map[string]int)` æˆ– `m := map[string]int{}`ã€‚åœ¨å¹¶å‘åœºæ™¯ä½¿ç”¨ `sync.Mutex` æˆ– `sync.Map`ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import "fmt"

func main() {
    var a map[string]int
    // a["x"] = 1 // panic: assignment to entry in nil map

    b := make(map[string]int)
    b["x"] = 1
    fmt.Println(b)

    c := map[string]int{"y":2}
    fmt.Println(c)
}
```

---
### 4. defer çš„æ‰§è¡Œé¡ºåºä¸ return
**æ€è·¯ï¼š** defer æŒ‰ LIFOï¼ˆåè¿›å…ˆå‡ºï¼‰é¡ºåºæ‰§è¡Œã€‚å‡½æ•°è¿”å›æ—¶ä¼šå…ˆè®¡ç®—è¿”å›å€¼ï¼ˆè‹¥æœ‰å‘½åè¿”å›å€¼åˆ™æ˜¯èµ‹å€¼è¿‡ç¨‹ï¼‰ï¼Œç„¶åæ‰§è¡Œ deferï¼Œæœ€åçœŸæ­£è¿”å›ã€‚è‹¥ defer ä¿®æ”¹äº†å‘½åè¿”å›å€¼ï¼Œåˆ™è¿”å›å€¼ä¼šå˜ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import "fmt"

func f() (r int) {
    defer func() {
        r += 1 // ä¿®æ”¹å‘½åè¿”å›å€¼
    }()
    return 1 // ä¼šå…ˆå°† r=1ï¼Œç„¶åæ‰§è¡Œ deferï¼Œä½¿å¾— r=2ï¼Œæœ€ç»ˆè¿”å› 2
}

func main() {
    fmt.Println(f()) // è¾“å‡º 2
}
```

---
### 5. append æ‰©å®¹ä¸é¿å…å¤åˆ¶
**æ€è·¯ï¼š** å½“ slice çš„ len < cap æ—¶ append ä¸ä¼šåˆ†é…æ–°æ•°ç»„ï¼›è‹¥éœ€è¦é¿å…å¤åˆ¶å¯ä»¥æå‰ `make` å‡ºåˆé€‚çš„ cap æˆ–ä½¿ç”¨ `append(make([]T,0,needed), ...)`ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import "fmt"

func main() {
    s := make([]int, 0, 5)
    for i := 0; i < 5; i++ {
        s = append(s, i)
    }
    fmt.Println(cap(s), s)
}
```

---
### 6. string ä¸ []byte è½¬æ¢ä¼˜åŒ–
**æ€è·¯ï¼š** é¢‘ç¹è½¬æ¢ä¼šäº§ç”Ÿå†…å­˜æ‹·è´ã€‚å¯ä»¥ä½¿ç”¨ `strings.Builder` / `bytes.Buffer` æ¥æ„å»ºå­—ç¬¦ä¸²ï¼Œæˆ–ç”¨ `unsafe` åšé›¶æ‹·è´è½¬æ¢ï¼ˆæœ‰é£é™©ï¼Œä¸æ¨èåœ¨é¢è¯•æ—¶éšæ„ä½¿ç”¨ï¼Œéœ€æ³¨æ˜å®‰å…¨æ€§é—®é¢˜ï¼‰ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import (
    "bytes"
    "fmt"
)

func main() {
    var b bytes.Buffer
    for i := 0; i < 1000; i++ {
        b.WriteString("x")
    }
    s := b.String()
    fmt.Println(len(s))
}
```

---
### 7. å®ç°ä¸€ä¸ªçº¿ç¨‹å®‰å…¨çš„ç®€å• map
**æ€è·¯ï¼š** ä½¿ç”¨ `sync.RWMutex` æä¾›å¹¶å‘å®‰å…¨çš„ Get/Set/Deleteã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import (
    "fmt"
    "sync"
)

type SafeMap struct {
    mu sync.RWMutex
    m  map[string]interface{}
}

func NewSafeMap() *SafeMap {
    return &SafeMap{m: make(map[string]interface{})}
}

func (s *SafeMap) Set(k string, v interface{}) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.m[k] = v
}

func (s *SafeMap) Get(k string) (interface{}, bool) {
    s.mu.RLock()
    defer s.mu.RUnlock()
    v, ok := s.m[k]
    return v, ok
}

func (s *SafeMap) Delete(k string) {
    s.mu.Lock()
    defer s.mu.Unlock()
    delete(s.m, k)
}

func main() {
    sm := NewSafeMap()
    sm.Set("a", 1)
    v, ok := sm.Get("a")
    fmt.Println(v, ok)
    sm.Delete("a")
}
```

---
## ğŸŸ¡ ä¸­çº§åœºæ™¯é¢˜ï¼ˆå¹¶å‘ä¸æ§åˆ¶ï¼‰

### 1. WaitGroup æ§åˆ¶å¹¶å‘ä»»åŠ¡
**æ€è·¯ï¼š** ä½¿ç”¨ `sync.WaitGroup` çš„ Add/Done/Waitã€‚æ³¨æ„ï¼šAdd åº”åœ¨å¯åŠ¨ goroutine ä¹‹å‰æˆ–åœ¨ä¸» goroutine ä¸­ï¼Œé¿å…ç«æ€ã€‚Done æ¬¡æ•°å¿…é¡»ä¸ Add å¯¹åº”ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()
    time.Sleep(100 * time.Millisecond)
    fmt.Println("worker", id, "done")
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go worker(i, &wg)
    }
    wg.Wait()
    fmt.Println("all done")
}
```

---
### 2. å›ºå®šå¤§å°çš„ goroutine æ± ï¼ˆworker poolï¼‰
**æ€è·¯ï¼š** ä½¿ç”¨ä»»åŠ¡ channel å’Œå›ºå®šæ•°é‡çš„ worker goroutineï¼Œæä¾› Submit æ¥å£å¹¶å¯å…³é—­æ± ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import (
    "fmt"
    "sync"
)

type Task func()

type Pool struct {
    tasks chan Task
    wg    sync.WaitGroup
}

func NewPool(workerCount, queueSize int) *Pool {
    p := &Pool{tasks: make(chan Task, queueSize)}
    p.wg.Add(workerCount)
    for i := 0; i < workerCount; i++ {
        go func() {
            defer p.wg.Done()
            for t := range p.tasks {
                t()
            }
        }()
    }
    return p
}

func (p *Pool) Submit(t Task) {
    p.tasks <- t
}

func (p *Pool) Shutdown() {
    close(p.tasks)
    p.wg.Wait()
}

func main() {
    p := NewPool(3, 10)
    for i := 0; i < 10; i++ {
        n := i
        p.Submit(func() { fmt.Println("task", n) })
    }
    p.Shutdown()
    fmt.Println("pool shutdown")
}
```

---
### 3. ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹ï¼ˆä¼˜é›…é€€å‡ºï¼‰
**æ€è·¯ï¼š** ä½¿ç”¨å¸¦ç¼“å†² channelï¼Œç”Ÿäº§è€…åœ¨å…³é—­æ—¶å…³é—­ channelï¼Œæ¶ˆè´¹è€… range channel ç›´åˆ°ç»“æŸã€‚æˆ–è€…ä½¿ç”¨ context æ§åˆ¶å¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…çš„é€€å‡ºã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

func producer(ctx context.Context, ch chan<- int, id int) {
    defer fmt.Println("producer", id, "exit")
    for i := 0; i < 5; i++ {
        select {
        case <-ctx.Done():
            return
        case ch <- i:
            time.Sleep(10 * time.Millisecond)
        }
    }
}

func consumer(ctx context.Context, ch <-chan int, id int, wg *sync.WaitGroup) {
    defer wg.Done()
    for {
        select {
        case <-ctx.Done():
            return
        case v, ok := <-ch:
            if !ok {
                return
            }
            fmt.Println("consumer", id, "got", v)
        }
    }
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    ch := make(chan int, 10)
    var wg sync.WaitGroup

    // start consumers
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go consumer(ctx, ch, i, &wg)
    }

    // producers
    for i := 0; i < 2; i++ {
        go producer(ctx, ch, i)
    }

    time.Sleep(100 * time.Millisecond)
    cancel() // graceful shutdown
    close(ch)
    wg.Wait()
    fmt.Println("all done")
}
```

```go
//å®Œæ•´ç‰ˆæœ¬

package main

import (
	"context"
	"errors"
	"fmt"
	"log"
	"math/rand"
	"os"
	"os/signal"
	"sync"
	"sync/atomic"
	"syscall"
	"time"
)

// TaskFunc æ˜¯è¦æ‰§è¡Œçš„ä»»åŠ¡å‡½æ•°
type TaskFunc func(ctx context.Context) error

var (
	ErrQueueFull = errors.New("task queue is full")
	ErrStopped   = errors.New("manager stopped; not accepting tasks")
)

// Manager ç®¡ç†ç”Ÿäº§è€…/æ¶ˆè´¹è€…
type Manager struct {
	queue     chan *taskWrapper
	workers   int
	maxRetries int
	retryBase  time.Duration // åŸºç¡€é‡è¯•å»¶è¿Ÿï¼ˆä¼šæŒ‡æ•°å¢é•¿ï¼‰
	ratePerSec int           // 0 è¡¨ç¤ºä¸åšé€Ÿç‡é™åˆ¶

	// å†…éƒ¨æ§åˆ¶
	closed uint32 // atomic flag: 1 è¡¨ç¤ºå·²å…³é—­ï¼ˆä¸å†æ¥å—ä»»åŠ¡ï¼‰
	wg     sync.WaitGroup

	// context ç”¨äºå–æ¶ˆæ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡ï¼ˆå½“éœ€è¦ç«‹å³åœæ­¢ï¼‰
	ctx    context.Context
	cancel context.CancelFunc

	// rate limiting token channelï¼ˆå½“ ratePerSec>0 æ—¶ä½¿ç”¨ï¼‰
	tokens chan struct{}

	// ç»Ÿè®¡
	enqueued uint64
	queuedFail uint64
	processed uint64
	failed    uint64
	retried   uint64

	// å¯é€‰çš„é”™è¯¯å›è°ƒ
	OnError func(taskID string, err error)
}

// taskWrapper åŒ…è£…ä»»åŠ¡ï¼Œä¾¿äºé™„å¸¦ id/info
type taskWrapper struct {
	id string
	fn TaskFunc
}

// NewManager åˆ›å»º Manager
// queueSize: é˜Ÿåˆ—ç¼“å†²é•¿åº¦
// workers: æ¶ˆè´¹è€…æ•°é‡
// maxRetries: æ¯ä¸ªä»»åŠ¡é‡è¯•æ¬¡æ•°ï¼ˆ0 è¡¨ç¤ºä¸é‡è¯•ï¼‰
// retryBase: åŸºç¡€é‡è¯•é—´éš”ï¼Œä¾‹å¦‚ 200*time.Millisecond
// ratePerSec: æ¯ç§’æœ€å¤§å¤„ç†æ•°ï¼ˆ0 è¡¨ç¤ºä¸é™åˆ¶ï¼‰
func NewManager(queueSize, workers, maxRetries int, retryBase time.Duration, ratePerSec int) *Manager {
	ctx, cancel := context.WithCancel(context.Background())
	m := &Manager{
		queue:      make(chan *taskWrapper, queueSize),
		workers:    workers,
		maxRetries: maxRetries,
		retryBase:  retryBase,
		ratePerSec: ratePerSec,
		ctx:        ctx,
		cancel:     cancel,
	}
	if ratePerSec > 0 {
		m.tokens = make(chan struct{}, ratePerSec) // å®¹é‡ä¸ºæ¯ç§’ä»¤ç‰Œä¸Šé™
		interval := time.Second / time.Duration(ratePerSec)
		if interval <= 0 {
			interval = time.Millisecond
		}
		go func() {
			tk := time.NewTicker(interval)
			defer tk.Stop()
			for {
				select {
				case <-m.ctx.Done():
					return
				case <-tk.C:
					// éé˜»å¡å‘é€ tokenï¼ˆä¿æŒä¸Šé™ï¼‰
					select {
					case m.tokens <- struct{}{}:
					default:
					}
				}
			}
		}()
	}
	return m
}

// Start å¯åŠ¨æ‰€æœ‰ worker
func (m *Manager) Start() {
	for i := 0; i < m.workers; i++ {
		m.wg.Add(1)
		go m.worker(i)
	}
}

// Enqueue å°è¯•æŠŠä»»åŠ¡æ”¾å…¥é˜Ÿåˆ—ï¼ˆéé˜»å¡é£æ ¼ï¼‰
// å¦‚æœé˜Ÿåˆ—æ»¡ä¼šè¿”å› ErrQueueFull
// å¦‚æœ manager å·²åœæ­¢åˆ™è¿”å› ErrStopped
func (m *Manager) Enqueue(id string, fn TaskFunc) error {
	if atomic.LoadUint32(&m.closed) == 1 {
		atomic.AddUint64(&m.queuedFail, 1)
		return ErrStopped
	}
	select {
	case m.queue <- &taskWrapper{id: id, fn: fn}:
		atomic.AddUint64(&m.enqueued, 1)
		return nil
	default:
		atomic.AddUint64(&m.queuedFail, 1)
		return ErrQueueFull
	}
}

// worker æ˜¯æ¯ä¸ªæ¶ˆè´¹è€… goroutine çš„ä¸»å¾ªç¯
func (m *Manager) worker(idx int) {
	defer m.wg.Done()
	for tw := range m.queue {
		// å¦‚æœ tokens ä¸ä¸º nilï¼Œåˆ™åšé€Ÿç‡é™åˆ¶
		if m.tokens != nil {
			select {
			case <-m.ctx.Done():
				return
			case <-m.tokens:
				// got token
			}
		}

		m.processTask(tw)
	}
	// å½“ queue è¢« closeï¼Œrange ç»“æŸï¼Œworker é€€å‡º
}

// processTask æ‰§è¡Œå•ä¸ªä»»åŠ¡ï¼ŒåŒ…å«é‡è¯•ä¸ panic æ¢å¤
func (m *Manager) processTask(tw *taskWrapper) {
	// recover panic, è®°å½•ä¸ºå¤±è´¥
	defer func() {
		if r := recover(); r != nil {
			err := fmt.Errorf("panic: %v", r)
			atomic.AddUint64(&m.failed, 1)
			if m.OnError != nil {
				m.OnError(tw.id, err)
			}
		}
	}()

	var attempt int
	for {
		attempt++
		// å¦‚æœå…¨å±€ cancelï¼Œè¢«ç«‹å³å–æ¶ˆ -> æ”¾å¼ƒæˆ–è§†ä¸ºå¤±è´¥
		select {
		case <-m.ctx.Done():
			atomic.AddUint64(&m.failed, 1)
			if m.OnError != nil {
				m.OnError(tw.id, fmt.Errorf("task cancelled"))
			}
			return
		default:
		}

		// æ‰§è¡Œä»»åŠ¡
		err := tw.fn(m.ctx)
		if err == nil {
			atomic.AddUint64(&m.processed, 1)
			return
		}

		// å¤±è´¥å¤„ç†
		atomic.AddUint64(&m.retried, 1)
		if attempt > m.maxRetries {
			atomic.AddUint64(&m.failed, 1)
			if m.OnError != nil {
				m.OnError(tw.id, err)
			}
			return
		}

		// æŒ‡æ•°é€€é¿ + æŠ–åŠ¨
		backoff := m.retryBase * (1 << (attempt - 1))
		// æ·»åŠ å°‘é‡éšæœºæŠ–åŠ¨
		jitter := time.Duration(rand.Int63n(int64(backoff)/2+1))
		sleep := backoff + jitter
		// ä½†å¦‚æœ ctx è¢« cancelï¼Œæå‰è¿”å›
		select {
		case <-time.After(sleep):
			// å†è¯•
		case <-m.ctx.Done():
			atomic.AddUint64(&m.failed, 1)
			if m.OnError != nil {
				m.OnError(tw.id, fmt.Errorf("task cancelled during backoff"))
			}
			return
		}
	}
}

// Shutdown ä¼˜é›…å…³é—­ï¼šåœæ­¢æ¥å—æ–°ä»»åŠ¡ã€å…³é—­é˜Ÿåˆ—å¹¶ç­‰å¾… worker å®Œæˆï¼ˆç›´åˆ°è¶…æ—¶ï¼‰
// å¦‚æœ graceful=falseï¼Œåˆ™ç«‹å³ cancel æ‰€æœ‰æ­£åœ¨è¿è¡Œçš„ä»»åŠ¡å¹¶ç«‹å³å…³é—­
func (m *Manager) Shutdown(graceful bool, timeout time.Duration) error {
	// å…ˆè®¾ç½® closed æ ‡å¿—ï¼Œé˜»æ­¢æ–°çš„å…¥é˜Ÿ
	if !atomic.CompareAndSwapUint32(&m.closed, 0, 1) {
		// already closed
	}

	if !graceful {
		// ç«‹å³å–æ¶ˆæ­£åœ¨è¿è¡Œçš„ä»»åŠ¡
		m.cancel()
		// close queue to wake workers (they will exit when range ends)
		close(m.queue)
		// wait for workers
		done := make(chan struct{})
		go func() {
			m.wg.Wait()
			close(done)
		}()
		select {
		case <-done:
			return nil
		case <-time.After(timeout):
			return errors.New("timeout waiting for shutdown")
		}
	}

	// graceful: å…³é—­é˜Ÿåˆ—ï¼Œç­‰å¾…é˜Ÿåˆ—å¤„ç†å®Œï¼ˆworkers range ç»“æŸï¼‰
	close(m.queue)

	// ç­‰å¾… workers å®Œæˆæˆ–è¶…æ—¶
	done := make(chan struct{})
	go func() {
		m.wg.Wait()
		close(done)
	}()
	select {
	case <-done:
		return nil
	case <-time.After(timeout):
		// å¦‚æœè¶…æ—¶ï¼Œå¯ä»¥é€‰æ‹© cancel æ­£åœ¨è¿è¡Œçš„ä»»åŠ¡
		m.cancel()
		return errors.New("timeout waiting for graceful shutdown; cancelled running tasks")
	}
}

// Stats è¿”å›å½“å‰ç»Ÿè®¡ä¿¡æ¯
type Stats struct {
	Enqueued   uint64
	EnqueueFail uint64
	Processed  uint64
	Failed     uint64
	Retries    uint64
	QueueLen   int
}

func (m *Manager) Stats() Stats {
	return Stats{
		Enqueued:   atomic.LoadUint64(&m.enqueued),
		EnqueueFail: atomic.LoadUint64(&m.queuedFail),
		Processed:  atomic.LoadUint64(&m.processed),
		Failed:     atomic.LoadUint64(&m.failed),
		Retries:    atomic.LoadUint64(&m.retried),
		QueueLen:   len(m.queue),
	}
}

// ------------------- æ¼”ç¤º main -------------------

func main() {
	// éšæœºæ•°ç§å­ï¼ˆç”¨äº jitterï¼‰
	rand.Seed(time.Now().UnixNano())

	// åˆ›å»º managerï¼šé˜Ÿåˆ— 100ï¼Œ5 ä¸ª workerï¼Œæ¯ä»»åŠ¡æœ€å¤š 3 æ¬¡é‡è¯•ï¼ŒåŸºæœ¬é€€é¿ 200msï¼Œé€Ÿç‡æ¯ç§’ 20
	m := NewManager(100, 5, 3, 200*time.Millisecond, 20)
	m.OnError = func(id string, err error) {
		log.Printf("[OnError] task %s error: %v\n", id, err)
	}
	m.Start()

	// æ•è·ç³»ç»Ÿä¿¡å·ç”¨äºä¼˜é›…é€€å‡º
	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)

	// æ¨¡æ‹Ÿç”Ÿäº§è€…ï¼ˆå¹¶å‘äº§ç”Ÿä»»åŠ¡ï¼‰
	producers := 3
	var prodWg sync.WaitGroup
	prodWg.Add(producers)
	totalTasks := 1000
	taskCounter := uint64(0)

	for p := 0; p < producers; p++ {
		go func(pid int) {
			defer prodWg.Done()
			for {
				n := atomic.AddUint64(&taskCounter, 1)
				if int(n) > totalTasks {
					return
				}
				id := fmt.Sprintf("task-%d-p%d", n, pid)
				// ä»»åŠ¡ï¼šéšæœºæˆåŠŸæˆ–å¤±è´¥ï¼Œå¤±è´¥ä¼šè§¦å‘é‡è¯•
				err := m.Enqueue(id, func(ctx context.Context) error {
					// æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
					select {
					case <-time.After(time.Duration(rand.Intn(200)) * time.Millisecond):
					case <-ctx.Done():
						return ctx.Err()
					}

					// éšæœºå¤±è´¥æ¦‚ç‡
					if rand.Intn(100) < 20 {
						return fmt.Errorf("random failure for %s", id)
					}
					// åšç‚¹äº‹æƒ…...
					//fmt.Println("processed", id)
					return nil
				})
				if err == ErrQueueFull {
					// ç®€å•ï¼šé‡è¯•å…¥é˜Ÿä¸€æ¬¡å†æ”¾å¼ƒï¼ˆçœŸå®ç”Ÿäº§å¯ä»¥æ›´å¤æ‚ï¼‰
					time.Sleep(50 * time.Millisecond)
					_ = m.Enqueue(id, func(ctx context.Context) error {
						time.Sleep(10 * time.Millisecond)
						return nil
					})
				}
			}
		}(p)
	}

	// ç­‰å¾…ç”Ÿäº§è€…å®Œæˆæˆ–è€…æ¥æ”¶åˆ°é€€å‡ºä¿¡å·
	go func() {
		prodWg.Wait()
		// æ‰€æœ‰ä»»åŠ¡å·²äº§ç”Ÿï¼Œå…³é—­ managerï¼ˆgracefulï¼‰
		log.Println("all producers done; initiating graceful shutdown")
		if err := m.Shutdown(true, 30*time.Second); err != nil {
			log.Println("graceful shutdown error:", err)
		}
	}()

	// ç›‘å¬é€€å‡ºä¿¡å·ï¼Œç”¨æˆ·å¯ä»¥ Ctrl+C æå‰åœæ­¢ï¼ˆç«‹å³ cancelï¼‰
	select {
	case s := <-sigCh:
		log.Printf("signal %v received: stopping immediately\n", s)
		_ = m.Shutdown(false, 5*time.Second)
	}

	// æ‰“å°ç»Ÿè®¡
	fmt.Println("final stats:", m.Stats())
}


```
---
### 4. ä¸¤ä¸ª goroutine äº¤æ›¿æ‰“å° 1~100
**æ€è·¯ï¼š** ä½¿ç”¨ä¸¤ä¸ªæ— ç¼“å†² channel äº¤æ›¿é€šçŸ¥ï¼Œæˆ–ä½¿ç”¨ sync.Condã€‚ä¸‹é¢ç¤ºä¾‹ä½¿ç”¨ channelã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import "fmt"

// äº¤æ›¿æ‰“å°1-100

func DoubleChanPrint() {
	chan1 := make(chan struct{})
	chan2 := make(chan struct{})
	wg := sync.WaitGroup{}
	wg.Add(2)

	go func() {
		defer wg.Done()
		for i := 1; i < 100; i += 2 {
			<-chan1
			fmt.Println("chan1 : ", i)
			chan2 <- struct{}{}
		}
	}()

	go func() {
		defer wg.Done()
		for i := 2; i <= 100; i += 2 {
			<-chan2
			fmt.Println("chan2 : ", i)
			if i < 100 {
				chan1 <- struct{}{}
			}
		}
	}()

	chan1 <- struct{}{}
	wg.Wait()
	close(chan1)
	close(chan2)
}
func DoubleChanPrint2() {
	chan1 := make(chan int) // ç”¨äºå‘é€å¥‡æ•° (1, 3, 5...)
	chan2 := make(chan int) // ç”¨äºå‘é€å¶æ•° (2, 4, 6...)
	wg := sync.WaitGroup{}
	wg.Add(2)

	go func() {
		defer wg.Done()
		for v := range chan1 { // æ¥æ”¶å¥‡æ•°ï¼Œå‘é€å¶æ•°
			fmt.Println("chan1 : ", v) // æ‰“å°å¥‡æ•°
			if v < 99 {
				chan2 <- v + 1
			} else {
				// v == 99ï¼Œå‘é€100åï¼Œå°±å¯ä»¥å…³é—­chan2äº†
				chan2 <- v + 1 // å‘é€ 100
				close(chan2)
			}
		}
	}()

	go func() {
		defer wg.Done()
		for v := range chan2 { // æ¥æ”¶å¶æ•°ï¼Œå‘é€å¥‡æ•°
			fmt.Println("chan2 : ", v) // æ‰“å°å¶æ•°
			if v < 100 {               // v == 100æ—¶ï¼Œæ˜¯æœ€åä¸€ä¸ªæ•°å­—ï¼Œä¸åº”è¯¥å†å‘é€äº†
				chan1 <- v + 1
			} else {
				// v == 100, æ˜¯æœ€åä¸€ä¸ªæ•°å­—ï¼Œä»€ä¹ˆéƒ½ä¸ç”¨åšï¼Œ
				// åªæ˜¯ç­‰å¾… chan2 è¢«å…³é—­åï¼Œå¾ªç¯è‡ªç„¶ç»“æŸã€‚
				close(chan1)
			}
		}
		// chan2 è¢«å…³é—­åï¼Œå¾ªç¯ç»“æŸï¼Œæ‰§è¡Œ defer wg.Done()
	}()

	chan1 <- 1 // å¯åŠ¨
	wg.Wait()
	//close(chan1)
}
```

---
### 5. é™åˆ¶å¹¶å‘æ•°é‡ï¼ˆæ¯”å¦‚æœ€å¤š 10 ä¸ªä»»åŠ¡ï¼‰
**æ€è·¯ï¼š** ä½¿ç”¨å¸¦ç¼“å†²çš„ä¿¡å·é‡ channel æˆ–è€… sync.WaitGroup + æœ‰é™ worker poolã€‚

**ç¤ºä¾‹ï¼ˆä¿¡å·é‡ï¼‰ï¼š**
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    sem := make(chan struct{}, 10) // æœ€å¤§ 10 å¹¶å‘
    var wg sync.WaitGroup
    for i := 0; i < 50; i++ {
        wg.Add(1)
        sem <- struct{}{}
        go func(n int) {
            defer wg.Done()
            defer func() { <-sem }()
            time.Sleep(50 * time.Millisecond)
            fmt.Println("task", n)
        }(i)
    }
    wg.Wait()
    fmt.Println("all tasks done")
}
```

---
### 6. context æ§åˆ¶ä»»åŠ¡è¶…æ—¶ä¸å–æ¶ˆ
**æ€è·¯ï¼š** ä½¿ç”¨ `context.WithTimeout` æˆ– `WithCancel`ï¼Œåœ¨ goroutine å†…é€‰æ‹© `ctx.Done()`ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import (
    "context"
    "fmt"
    "time"
)

func do(ctx context.Context) {
    select {
    case <-time.After(2 * time.Second):
        fmt.Println("work done")
    case <-ctx.Done():
        fmt.Println("cancelled:", ctx.Err())
    }
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
    defer cancel()
    do(ctx)
}
```

---
## ğŸ”´ é«˜çº§åœºæ™¯é¢˜ï¼ˆç³»ç»Ÿè®¾è®¡ä¸æ€§èƒ½ï¼‰

### 1. æœ¬åœ°ç¼“å­˜ç³»ç»Ÿï¼ˆTTL + å¹¶å‘å®‰å…¨ + æ¸…ç†ï¼‰
**æ€è·¯ï¼š** map å­˜å‚¨ key -> {value, expireAt}ï¼Œä½¿ç”¨ RWMutex ä¿æŠ¤ã€‚å¯åŠ¨åå° goroutine å‘¨æœŸæ€§æ¸…ç†è¿‡æœŸé¡¹ã€‚æä¾› Get/Set/Delete æ¥å£ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type item struct {
    value    interface{}
    expireAt int64
}

type Cache struct {
    mu    sync.RWMutex
    m     map[string]*item
    stop  chan struct{}
    wg    sync.WaitGroup
}

func NewCache() *Cache {
    c := &Cache{m: make(map[string]*item), stop: make(chan struct{})}
    c.wg.Add(1)
    go c.periodicClean(1 * time.Second)
    return c
}

func (c *Cache) Set(k string, v interface{}, ttl time.Duration) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.m[k] = &item{value: v, expireAt: time.Now().Add(ttl).UnixNano()}
}

func (c *Cache) Get(k string) (interface{}, bool) {
    c.mu.RLock()
    it, ok := c.m[k]
    c.mu.RUnlock()
    if !ok {
        return nil, false
    }
    if time.Now().UnixNano() > it.expireAt {
        c.mu.Lock()
        delete(c.m, k)
        c.mu.Unlock()
        return nil, false
    }
    return it.value, true
}

func (c *Cache) periodicClean(interval time.Duration) {
    defer c.wg.Done()
    ticker := time.NewTicker(interval)
    defer ticker.Stop()
    for {
        select {
        case <-ticker.C:
            now := time.Now().UnixNano()
            c.mu.Lock()
            for k, v := range c.m {
                if now > v.expireAt {
                    delete(c.m, k)
                }
            }
            c.mu.Unlock()
        case <-c.stop:
            return
        }
    }
}

func (c *Cache) Close() {
    close(c.stop)
    c.wg.Wait()
}
func main() {
    c := NewCache()
    c.Set("a", 1, 2*time.Second)
    v, ok := c.Get("a")
    fmt.Println(v, ok)
    time.Sleep(3 * time.Second)
    v, ok = c.Get("a")
    fmt.Println(v, ok)
    c.Close()
}
```

---
### 2. LRU ç¼“å­˜ï¼ˆmap + åŒå‘é“¾è¡¨ï¼Œçº¿ç¨‹å®‰å…¨ï¼‰
**æ€è·¯ï¼š** ç”¨ map ä¿å­˜ key->nodeï¼ŒåŒå‘é“¾è¡¨ç»´æŠ¤è®¿é—®é¡ºåºã€‚Get å°†èŠ‚ç‚¹ç§»åˆ°å¤´éƒ¨ï¼›Set æ’å…¥å¹¶åœ¨è¶…å®¹é‡æ—¶ç§»é™¤å°¾éƒ¨ã€‚åŠ é”ä¿è¯å¹¶å‘å®‰å…¨ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

func main() {

}

// å®ç°lru
type Node struct {
	key, val   int
	prev, next *Node
}

type LRUCache struct {
	capacity   int
	head, tail *Node
	cache      map[int]*Node
}

func Constructor(capacity int) LRUCache {
	lru := LRUCache{
		capacity: capacity,
		head:     &Node{},
		tail:     &Node{},
		cache:    make(map[int]*Node, capacity+1),
	}
	lru.head.next = lru.tail
	lru.tail.prev = lru.head
	return lru
}
func (l LRUCache) Get(key int) int {
	if node, ok := l.cache[key]; ok {
		l.MoveToHead(node)
		return node.val
	}
	return -1
}
func (l LRUCache) Put(key int, value int) {
	if node, ok := l.cache[key]; ok {
		node.val = value
		l.MoveToHead(node)
	} else {
		node := &Node{key, value, nil, nil}
		l.cache[key] = node
		l.AddNodeToHead(node)
		if len(l.cache) > l.capacity {
			node := l.RemoveTail()
			delete(l.cache, node.key)
		}
	}
}

func (l LRUCache) MoveToHead(node *Node) {
	l.RemoveNode(node)
	l.AddNodeToHead(node)
}
func (l LRUCache) RemoveNode(node *Node) {
	node.prev.next = node.next
	node.next.prev = node.prev
}
func (l LRUCache) AddNodeToHead(node *Node) {
	node.prev = l.head
	node.next = l.head.next
	l.head.next.prev = node
	l.head.next = node
}
func (l LRUCache) RemoveTail() *Node {
	node := l.tail.prev
	l.RemoveNode(node)
	return node
}

```

---
### 3. ç®€æ˜“æ¶ˆæ¯é˜Ÿåˆ—ï¼ˆå‘å¸ƒ/è®¢é˜…ï¼‰
**æ€è·¯ï¼š** ä½¿ç”¨ channel + map[channel] ä¸ºæ¯ä¸ªè®¢é˜…è€…æä¾›æ¥æ”¶é€šé“ã€‚æŒä¹…åŒ–éœ€è¦é¢å¤–å°†æ¶ˆæ¯å†™å…¥ç£ç›˜/æ•°æ®åº“å¹¶åšç¡®è®¤æœºåˆ¶ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import (
    "fmt"
    "sync"
)

type Broker struct {
    mu    sync.RWMutex
    subs  map[string][]chan string
}

func NewBroker() *Broker {
    return &Broker{subs: make(map[string][]chan string)}
}

func (b *Broker) Subscribe(topic string) chan string {
    ch := make(chan string, 10)
    b.mu.Lock()
    b.subs[topic] = append(b.subs[topic], ch)
    b.mu.Unlock()
    return ch
}

func (b *Broker) Publish(topic, msg string) {
    b.mu.RLock()
    subs := b.subs[topic]
    b.mu.RUnlock()
    for _, ch := range subs {
        select {
        case ch <- msg:
        default:
            // drop or buffer full handling
        }
    }
}

func (b *Broker) Unsubscribe(topic string, ch chan string) {
    b.mu.Lock()
    defer b.mu.Unlock()
    subs := b.subs[topic]
    for i, c := range subs {
        if c == ch {
            b.subs[topic] = append(subs[:i], subs[i+1:]...)
            close(c)
            break
        }
    }
}

func main() {
    b := NewBroker()
    ch := b.Subscribe("t1")
    go func() {
        for m := range ch {
            fmt.Println("recv", m)
        }
    }()

    b.Publish("t1", "hello")
    b.Unsubscribe("t1", ch)
}
```

---
### 4. ç§’æ€ç³»ç»Ÿé˜²è¶…å–ï¼ˆå…³é”®æ€è·¯ï¼‰
**æ€è·¯ï¼š** åœ¨é«˜å¹¶å‘ä¸‹é¿å…è¶…å–ï¼šä½¿ç”¨ Redis åšåº“å­˜é¢„å‡ï¼ˆLua è„šæœ¬ä¿è¯åŸå­æ€§ï¼‰ï¼Œå¼•å…¥æœ¬åœ°å†…å­˜å”®ç½„æ ‡è®° + æ¶ˆæ¯é˜Ÿåˆ—å¼‚æ­¥ä¸‹å•ï¼Œæ‰“æ•£å†™åº“å‹åŠ›ã€‚

**å…³é”® Lua ä¼ªç ï¼š**
```text
-- KEYS[1] stock key
-- ARGV[1] amount
local stock = tonumber(redis.call('get', KEYS[1]) or '0')
if stock <= 0 then return 0 end
if stock < tonumber(ARGV[1]) then return 0 end
redis.call('decrby', KEYS[1], ARGV[1])
return 1
```

**Go ç¤ºä¾‹è°ƒç”¨ï¼ˆç®€åŒ–ï¼‰ï¼š**
```go
// çœç•¥ redis å®¢æˆ·ç«¯åˆå§‹åŒ–ï¼Œç¤ºä¾‹ä¼ªç 
script := `...` // ä¸Šé¢çš„ lua
res, err := redisClient.Eval(ctx, script, []string{"stock:1"}, 1).Result()
if err != nil { /* handle */ }
if res.(int64) == 1 {
    // push order info to MQ for async processing
}
```

---
### 5. é™æµç»„ä»¶ï¼ˆä»¤ç‰Œæ¡¶ï¼‰
**æ€è·¯ï¼š** ç”¨ goroutine æŒç»­æŒ‰é€Ÿç‡å‘ channel æ”¾ tokenï¼Œä¸šåŠ¡å¤„ç†å‰å°è¯•å– tokenï¼Œå–ä¸åˆ°åˆ™æ‹’ç»æˆ–ç­‰å¾…ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import (
    "fmt"
    "time"
)

type TokenBucket struct {
    tokens chan struct{}
}

func NewTokenBucket(rate int, capacity int) *TokenBucket {
    tb := &TokenBucket{tokens: make(chan struct{}, capacity)}
    ticker := time.NewTicker(time.Second / time.Duration(rate))
	// åˆå§‹æ—¶å…ˆè£…æ»¡
	for i := 0; i < capacity; i++ {
		tb.tokens <- struct{}{}
	}
    go func() {
        for range ticker.C {
            select {
            case tb.tokens <- struct{}{}:
            default:
            }
        }
    }()
    return tb
}

func (tb *TokenBucket) Allow() bool {
    select {
    case <-tb.tokens:
        return true
    default:
        return false
    }
}

func main() {
    tb := NewTokenBucket(5, 10) // æ¯ç§’ 5 ä¸ªï¼Œæ¡¶å®¹é‡ 10
    for i := 0; i < 20; i++ {
        if tb.Allow() {
            fmt.Println("allowed", i)
        } else {
            fmt.Println("rejected", i)
        }
        time.Sleep(100 * time.Millisecond)
    }
}
```

---
## âš™ï¸ å®æˆ˜ Debug åœºæ™¯é¢˜ï¼ˆæ’éšœä¸ä¼˜åŒ–ï¼‰

### 1. goroutine æ³„æ¼æ’æŸ¥
**æ€è·¯ï¼š** ä½¿ç”¨ `pprof` è·å– goroutine å †æ ˆï¼Œå®šä½é˜»å¡ç‚¹ï¼ˆä¾‹å¦‚ channel é˜»å¡ã€select æ²¡æœ‰ default ç­‰ï¼‰ã€‚æ£€æŸ¥æ‰€æœ‰ goroutine å¯åŠ¨ä½ç½®å¹¶ç¡®ä¿æœ‰é€€å‡ºè·¯å¾„æˆ– context æ§åˆ¶ã€‚

**pprof ç¤ºä¾‹ï¼š**
```go
// åœ¨ç¨‹åº main ä¸­å¼•å…¥ net/http/pprof
import _ "net/http/pprof"
import "net/http"

go func() {
    http.ListenAndServe("localhost:6060", nil)
}()
// ç„¶ååœ¨ç»ˆç«¯ä½¿ç”¨: go tool pprof http://localhost:6060/debug/pprof/goroutine
```

---
### 2. æ­»é”å®šä½ä¸ä¿®å¤
**ç¤ºä¾‹æ­»é”ä»£ç ï¼š**
```go
package main

import "sync"

func main() {
    var mu sync.Mutex
    mu.Lock()
    // do something
    mu.Lock() // deadlock: same goroutine locks twice
}
```

**ä¿®å¤ï¼š** ä¸è¦åœ¨åŒä¸€ goroutine é‡å¤åŠ æ™®é€š Mutexï¼Œæˆ–æ”¹ç”¨ `sync.RWMutex`/è®¾è®¡é¿å…é‡å…¥åœºæ™¯ï¼Œæˆ–ä½¿ç”¨å¯é‡å…¥é”ï¼ˆéœ€è¦è‡ªè¡Œå®ç°ï¼‰ã€‚

---
### 3. å†…å­˜æš´æ¶¨åˆ†æä¸ä¼˜åŒ–
**æ€è·¯ï¼š** ç”¨ pprof çš„ heap åˆ†æå“ªä¸ªå¯¹è±¡å ç”¨å†…å­˜æœ€å¤šï¼›æ£€æŸ¥åˆ‡ç‰‡/ç¼“å­˜æ˜¯å¦æ— é™åˆ¶å¢é•¿ï¼Œæ£€æŸ¥ goroutine å †æ ˆæ˜¯å¦è¿‡å¤šå¯¼è‡´å ç”¨ã€‚ä¼˜åŒ–ï¼šé™åˆ¶ç¼“å­˜å¤§å°ã€å¤ç”¨å¯¹è±¡ï¼ˆsync.Poolï¼‰ã€é¿å…å¤§å¯¹è±¡æ‹·è´ã€‚

---
### 4. é”ç«äº‰è¯Šæ–­ä¸ä¼˜åŒ–
**æ€è·¯ï¼š** ç”¨ `pprof` çš„ mutex profile æˆ– runtime/trace æ‰¾åˆ°çƒ­ç‚¹é”ï¼Œåˆ†ææ˜¯çŸ­ä¸´ç•ŒåŒºè¿˜æ˜¯é•¿ä¸´ç•ŒåŒºï¼Œè€ƒè™‘åˆ†æ®µé”ã€å‡å°‘é”æŒæœ‰æ—¶é—´ã€ä½¿ç”¨è¯»å†™é”æˆ– lock-free ç»“æ„ã€‚

---
### 5. pprof æ‰¾åˆ°çƒ­ç‚¹åæ”¹è¿›ç¤ºä¾‹
**ç¤ºä¾‹ï¼š** å‡è®¾çƒ­ç‚¹åœ¨å­—ç¬¦ä¸²æ‹¼æ¥ï¼Œä¼˜åŒ–å‰ç”¨ `+` é¢‘ç¹æ‹¼æ¥ï¼Œä¼˜åŒ–åä½¿ç”¨ `strings.Builder`ï¼š
```go
// before: using + inside loop -> lots of allocations
// after:
import "strings"
var b strings.Builder
for _, s := range parts {
    b.WriteString(s)
}
res := b.String()
```

---
