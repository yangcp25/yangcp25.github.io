+++
date = '2025-10-22T22:38:00+08:00'
draft = false
title = 'Go åœºæ™¯é¢˜æ¨¡ç‰ˆ â€” ç­”æ¡ˆç‰ˆ'
+++

---
## ğŸŸ¢ åˆçº§åœºæ™¯é¢˜ï¼ˆè¯­è¨€ç‰¹æ€§ä¸é™·é˜±ï¼‰

### 1. åˆ‡ç‰‡åœ¨å‡½æ•°å‚æ•°ä¼ é€’æ—¶ï¼Œä»€ä¹ˆæ—¶å€™ä¼šå½±å“å¤–éƒ¨æ•°æ®ï¼Ÿ
**æ€è·¯ï¼š** åˆ‡ç‰‡æ˜¯ä¸‰å…ƒç»„ï¼ˆæŒ‡é’ˆã€lenã€capï¼‰ã€‚ä¼ å‚æ—¶ä¼šæ‹·è´è¿™ä¸‰é¡¹ï¼Œä½†åº•å±‚æ•°ç»„ä»ç„¶å…±äº«ã€‚åªæœ‰å½“ append å¯¼è‡´æ‰©å®¹ï¼ˆæ–°çš„åº•å±‚æ•°ç»„åˆ†é…ï¼‰æˆ–ä¿®æ”¹é€šè¿‡ç´¢å¼•ç›´æ¥å†™å…¥æ—¶ï¼Œå¤–éƒ¨å¯è§ã€‚
- ç›´æ¥ `s[i] = x` ä¼šå½±å“å¤–éƒ¨ï¼›
- `s = append(s, x)` å½“ cap ä¸è¶³æ—¶ä¼šåˆ†é…æ–°æ•°ç»„ï¼Œå¤–éƒ¨ä¸ä¼šçœ‹åˆ°æ–°å…ƒç´ ã€‚

**ç¤ºä¾‹ä»£ç ï¼š**
```go
package main

import "fmt"

func appendMaybe(s []int) []int {
    s = append(s, 100) // è‹¥ cap ä¸è¶³ï¼Œè¿™é‡Œä¼šåˆ†é…æ–°åº•å±‚æ•°ç»„
    return s
}

func modify(s []int) {
    if len(s) > 0 {
        s[0] = 999 // ä¿®æ”¹å…±äº«åº•å±‚æ•°ç»„
    }
}

func main() {
    a := make([]int, 1, 1)
    a[0] = 1
    b := appendMaybe(a)
    fmt.Println("a:", a) // å¦‚æœæ‰©å®¹å‘ç”Ÿï¼Œa ä¸åŒ…å« 100
    fmt.Println("b:", b)

    c := make([]int, 1, 2)
    c[0] = 1
    d := appendMaybe(c)
    fmt.Println("c:", c) // cap è¶³å¤Ÿï¼Œc ä¼šçœ‹åˆ° append çš„ç»“æœ (å¦‚æœ append reuses)
    fmt.Println("d:", d)

    modify(a)
    fmt.Println("a after modify:", a) // è¢«ä¿®æ”¹
}
```

---
### 2. `for range` vs `for i := 0; i < len(slice); i++`
**æ€è·¯ï¼š** `for range` ä¼šåœ¨æ¯æ¬¡è¿­ä»£æ—¶æŠŠå…ƒç´ æ‹·è´åˆ°æ–°çš„å˜é‡ï¼ˆvï¼‰ï¼Œå› æ­¤ç›´æ¥ä¿®æ”¹ v ä¸ä¼šå½±å“åˆ‡ç‰‡ã€‚ç´¢å¼•è®¿é—® `slice[i]` ç›´æ¥è®¿é—®åº•å±‚æ•°ç»„å¯ä»¥ä¿®æ”¹åŸå€¼ã€‚æ€§èƒ½ä¸Šä¸¤è€…å·®å¼‚å¾ˆå°ï¼Œé™¤éå…ƒç´ ä¸ºå¤§ç»“æ„ä½“ï¼Œrange ä¼šæ‹·è´æ•´ä¸ªç»“æ„ä½“ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import "fmt"

type Big struct{ X [100]int }

func main() {
    s := []Big{{}, {}}

    for i, v := range s {
        v.X[0] = 1 // ä¿®æ”¹çš„æ˜¯ v çš„æ‹·è´ï¼Œä¸ä¼šå½±å“ s[i]
        fmt.Println("range modified v:", i, v.X[0])
    }

    for i := range s {
        s[i].X[0] = 2 // ç›´æ¥ä¿®æ”¹åº•å±‚æ•°ç»„
        fmt.Println("index modified:", i, s[i].X[0])
    }
    fmt.Println("final:", s[0].X[0], s[1].X[0])
}
```

---
### 3. map åˆå§‹åŒ–çš„æ­£ç¡®å†™æ³•
**æ€è·¯ï¼š** æœªåˆå§‹åŒ–çš„ `var m map[K]V` ä¸º nilï¼Œå†™å…¥ä¼š panicã€‚æ­£ç¡®æ–¹å¼ï¼š`m := make(map[string]int)` æˆ– `m := map[string]int{}`ã€‚åœ¨å¹¶å‘åœºæ™¯ä½¿ç”¨ `sync.Mutex` æˆ– `sync.Map`ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import "fmt"

func main() {
    var a map[string]int
    // a["x"] = 1 // panic: assignment to entry in nil map

    b := make(map[string]int)
    b["x"] = 1
    fmt.Println(b)

    c := map[string]int{"y":2}
    fmt.Println(c)
}
```

---
### 4. defer çš„æ‰§è¡Œé¡ºåºä¸ return
**æ€è·¯ï¼š** defer æŒ‰ LIFOï¼ˆåè¿›å…ˆå‡ºï¼‰é¡ºåºæ‰§è¡Œã€‚å‡½æ•°è¿”å›æ—¶ä¼šå…ˆè®¡ç®—è¿”å›å€¼ï¼ˆè‹¥æœ‰å‘½åè¿”å›å€¼åˆ™æ˜¯èµ‹å€¼è¿‡ç¨‹ï¼‰ï¼Œç„¶åæ‰§è¡Œ deferï¼Œæœ€åçœŸæ­£è¿”å›ã€‚è‹¥ defer ä¿®æ”¹äº†å‘½åè¿”å›å€¼ï¼Œåˆ™è¿”å›å€¼ä¼šå˜ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import "fmt"

func f() (r int) {
    defer func() {
        r += 1 // ä¿®æ”¹å‘½åè¿”å›å€¼
    }()
    return 1 // ä¼šå…ˆå°† r=1ï¼Œç„¶åæ‰§è¡Œ deferï¼Œä½¿å¾— r=2ï¼Œæœ€ç»ˆè¿”å› 2
}

func main() {
    fmt.Println(f()) // è¾“å‡º 2
}
```

---
### 5. append æ‰©å®¹ä¸é¿å…å¤åˆ¶
**æ€è·¯ï¼š** å½“ slice çš„ len < cap æ—¶ append ä¸ä¼šåˆ†é…æ–°æ•°ç»„ï¼›è‹¥éœ€è¦é¿å…å¤åˆ¶å¯ä»¥æå‰ `make` å‡ºåˆé€‚çš„ cap æˆ–ä½¿ç”¨ `append(make([]T,0,needed), ...)`ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import "fmt"

func main() {
    s := make([]int, 0, 5)
    for i := 0; i < 5; i++ {
        s = append(s, i)
    }
    fmt.Println(cap(s), s)
}
```

---
### 6. string ä¸ []byte è½¬æ¢ä¼˜åŒ–
**æ€è·¯ï¼š** é¢‘ç¹è½¬æ¢ä¼šäº§ç”Ÿå†…å­˜æ‹·è´ã€‚å¯ä»¥ä½¿ç”¨ `strings.Builder` / `bytes.Buffer` æ¥æ„å»ºå­—ç¬¦ä¸²ï¼Œæˆ–ç”¨ `unsafe` åšé›¶æ‹·è´è½¬æ¢ï¼ˆæœ‰é£é™©ï¼Œä¸æ¨èåœ¨é¢è¯•æ—¶éšæ„ä½¿ç”¨ï¼Œéœ€æ³¨æ˜å®‰å…¨æ€§é—®é¢˜ï¼‰ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import (
    "bytes"
    "fmt"
)

func main() {
    var b bytes.Buffer
    for i := 0; i < 1000; i++ {
        b.WriteString("x")
    }
    s := b.String()
    fmt.Println(len(s))
}
```

---
### 7. å®ç°ä¸€ä¸ªçº¿ç¨‹å®‰å…¨çš„ç®€å• map
**æ€è·¯ï¼š** ä½¿ç”¨ `sync.RWMutex` æä¾›å¹¶å‘å®‰å…¨çš„ Get/Set/Deleteã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import (
    "fmt"
    "sync"
)

type SafeMap struct {
    mu sync.RWMutex
    m  map[string]interface{}
}

func NewSafeMap() *SafeMap {
    return &SafeMap{m: make(map[string]interface{})}
}

func (s *SafeMap) Set(k string, v interface{}) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.m[k] = v
}

func (s *SafeMap) Get(k string) (interface{}, bool) {
    s.mu.RLock()
    defer s.mu.RUnlock()
    v, ok := s.m[k]
    return v, ok
}

func (s *SafeMap) Delete(k string) {
    s.mu.Lock()
    defer s.mu.Unlock()
    delete(s.m, k)
}

func main() {
    sm := NewSafeMap()
    sm.Set("a", 1)
    v, ok := sm.Get("a")
    fmt.Println(v, ok)
    sm.Delete("a")
}
```

---
## ğŸŸ¡ ä¸­çº§åœºæ™¯é¢˜ï¼ˆå¹¶å‘ä¸æ§åˆ¶ï¼‰

### 1. WaitGroup æ§åˆ¶å¹¶å‘ä»»åŠ¡
**æ€è·¯ï¼š** ä½¿ç”¨ `sync.WaitGroup` çš„ Add/Done/Waitã€‚æ³¨æ„ï¼šAdd åº”åœ¨å¯åŠ¨ goroutine ä¹‹å‰æˆ–åœ¨ä¸» goroutine ä¸­ï¼Œé¿å…ç«æ€ã€‚Done æ¬¡æ•°å¿…é¡»ä¸ Add å¯¹åº”ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()
    time.Sleep(100 * time.Millisecond)
    fmt.Println("worker", id, "done")
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go worker(i, &wg)
    }
    wg.Wait()
    fmt.Println("all done")
}
```

---
### 2. å›ºå®šå¤§å°çš„ goroutine æ± ï¼ˆworker poolï¼‰
**æ€è·¯ï¼š** ä½¿ç”¨ä»»åŠ¡ channel å’Œå›ºå®šæ•°é‡çš„ worker goroutineï¼Œæä¾› Submit æ¥å£å¹¶å¯å…³é—­æ± ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import (
    "fmt"
    "sync"
)

type Task func()

type Pool struct {
    tasks chan Task
    wg    sync.WaitGroup
}

func NewPool(workerCount, queueSize int) *Pool {
    p := &Pool{tasks: make(chan Task, queueSize)}
    p.wg.Add(workerCount)
    for i := 0; i < workerCount; i++ {
        go func() {
            defer p.wg.Done()
            for t := range p.tasks {
                t()
            }
        }()
    }
    return p
}

func (p *Pool) Submit(t Task) {
    p.tasks <- t
}

func (p *Pool) Shutdown() {
    close(p.tasks)
    p.wg.Wait()
}

func main() {
    p := NewPool(3, 10)
    for i := 0; i < 10; i++ {
        n := i
        p.Submit(func() { fmt.Println("task", n) })
    }
    p.Shutdown()
    fmt.Println("pool shutdown")
}
```

---
### 3. ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹ï¼ˆä¼˜é›…é€€å‡ºï¼‰
**æ€è·¯ï¼š** ä½¿ç”¨å¸¦ç¼“å†² channelï¼Œç”Ÿäº§è€…åœ¨å…³é—­æ—¶å…³é—­ channelï¼Œæ¶ˆè´¹è€… range channel ç›´åˆ°ç»“æŸã€‚æˆ–è€…ä½¿ç”¨ context æ§åˆ¶å¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…çš„é€€å‡ºã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

func producer(ctx context.Context, ch chan<- int, id int) {
    defer fmt.Println("producer", id, "exit")
    for i := 0; i < 5; i++ {
        select {
        case <-ctx.Done():
            return
        case ch <- i:
            time.Sleep(10 * time.Millisecond)
        }
    }
}

func consumer(ctx context.Context, ch <-chan int, id int, wg *sync.WaitGroup) {
    defer wg.Done()
    for {
        select {
        case <-ctx.Done():
            return
        case v, ok := <-ch:
            if !ok {
                return
            }
            fmt.Println("consumer", id, "got", v)
        }
    }
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    ch := make(chan int, 10)
    var wg sync.WaitGroup

    // start consumers
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go consumer(ctx, ch, i, &wg)
    }

    // producers
    for i := 0; i < 2; i++ {
        go producer(ctx, ch, i)
    }

    time.Sleep(100 * time.Millisecond)
    cancel() // graceful shutdown
    close(ch)
    wg.Wait()
    fmt.Println("all done")
}
```

---
### 4. ä¸¤ä¸ª goroutine äº¤æ›¿æ‰“å° 1~100
**æ€è·¯ï¼š** ä½¿ç”¨ä¸¤ä¸ªæ— ç¼“å†² channel äº¤æ›¿é€šçŸ¥ï¼Œæˆ–ä½¿ç”¨ sync.Condã€‚ä¸‹é¢ç¤ºä¾‹ä½¿ç”¨ channelã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import "fmt"

func main() {
    ch1 := make(chan struct{})
    ch2 := make(chan struct{})

    go func() {
        for i := 1; i <= 100; i += 2 {
            <-ch1
            fmt.Println(i)
            ch2 <- struct{}{}
        }
    }()

    go func() {
        for i := 2; i <= 100; i += 2 {
            <-ch2
            fmt.Println(i)
            ch1 <- struct{}{}
        }
    }()

    // start
    ch1 <- struct{}{}
    // wait finishing by receiving last signal
    <-ch2
}
```

---
### 5. é™åˆ¶å¹¶å‘æ•°é‡ï¼ˆæ¯”å¦‚æœ€å¤š 10 ä¸ªä»»åŠ¡ï¼‰
**æ€è·¯ï¼š** ä½¿ç”¨å¸¦ç¼“å†²çš„ä¿¡å·é‡ channel æˆ–è€… sync.WaitGroup + æœ‰é™ worker poolã€‚

**ç¤ºä¾‹ï¼ˆä¿¡å·é‡ï¼‰ï¼š**
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    sem := make(chan struct{}, 10) // æœ€å¤§ 10 å¹¶å‘
    var wg sync.WaitGroup
    for i := 0; i < 50; i++ {
        wg.Add(1)
        sem <- struct{}{}
        go func(n int) {
            defer wg.Done()
            defer func() { <-sem }()
            time.Sleep(50 * time.Millisecond)
            fmt.Println("task", n)
        }(i)
    }
    wg.Wait()
    fmt.Println("all tasks done")
}
```

---
### 6. context æ§åˆ¶ä»»åŠ¡è¶…æ—¶ä¸å–æ¶ˆ
**æ€è·¯ï¼š** ä½¿ç”¨ `context.WithTimeout` æˆ– `WithCancel`ï¼Œåœ¨ goroutine å†…é€‰æ‹© `ctx.Done()`ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import (
    "context"
    "fmt"
    "time"
)

func do(ctx context.Context) {
    select {
    case <-time.After(2 * time.Second):
        fmt.Println("work done")
    case <-ctx.Done():
        fmt.Println("cancelled:", ctx.Err())
    }
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
    defer cancel()
    do(ctx)
}
```

---
## ğŸ”´ é«˜çº§åœºæ™¯é¢˜ï¼ˆç³»ç»Ÿè®¾è®¡ä¸æ€§èƒ½ï¼‰

### 1. æœ¬åœ°ç¼“å­˜ç³»ç»Ÿï¼ˆTTL + å¹¶å‘å®‰å…¨ + æ¸…ç†ï¼‰
**æ€è·¯ï¼š** map å­˜å‚¨ key -> {value, expireAt}ï¼Œä½¿ç”¨ RWMutex ä¿æŠ¤ã€‚å¯åŠ¨åå° goroutine å‘¨æœŸæ€§æ¸…ç†è¿‡æœŸé¡¹ã€‚æä¾› Get/Set/Delete æ¥å£ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type item struct {
    value    interface{}
    expireAt int64
}

type Cache struct {
    mu    sync.RWMutex
    m     map[string]*item
    stop  chan struct{}
    wg    sync.WaitGroup
}

func NewCache() *Cache {
    c := &Cache{m: make(map[string]*item), stop: make(chan struct{})}
    c.wg.Add(1)
    go c.periodicClean(1 * time.Second)
    return c
}

func (c *Cache) Set(k string, v interface{}, ttl time.Duration) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.m[k] = &item{value: v, expireAt: time.Now().Add(ttl).UnixNano()}
}

func (c *Cache) Get(k string) (interface{}, bool) {
    c.mu.RLock()
    it, ok := c.m[k]
    c.mu.RUnlock()
    if !ok {
        return nil, false
    }
    if time.Now().UnixNano() > it.expireAt {
        c.mu.Lock()
        delete(c.m, k)
        c.mu.Unlock()
        return nil, false
    }
    return it.value, true
}

func (c *Cache) periodicClean(interval time.Duration) {
    defer c.wg.Done()
    ticker := time.NewTicker(interval)
    defer ticker.Stop()
    for {
        select {
        case <-ticker.C:
            now := time.Now().UnixNano()
            c.mu.Lock()
            for k, v := range c.m {
                if now > v.expireAt {
                    delete(c.m, k)
                }
            }
            c.mu.Unlock()
        case <-c.stop:
            return
        }
    }
}

func (c *Cache) Close() {
    close(c.stop)
    c.wg.Wait()
}
func main() {
    c := NewCache()
    c.Set("a", 1, 2*time.Second)
    v, ok := c.Get("a")
    fmt.Println(v, ok)
    time.Sleep(3 * time.Second)
    v, ok = c.Get("a")
    fmt.Println(v, ok)
    c.Close()
}
```

---
### 2. LRU ç¼“å­˜ï¼ˆmap + åŒå‘é“¾è¡¨ï¼Œçº¿ç¨‹å®‰å…¨ï¼‰
**æ€è·¯ï¼š** ç”¨ map ä¿å­˜ key->nodeï¼ŒåŒå‘é“¾è¡¨ç»´æŠ¤è®¿é—®é¡ºåºã€‚Get å°†èŠ‚ç‚¹ç§»åˆ°å¤´éƒ¨ï¼›Set æ’å…¥å¹¶åœ¨è¶…å®¹é‡æ—¶ç§»é™¤å°¾éƒ¨ã€‚åŠ é”ä¿è¯å¹¶å‘å®‰å…¨ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import "container/list"
import "sync"

type LRUCache struct {
    mu       sync.Mutex
    capacity int
    ll       *list.List
    cache    map[string]*list.Element
}

type entry struct {
    key   string
    value interface{}
}

func NewLRU(cap int) *LRUCache {
    return &LRUCache{
        capacity: cap,
        ll:       list.New(),
        cache:    make(map[string]*list.Element),
    }
}

func (l *LRUCache) Get(k string) (interface{}, bool) {
    l.mu.Lock()
    defer l.mu.Unlock()
    if ele, ok := l.cache[k]; ok {
        l.ll.MoveToFront(ele)
        return ele.Value.(*entry).value, true
    }
    return nil, false
}

func (l *LRUCache) Set(k string, v interface{}) {
    l.mu.Lock()
    defer l.mu.Unlock()
    if ele, ok := l.cache[k]; ok {
        l.ll.MoveToFront(ele)
        ele.Value.(*entry).value = v
        return
    }
    ele := l.ll.PushFront(&entry{key: k, value: v})
    l.cache[k] = ele
    if l.ll.Len() > l.capacity {
        last := l.ll.Back()
        if last != nil {
            l.ll.Remove(last)
            delete(l.cache, last.Value.(*entry).key)
        }
    }
}
```

---
### 3. ç®€æ˜“æ¶ˆæ¯é˜Ÿåˆ—ï¼ˆå‘å¸ƒ/è®¢é˜…ï¼‰
**æ€è·¯ï¼š** ä½¿ç”¨ channel + map[channel] ä¸ºæ¯ä¸ªè®¢é˜…è€…æä¾›æ¥æ”¶é€šé“ã€‚æŒä¹…åŒ–éœ€è¦é¢å¤–å°†æ¶ˆæ¯å†™å…¥ç£ç›˜/æ•°æ®åº“å¹¶åšç¡®è®¤æœºåˆ¶ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import (
    "fmt"
    "sync"
)

type Broker struct {
    mu    sync.RWMutex
    subs  map[string][]chan string
}

func NewBroker() *Broker {
    return &Broker{subs: make(map[string][]chan string)}
}

func (b *Broker) Subscribe(topic string) chan string {
    ch := make(chan string, 10)
    b.mu.Lock()
    b.subs[topic] = append(b.subs[topic], ch)
    b.mu.Unlock()
    return ch
}

func (b *Broker) Publish(topic, msg string) {
    b.mu.RLock()
    subs := b.subs[topic]
    b.mu.RUnlock()
    for _, ch := range subs {
        select {
        case ch <- msg:
        default:
            // drop or buffer full handling
        }
    }
}

func (b *Broker) Unsubscribe(topic string, ch chan string) {
    b.mu.Lock()
    defer b.mu.Unlock()
    subs := b.subs[topic]
    for i, c := range subs {
        if c == ch {
            b.subs[topic] = append(subs[:i], subs[i+1:]...)
            close(c)
            break
        }
    }
}

func main() {
    b := NewBroker()
    ch := b.Subscribe("t1")
    go func() {
        for m := range ch {
            fmt.Println("recv", m)
        }
    }()

    b.Publish("t1", "hello")
    b.Unsubscribe("t1", ch)
}
```

---
### 4. ç§’æ€ç³»ç»Ÿé˜²è¶…å–ï¼ˆå…³é”®æ€è·¯ï¼‰
**æ€è·¯ï¼š** åœ¨é«˜å¹¶å‘ä¸‹é¿å…è¶…å–ï¼šä½¿ç”¨ Redis åšåº“å­˜é¢„å‡ï¼ˆLua è„šæœ¬ä¿è¯åŸå­æ€§ï¼‰ï¼Œå¼•å…¥æœ¬åœ°å†…å­˜å”®ç½„æ ‡è®° + æ¶ˆæ¯é˜Ÿåˆ—å¼‚æ­¥ä¸‹å•ï¼Œæ‰“æ•£å†™åº“å‹åŠ›ã€‚

**å…³é”® Lua ä¼ªç ï¼š**
```text
-- KEYS[1] stock key
-- ARGV[1] amount
local stock = tonumber(redis.call('get', KEYS[1]) or '0')
if stock <= 0 then return 0 end
if stock < tonumber(ARGV[1]) then return 0 end
redis.call('decrby', KEYS[1], ARGV[1])
return 1
```

**Go ç¤ºä¾‹è°ƒç”¨ï¼ˆç®€åŒ–ï¼‰ï¼š**
```go
// çœç•¥ redis å®¢æˆ·ç«¯åˆå§‹åŒ–ï¼Œç¤ºä¾‹ä¼ªç 
script := `...` // ä¸Šé¢çš„ lua
res, err := redisClient.Eval(ctx, script, []string{"stock:1"}, 1).Result()
if err != nil { /* handle */ }
if res.(int64) == 1 {
    // push order info to MQ for async processing
}
```

---
### 5. é™æµç»„ä»¶ï¼ˆä»¤ç‰Œæ¡¶ï¼‰
**æ€è·¯ï¼š** ç”¨ goroutine æŒç»­æŒ‰é€Ÿç‡å‘ channel æ”¾ tokenï¼Œä¸šåŠ¡å¤„ç†å‰å°è¯•å– tokenï¼Œå–ä¸åˆ°åˆ™æ‹’ç»æˆ–ç­‰å¾…ã€‚

**ç¤ºä¾‹ï¼š**
```go
package main

import (
    "fmt"
    "time"
)

type TokenBucket struct {
    tokens chan struct{}
}

func NewTokenBucket(rate int, capacity int) *TokenBucket {
    tb := &TokenBucket{tokens: make(chan struct{}, capacity)}
    ticker := time.NewTicker(time.Second / time.Duration(rate))
    go func() {
        for range ticker.C {
            select {
            case tb.tokens <- struct{}{}:
            default:
            }
        }
    }()
    return tb
}

func (tb *TokenBucket) Allow() bool {
    select {
    case <-tb.tokens:
        return true
    default:
        return false
    }
}

func main() {
    tb := NewTokenBucket(5, 10) // æ¯ç§’ 5 ä¸ªï¼Œæ¡¶å®¹é‡ 10
    for i := 0; i < 20; i++ {
        if tb.Allow() {
            fmt.Println("allowed", i)
        } else {
            fmt.Println("rejected", i)
        }
        time.Sleep(100 * time.Millisecond)
    }
}
```

---
## âš™ï¸ å®æˆ˜ Debug åœºæ™¯é¢˜ï¼ˆæ’éšœä¸ä¼˜åŒ–ï¼‰

### 1. goroutine æ³„æ¼æ’æŸ¥
**æ€è·¯ï¼š** ä½¿ç”¨ `pprof` è·å– goroutine å †æ ˆï¼Œå®šä½é˜»å¡ç‚¹ï¼ˆä¾‹å¦‚ channel é˜»å¡ã€select æ²¡æœ‰ default ç­‰ï¼‰ã€‚æ£€æŸ¥æ‰€æœ‰ goroutine å¯åŠ¨ä½ç½®å¹¶ç¡®ä¿æœ‰é€€å‡ºè·¯å¾„æˆ– context æ§åˆ¶ã€‚

**pprof ç¤ºä¾‹ï¼š**
```go
// åœ¨ç¨‹åº main ä¸­å¼•å…¥ net/http/pprof
import _ "net/http/pprof"
import "net/http"

go func() {
    http.ListenAndServe("localhost:6060", nil)
}()
// ç„¶ååœ¨ç»ˆç«¯ä½¿ç”¨: go tool pprof http://localhost:6060/debug/pprof/goroutine
```

---
### 2. æ­»é”å®šä½ä¸ä¿®å¤
**ç¤ºä¾‹æ­»é”ä»£ç ï¼š**
```go
package main

import "sync"

func main() {
    var mu sync.Mutex
    mu.Lock()
    // do something
    mu.Lock() // deadlock: same goroutine locks twice
}
```

**ä¿®å¤ï¼š** ä¸è¦åœ¨åŒä¸€ goroutine é‡å¤åŠ æ™®é€š Mutexï¼Œæˆ–æ”¹ç”¨ `sync.RWMutex`/è®¾è®¡é¿å…é‡å…¥åœºæ™¯ï¼Œæˆ–ä½¿ç”¨å¯é‡å…¥é”ï¼ˆéœ€è¦è‡ªè¡Œå®ç°ï¼‰ã€‚

---
### 3. å†…å­˜æš´æ¶¨åˆ†æä¸ä¼˜åŒ–
**æ€è·¯ï¼š** ç”¨ pprof çš„ heap åˆ†æå“ªä¸ªå¯¹è±¡å ç”¨å†…å­˜æœ€å¤šï¼›æ£€æŸ¥åˆ‡ç‰‡/ç¼“å­˜æ˜¯å¦æ— é™åˆ¶å¢é•¿ï¼Œæ£€æŸ¥ goroutine å †æ ˆæ˜¯å¦è¿‡å¤šå¯¼è‡´å ç”¨ã€‚ä¼˜åŒ–ï¼šé™åˆ¶ç¼“å­˜å¤§å°ã€å¤ç”¨å¯¹è±¡ï¼ˆsync.Poolï¼‰ã€é¿å…å¤§å¯¹è±¡æ‹·è´ã€‚

---
### 4. é”ç«äº‰è¯Šæ–­ä¸ä¼˜åŒ–
**æ€è·¯ï¼š** ç”¨ `pprof` çš„ mutex profile æˆ– runtime/trace æ‰¾åˆ°çƒ­ç‚¹é”ï¼Œåˆ†ææ˜¯çŸ­ä¸´ç•ŒåŒºè¿˜æ˜¯é•¿ä¸´ç•ŒåŒºï¼Œè€ƒè™‘åˆ†æ®µé”ã€å‡å°‘é”æŒæœ‰æ—¶é—´ã€ä½¿ç”¨è¯»å†™é”æˆ– lock-free ç»“æ„ã€‚

---
### 5. pprof æ‰¾åˆ°çƒ­ç‚¹åæ”¹è¿›ç¤ºä¾‹
**ç¤ºä¾‹ï¼š** å‡è®¾çƒ­ç‚¹åœ¨å­—ç¬¦ä¸²æ‹¼æ¥ï¼Œä¼˜åŒ–å‰ç”¨ `+` é¢‘ç¹æ‹¼æ¥ï¼Œä¼˜åŒ–åä½¿ç”¨ `strings.Builder`ï¼š
```go
// before: using + inside loop -> lots of allocations
// after:
import "strings"
var b strings.Builder
for _, s := range parts {
    b.WriteString(s)
}
res := b.String()
```

---
