+++
date = '2025-11-05T09:29:18+08:00'
draft = false
title = 'æ’åºç®—æ³•æ€»ç»“'
+++

æ€»ç»“â€”â€”**æ‰€æœ‰å¸¸è§æ’åºç®—æ³•çš„æ ¸å¿ƒæ€æƒ³ã€æ—¶é—´å¤æ‚åº¦ã€ç©ºé—´å¤æ‚åº¦ã€ç¨³å®šæ€§ã€æ˜¯å¦åŸåœ°æ’åºã€é€‚ç”¨åœºæ™¯å’Œç®€å•ä¾‹å­**ã€‚
ä¸‹é¢æ˜¯**æœ€å…¨é¢ä¸”é¢è¯•å¯¼å‘**çš„æ€»ç»“ç‰ˆæœ¬ğŸ‘‡

---

## ğŸ§  æ’åºç®—æ³•æ€»è§ˆè¡¨

| ç®—æ³•                        | æ€æƒ³                   | æ—¶é—´å¤æ‚åº¦                     | ç©ºé—´å¤æ‚åº¦    | ç¨³å®šæ€§        | åŸåœ°æ’åº | é€‚ç”¨åœºæ™¯          |
| ------------------------- | -------------------- | ------------------------- | -------- | ---------- | ---- | ------------- |
| **å†’æ³¡æ’åº (Bubble Sort)**    | ç›¸é‚»äº¤æ¢ï¼Œæœ€å¤§ï¼ˆæˆ–æœ€å°ï¼‰å…ƒç´ é€æ­¥â€œæµ®å‡ºâ€ | O(nÂ²)                     | O(1)     | âœ… ç¨³å®š       | âœ…    | æ•°æ®é‡å°ã€éƒ¨åˆ†æœ‰åº     |
| **é€‰æ‹©æ’åº (Selection Sort)** | æ¯æ¬¡é€‰æ‹©æœ€å°å…ƒç´ æ”¾åˆ°å‰é¢         | O(nÂ²)                     | O(1)     | âŒ ä¸ç¨³å®š      | âœ…    | æ•°æ®é‡å°ï¼Œå¯¹äº¤æ¢æ¬¡æ•°æ•æ„Ÿ  |
| **æ’å…¥æ’åº (Insertion Sort)** | å°†æœªæ’åºå…ƒç´ æ’å…¥åˆ°å·²æ’åºåºåˆ—ä¸­      | O(nÂ²)                     | O(1)     | âœ… ç¨³å®š       | âœ…    | æ•°æ®åŸºæœ¬æœ‰åºæ—¶é«˜æ•ˆ     |
| **å¸Œå°”æ’åº (Shell Sort)**     | æ’å…¥æ’åºçš„æ”¹è¿›ç‰ˆï¼Œåˆ†ç»„æ¯”è¾ƒå‡å°‘äº¤æ¢    | O(nÂ¹Ë™Â³~nÂ²)                | O(1)     | âŒ ä¸ç¨³å®š      | âœ…    | ä¸­ç­‰è§„æ¨¡æ•°æ®        |
| **å½’å¹¶æ’åº (Merge Sort)**     | åˆ†æ²» + åˆå¹¶æœ‰åºå­åºåˆ—         | O(n log n)                | O(n)     | âœ… ç¨³å®š       | âŒ    | å¤§æ•°æ®ã€å¤–éƒ¨æ’åº      |
| **å¿«é€Ÿæ’åº (Quick Sort)**     | åˆ†æ²» + åŸºå‡†åˆ’åˆ†            | å¹³å‡ O(n log n)<br>æœ€å O(nÂ²) | O(log n) | âŒ ä¸ç¨³å®š      | âœ…    | é€šç”¨æœ€å¿«çš„å†…éƒ¨æ’åº     |
| **å †æ’åº (Heap Sort)**       | åˆ©ç”¨å †ç»“æ„ç»´æŠ¤æœ€å¤§/æœ€å°å€¼        | O(n log n)                | O(1)     | âŒ ä¸ç¨³å®š      | âœ…    | éœ€è¦å¿«é€Ÿæ‰¾æœ€å¤§/æœ€å°çš„åœºæ™¯ |
| **è®¡æ•°æ’åº (Counting Sort)**  | ç»Ÿè®¡æ¯ä¸ªå…ƒç´ å‡ºç°æ¬¡æ•°           | O(n + k)                  | O(n + k) | âœ… ç¨³å®š       | âŒ    | æ•´æ•°ã€èŒƒå›´è¾ƒå°çš„åœºæ™¯    |
| **æ¡¶æ’åº (Bucket Sort)**     | æŒ‰åŒºé—´åˆ’åˆ†å¤šä¸ªæ¡¶å†åˆ†åˆ«æ’åº        | O(n + k)                  | O(n + k) | âœ… ç¨³å®šï¼ˆè§†å­æ’åºï¼‰ | âŒ    | æ•°æ®å‡åŒ€åˆ†å¸ƒçš„æµ®ç‚¹æ•°    |
| **åŸºæ•°æ’åº (Radix Sort)**     | æŒ‰ä½ï¼ˆä¸ªä½â†’é«˜ä½ï¼‰æ’åº          | O(dÂ·(n+k))                | O(n + k) | âœ… ç¨³å®š       | âŒ    | æ•´æ•°ã€å­—ç¬¦ä¸²æ’åº      |

---

## ğŸ” å„ç®—æ³•æ ¸å¿ƒæ€æƒ³è®²è§£ä¸ä»£ç ç¤ºä¾‹

---

### 1ï¸âƒ£ å†’æ³¡æ’åº Bubble Sort

> æ¯ä¸€è½®ä¸¤ä¸¤æ¯”è¾ƒï¼ŒæŠŠæœ€å¤§å€¼â€œå†’æ³¡â€åˆ°æœ€åã€‚

```go
func bubbleSort(nums []int) {
	n := len(nums)
	for i := 0; i < n-1; i++ {
		for j := 0; j < n-i-1; j++ {
			if nums[j] > nums[j+1] {
				nums[j], nums[j+1] = nums[j+1], nums[j]
			}
		}
	}
}
```

âœ… ç¨³å®šã€å®ç°ç®€å•
âŒ æ…¢ï¼Œä¸é€‚åˆå¤§æ•°æ®

---

### 2ï¸âƒ£ é€‰æ‹©æ’åº Selection Sort

> æ¯è½®é€‰å‡ºæœ€å°å€¼æ”¾åˆ°å‰é¢ã€‚

```go
func selectionSort(nums []int) {
	n := len(nums)
	for i := 0; i < n-1; i++ {
		min := i
		for j := i + 1; j < n; j++ {
			if nums[j] < nums[min] {
				min = j
			}
		}
		nums[i], nums[min] = nums[min], nums[i]
	}
}
```

âŒ ä¸ç¨³å®šï¼ˆå› ä¸ºæœ€å°å€¼å’Œå‰é¢å…ƒç´ äº¤æ¢ä¼šç ´åé¡ºåºï¼‰
âœ… ç®€å•ã€äº¤æ¢æ¬¡æ•°å°‘

---

### 3ï¸âƒ£ æ’å…¥æ’åº Insertion Sort

> æŠŠå½“å‰å…ƒç´ æ’å…¥åˆ°å‰é¢å·²æ’åºçš„éƒ¨åˆ†ã€‚

```go
func insertionSort(nums []int) {
	for i := 1; i < len(nums); i++ {
		key := nums[i]
		j := i - 1
		for j >= 0 && nums[j] > key {
			nums[j+1] = nums[j]
			j--
		}
		nums[j+1] = key
	}
}
```

âœ… ç¨³å®šï¼Œå°è§„æ¨¡æˆ–å‡ ä¹æœ‰åºæ•°ç»„å¾ˆå¿«ã€‚
ğŸ“ˆ å¹³å‡ O(nÂ²)ï¼Œæœ€å¥½ O(n)ã€‚

---

### 4ï¸âƒ£ å¸Œå°”æ’åº Shell Sort

> æ’å…¥æ’åº + åˆ†ç»„åŠ é€Ÿã€‚

```go
func shellSort(nums []int) {
	for gap := len(nums) / 2; gap > 0; gap /= 2 {
		for i := gap; i < len(nums); i++ {
			temp := nums[i]
			j := i
			for ; j >= gap && nums[j-gap] > temp; j -= gap {
				nums[j] = nums[j-gap]
			}
			nums[j] = temp
		}
	}
}
```

âŒ ä¸ç¨³å®š
âœ… æ¯”æ’å…¥æ’åºå¿«å¾—å¤šã€‚

---

### 5ï¸âƒ£ å½’å¹¶æ’åº Merge Sort

> åˆ†æ²» + åˆå¹¶ï¼ˆè§ä½ å‰é¢çš„æ¨¡æ¿ï¼‰ã€‚
> âœ… ç¨³å®š
> âŒ éœ€è¦ O(n) é¢å¤–ç©ºé—´ã€‚

---

### 6ï¸âƒ£ å¿«é€Ÿæ’åº Quick Sort

> é€‰ä¸€ä¸ªåŸºå‡†ï¼ŒæŠŠå°äºå®ƒçš„æ”¾å·¦è¾¹ï¼Œå¤§äºçš„æ”¾å³è¾¹ï¼Œå†é€’å½’ã€‚

```go
func quickSort(nums []int) {
	if len(nums) <= 1 {
		return
	}
	sort(nums, 0, len(nums)-1)
}

func sort(nums []int, l, r int) {
	if l >= r {
		return
	}
	pivot := partition(nums, l, r)
	sort(nums, l, pivot-1)
	sort(nums, pivot+1, r)
}

func partition(nums []int, l, r int) int {
	pivot := nums[r]
	i := l
	for j := l; j < r; j++ {
		if nums[j] < pivot {
			nums[i], nums[j] = nums[j], nums[i]
			i++
		}
	}
	nums[i], nums[r] = nums[r], nums[i]
	return i
}
```

âš¡ é€šå¸¸æ˜¯**æœ€å¿«çš„å†…éƒ¨æ’åºç®—æ³•**ã€‚
âŒ ä¸ç¨³å®šï¼Œæœ€åæƒ…å†µ O(nÂ²)ï¼Œä½†å¹³å‡éå¸¸å¥½ã€‚

---

### 7ï¸âƒ£ å †æ’åº Heap Sort

> æ„å»ºæœ€å¤§å †ï¼Œæ¯æ¬¡å–å‡ºå †é¡¶ï¼ˆæœ€å¤§å€¼ï¼‰æ”¾åˆ°æœ«å°¾ã€‚

```go
func heapSort(nums []int) {
	n := len(nums)
	for i := n/2 - 1; i >= 0; i-- {
		heapify(nums, n, i)
	}
	for i := n - 1; i > 0; i-- {
		nums[0], nums[i] = nums[i], nums[0]
		heapify(nums, i, 0)
	}
}

func heapify(nums []int, n, i int) {
	largest := i
	l, r := 2*i+1, 2*i+2
	if l < n && nums[l] > nums[largest] {
		largest = l
	}
	if r < n && nums[r] > nums[largest] {
		largest = r
	}
	if largest != i {
		nums[i], nums[largest] = nums[largest], nums[i]
		heapify(nums, n, largest)
	}
}
```

âœ… ä¸éœ€è¦é¢å¤–ç©ºé—´ï¼ŒO(1) ç©ºé—´å¤æ‚åº¦
âŒ ä¸ç¨³å®š

---

### 8ï¸âƒ£ è®¡æ•°æ’åº Counting Sort

> ç»Ÿè®¡æ¯ä¸ªå…ƒç´ å‡ºç°æ¬¡æ•°ï¼ŒæŒ‰æ¬¡æ•°è¾“å‡ºã€‚

```go
func countingSort(nums []int, maxVal int) []int {
	count := make([]int, maxVal+1)
	for _, v := range nums {
		count[v]++
	}
	idx := 0
	for i, c := range count {
		for c > 0 {
			nums[idx] = i
			idx++
			c--
		}
	}
	return nums
}
```

âœ… ç¨³å®šã€çº¿æ€§æ—¶é—´
âŒ åªèƒ½ç”¨äºéè´Ÿæ•´æ•°ï¼Œä¸”èŒƒå›´ä¸èƒ½å¤ªå¤§ã€‚

---

### 9ï¸âƒ£ æ¡¶æ’åº Bucket Sort

> æŠŠæ•°æ®åˆ†è¿›å¤šä¸ªæ¡¶ï¼Œæ¯ä¸ªæ¡¶å†…éƒ¨å†æ’åºã€‚

```go
func bucketSort(nums []float64) []float64 {
	n := len(nums)
	buckets := make([][]float64, n)
	for _, v := range nums {
		idx := int(v * float64(n))
		buckets[idx] = append(buckets[idx], v)
	}
	
	// å¯¹æ¯ä¸ªæ¡¶å†…éƒ¨æ’åºï¼ˆå¯ç”¨æ’å…¥æ’åºï¼‰
	for i := range buckets {
		insertionSortFloat(buckets[i])
	}
	
	result := make([]float64, 0, n)
	for _, b := range buckets {
		result = append(result, b...)
	}
	return result
}

func insertionSortFloat(nums []float64) {
	for i := 1; i < len(nums); i++ {
		key := nums[i]
		j := i - 1
		for j >= 0 && nums[j] > key {
			nums[j+1] = nums[j]
			j--
		}
		nums[j+1] = key
	}
}
```

é€‚ç”¨äºï¼šåˆ†å¸ƒå‡åŒ€çš„æµ®ç‚¹æ•°ï¼ˆä¾‹å¦‚ `[0,1)` åŒºé—´å†…ï¼‰ã€‚

---

### ğŸ”Ÿ åŸºæ•°æ’åº Radix Sort

> æŒ‰ä¸ªä½ã€åä½ã€ç™¾ä½â€¦â€¦ä¾æ¬¡ä½¿ç”¨è®¡æ•°æ’åºã€‚

```go
func radixSort(nums []int) {
	maxVal := 0
	for _, v := range nums {
		if v > maxVal {
			maxVal = v
		}
	}
	for exp := 1; maxVal/exp > 0; exp *= 10 {
		countingSortByDigit(nums, exp)
	}
}

func countingSortByDigit(nums []int, exp int) {
	n := len(nums)
	output := make([]int, n)
	count := make([]int, 10)

	for i := 0; i < n; i++ {
		digit := (nums[i] / exp) % 10
		count[digit]++
	}
	for i := 1; i < 10; i++ {
		count[i] += count[i-1]
	}
	for i := n - 1; i >= 0; i-- {
		digit := (nums[i] / exp) % 10
		output[count[digit]-1] = nums[i]
		count[digit]--
	}
	copy(nums, output)
}
```

é€‚ç”¨äºï¼šæ•´æ•°ã€å®šé•¿å­—ç¬¦ä¸²ã€‚

---

## ğŸ“ˆ æ€»ç»“

| ç±»åˆ«               | ç®—æ³•       | å£è¯€                  |
| ---------------- | -------- | ------------------- |
| **O(nÂ²) ç±»**      | å†’æ³¡ã€é€‰æ‹©ã€æ’å…¥ | æ…¢ä½†ç®€å•ï¼Œå†’æ³¡æ’å…¥ç¨³ï¼Œé€‰æ‹©ä¸ç¨³     |
| **O(n log n) ç±»** | å½’å¹¶ã€å¿«æ’ã€å †æ’ | åˆ†æ²»ä¸‰å…„å¼Ÿï¼šå½’å¹¶ç¨³ï¼Œå¿«æ’å¿«ï¼Œå †æ’çœç©ºé—´ |
| **çº¿æ€§æ’åºç±»**        | è®¡æ•°ã€æ¡¶ã€åŸºæ•°  | åˆ©ç”¨æ•°æ®ç‰¹å¾æ¢å–é€Ÿåº¦ï¼Œç©ºé—´æ¢æ—¶é—´    |

---


