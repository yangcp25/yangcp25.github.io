+++
date = '2025-10-15T21:52:36+08:00'
draft = false
title = '常用数据结构'
+++

# 常用数据结构定义

## 1\. 链表（Linked List）

``` go
type ListNode struct {
    Val  int
    Next *ListNode
}
```

## 2\. 双向链表（Doubly Linked List）

``` go
type DListNode struct {
    Val  int
    Prev *DListNode
    Next *DListNode
}
```

## 3\. 栈（Stack）

``` go
type Stack struct {
    data []int
}
```

## 4\. 队列（Queue）

``` go
type Queue struct {
    data []int
}
```

## 5\. 二叉树（Binary Tree）

``` go
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}
```

## 6\. N叉树（N-ary Tree）

``` go
type NTreeNode struct {
    Val      int
    Children []*NTreeNode
}
```

## 7\. 图（Graph）

``` go
type GraphNode struct {
    Val       int
    Neighbors []*GraphNode
}
```

## 8\. 哈希表（HashMap）

``` go
m := make(map[string]int)
```

## 9\. 堆（Heap / Priority Queue）

``` go
type Item struct {
    Val int
}

type IntHeap []Item
```

## 10\. 矩阵（Matrix）

``` go
matrix := [][]int{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
}
```

## 11\. Trie（前缀树）

``` go
type TrieNode struct {
    Children map[rune]*TrieNode
    IsEnd    bool
}

type Trie struct {
    Root *TrieNode
}
```

## 12\. 并查集（Union-Find）

``` go
type UnionFind struct {
    Parent []int
    Rank   []int
}
```

## 13\. LRU 缓存（Least Recently Used Cache）

``` go
type pair struct {
    key, value int
}

type LRUCache struct {
    capacity int
    cache    map[int]*list.Element
    list     *list.List
}
```
---

# 进阶
## 图


## 🧠 一、图的基本概念

图由：

* **顶点（Vertex）**：节点（如城市、用户、网页等）
* **边（Edge）**：节点之间的连接关系（如航线、好友关系、链接）

根据边的方向，可以分为：

| 类型  | 说明    | 举例        |
| --- | ----- | --------- |
| 无向图 | 边没有方向 | 好友关系（A↔B） |
| 有向图 | 边有方向  | 关注关系（A→B） |

边还可以有：

* **权重（Weight）**：表示距离、费用、强度等（比如航班距离、传输时间）

---

## 🧩 二、图的存储方式（两种核心结构）

### 1️⃣ 邻接矩阵（Adjacency Matrix）

用一个二维数组 `matrix[i][j]` 表示是否存在边。

例如：

```
0  1  2
A  B  C
```

边：

* A → B
* B → C
* A → C

则邻接矩阵为：

```
   A  B  C
A [0, 1, 1]
B [0, 0, 1]
C [0, 0, 0]
```

👉 适合稠密图（边多），判断连接快（O(1)），但占内存大（O(n²)）。

---

### 2️⃣ 邻接表（Adjacency List）

每个节点维护一个“邻居列表”。

例如同样的图：

```
A: [B, C]
B: [C]
C: []
```

👉 适合稀疏图（边少），存储效率高。

---

## 🧰 三、Go 中的表示方式

### ✅ 邻接表（推荐方式）

```go
type Graph struct {
    edges map[string][]string
}

func NewGraph() *Graph {
    return &Graph{edges: make(map[string][]string)}
}

func (g *Graph) AddEdge(from, to string) {
    g.edges[from] = append(g.edges[from], to)
}
```

使用示例：

```go
func main() {
    g := NewGraph()
    g.AddEdge("A", "B")
    g.AddEdge("A", "C")
    g.AddEdge("B", "C")

    fmt.Println(g.edges)
    // map[A:[B C] B:[C]]
}
```

---

### ✅ 带权图（Weighted Graph）

```go
type Graph struct {
    edges map[string]map[string]int
}

func NewGraph() *Graph {
    return &Graph{edges: make(map[string]map[string]int)}
}

func (g *Graph) AddEdge(from, to string, weight int) {
    if g.edges[from] == nil {
        g.edges[from] = make(map[string]int)
    }
    g.edges[from][to] = weight
}
```

使用示例：

```go
func main() {
    g := NewGraph()
    g.AddEdge("A", "B", 5)
    g.AddEdge("A", "C", 2)
    g.AddEdge("B", "C", 1)

    fmt.Println(g.edges)
    // map[A:map[B:5 C:2] B:map[C:1]]
}
```

---

## 🔍 四、图的遍历（基础模板）

### DFS 深度优先搜索（递归）

```go
func (g *Graph) DFS(start string, visited map[string]bool) {
    if visited[start] {
        return
    }
    visited[start] = true
    fmt.Println("visit:", start)

    for _, neighbor := range g.edges[start] {
        g.DFS(neighbor, visited)
    }
}
```

### BFS 广度优先搜索（队列）

```go
func (g *Graph) BFS(start string) {
    visited := make(map[string]bool)
    queue := []string{start}
    visited[start] = true

    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        fmt.Println("visit:", node)

        for _, neighbor := range g.edges[node] {
            if !visited[neighbor] {
                visited[neighbor] = true
                queue = append(queue, neighbor)
            }
        }
    }
}
```

---

## 🌍 五、常见应用类型

| 问题     | 使用算法           | 说明          |
| ------ | -------------- | ----------- |
| 判断是否连通 | DFS / BFS      | 岛屿数量、朋友圈    |
| 最短路径   | BFS / Dijkstra | 最短路径问题      |
| 检测环    | DFS / 拓扑排序     | 任务依赖检测      |
| 拓扑排序   | Kahn算法 / DFS   | 编译依赖、任务执行顺序 |
| 最小生成树  | Kruskal / Prim | 网络布线、最小代价连接 |
| 强连通分量  | Tarjan算法       | 社交圈、子系统分组   |

---

## 💡 小结

| 存储方式 | 优点    | 缺点   | 适用场景    |
| ---- | ----- | ---- | ------- |
| 邻接矩阵 | 判断连接快 | 占空间大 | 稠密图     |
| 邻接表  | 节省空间  | 判断慢  | 稀疏图（常见） |

---
