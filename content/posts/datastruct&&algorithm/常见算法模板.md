+++
date = '2025-10-18T23:12:48+08:00'
draft = false
title = '常见算法模板'
+++

-----
# 常见算法模板
# 第一部分：核心算法思想

## 1\. 二分查找 (Binary Search)

适用于**有序**序列的查找。

``` go
// 基础版本：查找特定值
func binarySearch(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2 // 防溢出
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1 // 未找到
}

// 变体：查找左侧边界（第一个 >= target 的位置）
func lowerBound(nums []int, target int) int {
    left, right := 0, len(nums) // 注意 right 的取值
    for left < right {
        mid := left + (right-left)/2
        if nums[mid] >= target {
            right = mid
        } else {
            left = mid + 1
        }
    }
    return left
}
```

## 2\. 双指针 (Two Pointers)

### 快慢指针

常用于链表（判断环、找中点）或数组（原地修改）。

``` go
// 链表环检测（已在下方链表部分提供）
func hasCycle(head *ListNode) bool {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```

### 对撞指针（左右指针）

常用于**有序数组**，从两端向中间逼近。

``` go
// 示例：有序数组的两数之和
func twoSumSorted(nums []int, target int) []int {
    left, right := 0, len(nums)-1
    for left < right {
        sum := nums[left] + nums[right]
        if sum == target {
            return []int{left, right}
        } else if sum < target {
            left++
        } else {
            right--
        }
    }
    return []int{-1, -1} // 未找到
}
```

## 3\. 滑动窗口 (Sliding Window)

用于解决子数组/子字符串问题。维护一个 `[left, right)` 区间的窗口。

``` go
// 示例：寻找最小覆盖子串（伪代码框架）
func minWindow(s, t string) string {
    need := make(map[byte]int)
    window := make(map[byte]int)
    for i := range t {
        need[t[i]]++
    }

    left, right := 0, 0
    valid := 0 // 窗口中满足 need 条件的字符个数
    
    // 结果起始索引和长度
    start, minLen := 0, len(s)+1 

    for right < len(s) {
        // c 是将移入窗口的字符
        c := s[right]
        right++
        // ... 进行窗口内数据更新 ...
        if _, ok := need[c]; ok {
            window[c]++
            if window[c] == need[c] {
                valid++
            }
        }

        // 判断左侧窗口是否要收缩
        for valid == len(need) { 
            // 在这里更新最小覆盖子串
            if right-left < minLen {
                start = left
                minLen = right - left
            }
            
            // d 是将移出窗口的字符
            d := s[left]
            left++
            // ... 进行窗口内数据更新 ...
            if _, ok := need[d]; ok {
                if window[d] == need[d] {
                    valid--
                }
                window[d]--
            }
        }
    }

    if minLen == len(s)+1 {
        return ""
    }
    return s[start : start+minLen]
}
```

## 4\. 回溯算法 (Backtracking) / DFS

用于解决组合、排列、子集、N皇后等问题。本质是深度优先搜索（DFS）。

``` go
// 示例：全排列
func permute(nums []int) [][]int {
    res := [][]int{}
    path := []int{}
    used := make(map[int]bool) // 记录路径上已使用的元素
    
    var backtrack func()
    backtrack = func() {
        // 结束条件
        if len(path) == len(nums) {
            temp := make([]int, len(path))
            copy(temp, path)
            res = append(res, temp)
            return
        }
        
        for i := 0; i < len(nums); i++ {
            // 剪枝：已使用过的元素
            if used[i] {
                continue
            }
            
            // 做选择
            path = append(path, nums[i])
            used[i] = true
            
            // 进入下一层决策
            backtrack()
            
            // 撤销选择
            path = path[:len(path)-1]
            used[i] = false
        }
    }
    
    backtrack()
    return res
}
```

## 5\. 广度优先搜索 (BFS)

常用于寻找最短路径、层序遍历等。核心是队列。

``` go
// 示例：二叉树层序遍历（已在下方二叉树部分提供）
// 示例：图的最短路径（伪代码）
func bfsShortestPath(start, end *GraphNode) int {
    queue := []*GraphNode{start}
    visited := make(map[*GraphNode]bool)
    visited[start] = true
    level := 0 // 距离

    for len(queue) > 0 {
        size := len(queue)
        for i := 0; i < size; i++ {
            node := queue[0]
            queue = queue[1:]

            if node == end {
                return level
            }

            for _, neighbor := range node.Neighbors {
                if !visited[neighbor] {
                    visited[neighbor] = true
                    queue = append(queue, neighbor)
                }
            }
        }
        level++
    }
    return -1 // 不可达
}
```

## 6\. 动态规划 (Dynamic Programming)

核心思想：定义状态、找出状态转移方程、确定 base case。

``` go
// 示例：爬楼梯
// 状态定义：dp[i] 表示爬到第 i 阶楼梯的方法数
// 状态转移：dp[i] = dp[i-1] + dp[i-2]
// Base Case: dp[0] = 1, dp[1] = 1 (或 dp[1]=1, dp[2]=2)
func climbStairs(n int) int {
    if n <= 1 {
        return 1
    }
    dp := make([]int, n+1)
    dp[0] = 1
    dp[1] = 1
    
    for i := 2; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
}

// 空间优化（滚动数组）
func climbStairsOptimized(n int) int {
    if n <= 1 {
        return 1
    }
    prev2, prev1 := 1, 1 // 对应 dp[i-2] 和 dp[i-1]
    for i := 2; i <= n; i++ {
        curr := prev1 + prev2 // dp[i]
        prev2 = prev1
        prev1 = curr
    }
    return prev1
}
```

-----

# 第二部分：数据结构相关模板

(这部分是您上次提供的内容，我将其整合到此处)

## 7\. 链表算法

*(需要 `ListNode` 结构定义)*

``` go
type ListNode struct {
    Val  int
    Next *ListNode
}
```

### 反转链表

``` go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    for head != nil {
        next := head.Next
        head.Next = prev
        prev = head
        head = next
    }
    return prev
}
```

### 合并两个有序链表

``` go
func mergeTwoLists(l1, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    cur := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            cur.Next = l1
            l1 = l1.Next
        } else {
            cur.Next = l2
            l2 = l2.Next
        }
        cur = cur.Next
    }
    if l1 != nil { cur.Next = l1 }
    if l2 != nil { cur.Next = l2 }
    return dummy.Next
} 
```

### 链表中环的检测（快慢指针应用）

``` go
func hasCycle(head *ListNode) bool {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```

## 8\. 二叉树遍历

*(需要 `TreeNode` 结构定义)*

``` go
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}
```

### 前序遍历（递归）

``` go
import "fmt"

func preorder(root *TreeNode) {
    if root == nil { return }
    fmt.Println(root.Val)
    preorder(root.Left)
    preorder(root.Right)
}
```

### 中序遍历（递归）

``` go
import "fmt"

func inorder(root *TreeNode) {
    if root == nil { return }
    inorder(root.Left)
    fmt.Println(root.Val)
    inorder(root.Right)
}
```

### 后序遍历（递归）

``` go
import "fmt"

func postorder(root *TreeNode) {
    if root == nil { return }
    postorder(root.Left)
    postorder(root.Right)
    fmt.Println(root.Val)
}
```

### 层序遍历（BFS 应用）

``` go
func levelOrder(root *TreeNode) [][]int {
    if root == nil { return nil }
    queue := []*TreeNode{root}
    res := [][]int{}
    for len(queue) > 0 {
        level := []int{}
        levelSize := len(queue) // 固定当前层的节点数
        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]
            level = append(level, node.Val)
            if node.Left != nil { queue = append(queue, node.Left) }
            if node.Right != nil { queue = append(queue, node.Right) }
        }
        res = append(res, level)
    }
    return res
}
```

## 9\. 图遍历

*(假定 `Graph` 是邻接表 `map[int][]int` 或 `[][]int`)*

### DFS 遍历

``` go
import "fmt"

func dfs(graph Graph, node int, visited map[int]bool) {
    if visited[node] { return }
    visited[node] = true
    fmt.Println(node)
    for _, nei := range graph[node] {
        dfs(graph, nei, visited)
    }
}
```

### BFS 遍历

``` go
func bfs(graph Graph, start int) []int {
    visited := make(map[int]bool)
    queue := []int{start}
    res := []int{}
    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        if visited[node] { continue }
        visited[node] = true
        res = append(res, node)
        for _, nei := range graph[node] {
            if !visited[nei] {
                queue = append(queue, nei)
            }
        }
    }
    return res
}
```

## 10\. 并查集 (Union-Find)

``` go
type UnionFind struct {
    Parent []int
    Rank   []int // 或 Size
}

func NewUnionFind(n int) *UnionFind {
    parent := make([]int, n)
    rank := make([]int, n)
    for i := 0; i < n; i++ {
        parent[i] = i
        rank[i] = 1
    }
    return &UnionFind{Parent: parent, Rank: rank}
}

func (uf *UnionFind) Find(x int) int {
    if uf.Parent[x] != x {
        uf.Parent[x] = uf.Find(uf.Parent[x]) // 路径压缩
    }
    return uf.Parent[x]
}

func (uf *UnionFind) Union(x, y int) bool {
    rootX := uf.Find(x)
    rootY := uf.Find(y)
    if rootX == rootY {
        return false // 已在同一集合
    }
    
    // 按秩合并
    if uf.Rank[rootX] < uf.Rank[rootY] {
        uf.Parent[rootX] = rootY
    } else if uf.Rank[rootX] > uf.Rank[rootY] {
        uf.Parent[rootY] = rootX
    } else {
        uf.Parent[rootY] = rootX
        uf.Rank[rootX]++
    }
    return true
}
```

## 11\. 堆操作 (container/heap)

``` go
import "container/heap"

// 示例：小顶堆
type Item struct {
    Val int
}

type IntHeap []Item

func (h IntHeap) Len() int           { return len(h) }
func (h IntHeap) Less(i, j int) bool { return h[i].Val < h[j].Val } // 小顶堆
func (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *IntHeap) Push(x any) {
    *h = append(*h, x.(Item))
}

func (h *IntHeap) Pop() any {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[:n-1]
    return x
}

/*
// 使用示例：
h := &IntHeap{Item{Val: 2}, Item{Val: 1}, Item{Val: 5}}
heap.Init(h)
heap.Push(h, Item{Val: 3})
fmt.Printf("min: %d\n", (*h)[0].Val)
for h.Len() > 0 {
    fmt.Printf("%d \n", heap.Pop(h).(Item).Val)
}
*/
```

## 12\. Trie (前缀树)

``` go
type TrieNode struct {
    Children map[rune]*TrieNode
    IsEnd    bool
}

func NewTrieNode() *TrieNode {
    return &TrieNode{Children: make(map[rune]*TrieNode)}
}

type Trie struct {
    Root *TrieNode
}

func Constructor() Trie {
    return Trie{Root: NewTrieNode()}
}

func (t *Trie) Insert(word string) {
    node := t.Root
    for _, ch := range word {
        if node.Children[ch] == nil {
            node.Children[ch] = NewTrieNode()
        }
        node = node.Children[ch]
    }
    node.IsEnd = true
}

func (t *Trie) Search(word string) bool {
    node := t.Root
    for _, ch := range word {
        if node.Children[ch] == nil {
            return false
        }
        node = node.Children[ch]
    }
    return node.IsEnd
}
```

## 13\. LRU 缓存

使用 `container/list` 和 `map` 实现。

``` go
import "container/list"

type LRUCache struct {
    capacity int
    cache    map[int]*list.Element // 存储 key 到 list 节点的映射
    list     *list.List            // 双向链表
}

// 链表中存储的元素
type pair struct {
    key, value int
}

func ConstructorLRU(capacity int) LRUCache {
    return LRUCache{
        capacity: capacity,
        cache:    make(map[int]*list.Element),
        list:     list.New(),
    }
}

func (c *LRUCache) Get(key int) int {
    if node, ok := c.cache[key]; ok {
        // 访问到了，移到队头
        c.list.MoveToFront(node)
        return node.Value.(pair).value
    }
    return -1
}

func (c *LRUCache) Put(key, value int) {
    if node, ok := c.cache[key]; ok {
        // 已存在，更新值并移到队头
        c.list.MoveToFront(node)
        node.Value = pair{key, value}
        return
    }
    
    // 不存在，是新元素
    if c.list.Len() == c.capacity {
        // 满了，淘汰队尾元素
        back := c.list.Back()
        if back != nil {
            c.list.Remove(back)
            delete(c.cache, back.Value.(pair).key)
        }
    }
    // 插入新节点到队头
    node := c.list.PushFront(pair{key, value})
    c.cache[key] = node
}
```

## 14\. 栈与队列操作

（使用切片 `[]int` 实现）

``` go
// 栈 (Stack)
type Stack struct {
    data []int
}
func (s *Stack) Push(x int) { s.data = append(s.data, x) }
func (s *Stack) Pop() int {
    n := len(s.data)
    if n == 0 { return -1 }
    val := s.data[n-1]
    s.data = s.data[:n-1]
    return val
}
func (s *Stack) Top() int {
    if len(s.data) == 0 { return -1 }
    return s.data[len(s.data)-1]
}

// 队列 (Queue)
type Queue struct {
    data []int
}
func (q *Queue) Enqueue(x int) { q.data = append(q.data, x) }
func (q *Queue) Dequeue() int {
    if len(q.data) == 0 { return -1 }
    val := q.data[0]
    q.data = q.data[1:]
    return val
}
```
