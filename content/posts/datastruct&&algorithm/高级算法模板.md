+++
date = '2025-11-10T21:55:50+08:00'
draft = false
title = '高级算法模板'
+++

---

# ✅ 总目录（你只要按这个顺序掌握）

| 类别              | 内容               | 定位    |
| --------------- | ---------------- | ----- |
| **一、前缀和 & 差分**  | 区间加减 → O(1) 求和   | 高频基础  |
| **二、字符串**       | KMP、Trie         | 面试常客  |
| **三、BFS / DFS** | 多源 BFS，分层 BFS    | 图模板   |
| **四、拓扑排序**      | DAG 处理           | 调度/依赖 |
| **五、树与图**       | 树直径、并查集、Dijkstra | 中高级   |
| **六、回溯**        | 子集 / N 皇后 / 剪枝   | 模板化即可 |
| **七、状态压缩 DP**   | 子集 DP / bitmask  | 稍难但高频 |
| **八、数学**        | 快速幂 / gcd / 组合数  | 必备基础  |

---

## 一、前缀和 & 差分

### ✅ 前缀和（快速求区间和）

```
sum[i] = nums[0] + ... + nums[i]
区间 [l, r] 的和 = sum[r] - sum[l-1]
```

```go
func prefixSum(nums []int) []int {
    n := len(nums)
    pre := make([]int, n+1)
    for i := 1; i <= n; i++ {
        pre[i] = pre[i-1] + nums[i-1]
    }
    return pre
}
```

---

### ✅ 差分（区间加值）

```
diff[i] = nums[i] - nums[i-1]
区间加 k：diff[l] += k, diff[r+1] -= k
```

```go
func diffBuild(nums []int) []int {
    n := len(nums)
    diff := make([]int, n)
    diff[0] = nums[0]
    for i := 1; i < n; i++ {
        diff[i] = nums[i] - nums[i-1]
    }
    return diff
}
func diffApply(diff []int) []int {
    for i := 1; i < len(diff); i++ {
        diff[i] += diff[i-1]
    }
    return diff
}
```

---

## 二、字符串

### ✅ KMP（快速匹配）

**核心：求 next 数组（最长前后缀相等长度）**

```go
func buildNext(p string) []int {
    n := len(p)
    next := make([]int, n)
    j := 0
    for i := 1; i < n; i++ {
        for j > 0 && p[i] != p[j] {
            j = next[j-1]
        }
        if p[i] == p[j] {
            j++
        }
        next[i] = j
    }
    return next
}
```

---

### ✅ Trie 字典树

```go
type Trie struct{ next [26]*Trie; end bool }

func (t *Trie) Insert(s string) {
    cur := t
    for _, c := range s {
        idx := c - 'a'
        if cur.next[idx] == nil { cur.next[idx] = &Trie{} }
        cur = cur.next[idx]
    }
    cur.end = true
}
```

---

## 三、BFS / DFS

### ✅ BFS（无权图最短路）

```go
func bfs(start int, g map[int][]int) []int {
    dist := map[int]int{start: 0}
    q := []int{start}
    for len(q) > 0 {
        x := q[0]; q = q[1:]
        for _, y := range g[x] {
            if _, seen := dist[y]; !seen {
                dist[y] = dist[x] + 1
                q = append(q, y)
            }
        }
    }
    return dist
}
```

---

### ✅ DFS（搜索 / 连通块）

```go
func dfs(x int, g map[int][]int, vis map[int]bool) {
    vis[x] = true
    for _, y := range g[x] {
        if !vis[y] { dfs(y, g, vis) }
    }
}
```

---

## 四、拓扑排序（DAG）

```go
func topoSort(g map[int][]int, indeg []int) []int {
    q := []int{}
    for i, d := range indeg { if d == 0 { q = append(q, i) } }
    order := []int{}
    for len(q) > 0 {
        x := q[0]; q = q[1:]
        order = append(order, x)
        for _, y := range g[x] {
            indeg[y]--
            if indeg[y] == 0 { q = append(q, y) }
        }
    }
    return order
}
```

---

## 五、树 & 图

### ✅ 树的直径（两次 BFS）

```
任取 A → 找到最远点 B
从 B 再 BFS → 得到最远点距离，即为直径
```

---

### ✅ 并查集

```go
type DSU struct{ fa []int }
func NewDSU(n int) *DSU {
    fa := make([]int, n)
    for i := range fa { fa[i] = i }
    return &DSU{fa}
}
func (d *DSU) Find(x int) int {
    if d.fa[x] != x { d.fa[x] = d.Find(d.fa[x]) }
    return d.fa[x]
}
func (d *DSU) Union(a, b int) { d.fa[d.Find(a)] = d.Find(b) }
```

---

### ✅ Dijkstra（带权最短路）

```go
type Pair struct{ d, x int }
func dijkstra(n int, g map[int][]Pair, src int) []int {
    const inf = 1e18
    dist := make([]int, n)
    for i := range dist { dist[i] = inf }
    dist[src] = 0
    h := &MinHeap{}; heap.Push(h, Pair{0, src})
    for h.Len() > 0 {
        p := heap.Pop(h).(Pair)
        if p.d > dist[p.x] { continue }
        for _, e := range g[p.x] {
            if dist[e.x] > p.d + e.d {
                dist[e.x] = p.d + e.d
                heap.Push(h, Pair{dist[e.x], e.x})
            }
        }
    }
    return dist
}
```

---

## 六、回溯模板（通杀子集 / 排列 / N 皇后）

```go
var res [][]int
var path []int
func backtrack(nums []int, start int) {
    res = append(res, append([]int(nil), path...))
    for i := start; i < len(nums); i++ {
        path = append(path, nums[i])
        backtrack(nums, i+1)
        path = path[:len(path)-1]
    }
}
```

---

## 七、状态压缩 DP（经典模板）

```
dp[mask]：表示子集 mask 的最优值
for each sub = mask 的子集:
    dp[mask] = min(dp[mask], dp[sub] + dp[mask-sub])
```

---

## 八、数学

```go
func gcd(a, b int) int { if b==0 { return a }; return gcd(b, a%b) }

func fastPow(a, b, mod int) int {
    res := 1
    for b > 0 {
        if b&1 == 1 { res = res*a % mod }
        a = a*a % mod
        b >>= 1
    }
    return res
}
```

---
