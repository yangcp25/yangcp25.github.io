+++
date = '2025-07-23T22:28:18+08:00'
draft = false
title = 'Http2_grpc'
+++
### http2
#### http1的弊端
* 数据以文本传输，十分低效
* header头数据很多
* 每个tcp链接只能发送一次链接
* 只能单向传递数据，由浏览器发起
* 加载无法定义顺序
#### http2
http2针对这些缺点进行了优化
* 对数据进行二进制分帧，基于流传输提高了传输效率，还可以进行流量控制，提升安全性和可靠性
* 对头数据进行了压缩，采用hpack算法对数据进行压缩，提升了传输效率
* 采用多路复用，每个tcp连接可以发起任意多的传输请求，减少了tcp的三次握手等频繁建立请求
* 可以实现服务端推送，从单向传输改为双向传输
* 可以根据页面不同资源的重要程度设置优先级进行加载
通过以上五个方面http2对h1进行了升级，提高了传输效率，增加更多实现的功能，提升了客户端用户体验。
#### 如何使用
##### 反向代理软件如nginx/apache等设置http2选项
如nginx,首先必须支持ssl/tsl证书，再加上`listen 443 ssl http2`
##### go的net组件自动支持http2,无需手动升级
### grpc
#### rpc
rpc是远程过程调用，是一种在不同进程或组件上让函数调用如同本地调用一样的技术。有多种实现，比如json-rpc,xrpc(基于xml),gprc
google推出，基于protobuf,通过IDL(接口定义)定义同义的方法和参数，使用代码生成工具生成不同语言的代码。

grpc也是基于http2,所以他可以利用http2的各种特性，他有google推出，采用protobuf传输。

Protobuf 是一种跨语言的、结构化数据的二进制序列化协议

他有以下特点：
* 基于IDL生成，接口及定义，可以生成多语言，被客户端和服务端共用。
* 数据传输效率高，基于http2,拥有双向传输、tcp多路复用、二进制数据帧传输、流量控制等特性
* 常见于微服务当中，可以方便的定义中间件，进行限流、降级等特性

完整 RPC 框架至少要干这些事：
* 方法发现
* 我要调的是哪个服务？哪个方法？
* 参数序列化 / 反序列化
* 网络传输
* 错误模型
* 超时、重试、返回码
* 连接管理
* 长连接？池化？
* 并发模型
* 流式调用（可选）

HTTP和 gRPC 的区别在于：
* HTTP + JSON 的本质是：
“约定好的接口 + 字符串传输”
gRPC 的本质是：
* “强约束的接口 + 代码级调用”
#### 总结
RPC是一种编程模型、抽象思想，RPC框架是这种编程模型、抽象思想的一种实现。grpc是rpc的一种go语言版本的实现。
grpc框架提供了服务发现与注册、网络传输、编解码数据、错误机制（超时、重试、错误码定义等）、连接管理、并发模型等功能，让不同服务之间的调用就像调用
一个包的函数里面调用一样。

protobuf负责数据的编码与解码。通过编写proto文件IDL强约束接口，定义方法和字段，并通过工具可以生成不同语言的代码，protobuf支持多种语言的生成。
通过小数据用小字段，大数据用大字段，对数据进行编号，采用Varint对大部分字段进行编码，传输过程根据编号进行二进制传输，减少了数据传输的大小。传输格式为
Key(field_number + wire_type) + Value， key的低3位表示 value的编码格式。 value 采用 0 + 7的格式，最高位表示后续是否还有数据。

grpc通过http2传输，所以具有http2的有点：高效的可靠性传输二进制传输、流量控制、拥塞控制；压缩头部；双向传输；多路复用；自定义加载顺序等特性。

维度,HTTP/JSON (REST),gRPC (Protobuf)
契约约束,松散（靠文档/口头）,严谨（靠 .proto 强约束）
序列化,文本 (JSON),二进制 (Protobuf)
传输层,HTTP/1.1 (大部分),HTTP/2 (原生),并发能力更强
流支持,不支持（需依赖额外协议）,原生支持 (四种流模式),业务扩展性极强
浏览器支持,完美支持,需代理 (grpc-web),适合微服务内部通信

### 浏览器一次完整的请求过程
* 服务器会启动进程监听某个端口，当端口监听到请求，进行处理
* 通过DNS解析域名拿到目标IP,依次通过浏览器、本地缓存查询，没有就往根dns服务器查询。
* 如果是http协议需要先通过ssl建立安全通道。
* 建立TCP连接，通过五元组：协议 ip 端口 目标IP 目标端口 进行三次握手，握手完成后开始发送数据
* 数据进行封装,数据从应用层（报文）->传输层（报文+端口号）->网络IP层（数据段+IP）->数据链路层(数据包+mac主机物理地址->数据帧)->物理层(二进制流)这个层次依次进行传输
* 通过网络层找到目的主机，通过端口号找到主机监听目的端口的程序。应用程序处理请求。
* 服务器处理响应，完成后，返回给客户端
* 断开连接、4次挥手，最后一次等待服务器发送完毕数据

### 参考资料
* https://blog.csdn.net/u012914309/article/details/127507726?spm=1001.2014.3001.5501
