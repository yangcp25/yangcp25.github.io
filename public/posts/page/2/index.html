<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Posts | yangcp</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - yangcp">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css" integrity="sha256-IhHKMWS&#43;eDACT2qtKzouUghDpk&#43;PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/posts/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="yangcp (Alt + H)">yangcp</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tag">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/me/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="http://localhost:1313/">Home</a></div>
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">限流熔断降级
    </h2>
  </header>
  <div class="entry-content">
    <p> 「熔断、限流、降级」 它们都属于服务稳定性设计（Service Resilience）的一部分。
下面我给你一个“面试官喜欢听”的回答框架，从概念 → 场景 → 实现 → 举例 四步讲清楚， 适合百度这种系统架构导向的岗位 👇
🧩 一、三者区别和联系（高层答法） 一句话记忆：
限流：控制请求量，不让系统被压垮。 熔断：发现下游挂了，别再请求它。 降级：资源紧张时，主动牺牲部分功能，保证核心可用。 面试开头可以这样讲：
“在微服务架构下，我们通常通过限流、熔断、降级三种机制保障系统的稳定性。 三者的核心目标都是防止服务雪崩，只是介入的时机不同：
限流在请求入口处防止流量打爆； 熔断在调用链中断开异常依赖； 降级则在系统压力大时主动丢弃非核心功能。” ⚙️ 二、限流（Rate Limiting） 📘 概念 限制系统单位时间内可处理的请求数。
📍常见算法 固定窗口（Fixed Window） 滑动窗口（Sliding Window） 漏桶算法（Leaky Bucket） 令牌桶算法（Token Bucket）✅ 常用 令牌桶算法原理：系统按照固定速率生成令牌，请求只有拿到令牌才能执行，否则拒绝或排队。
🛠️ 实现方式 单机限流：用 golang.org/x/time/rate（Go官方限流包） 分布式限流：用 Redis 实现（Lua脚本保证原子性） 网关层限流：在 API Gateway（如 Kong、Nginx、Kratos Gateway）配置规则 💬 举例 “比如我在上一个项目中，为防止短信接口被刷，我们在 Nginx 层按 IP &#43; URI 做限流，用令牌桶算法控制速率为 10 req/s，多余的直接返回 429 Too Many Requests。”
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-10-22 17:18:39 +0800 CST'>October 22, 2025</span>&nbsp;·&nbsp;2 min</footer>
  <a class="entry-link" aria-label="post link to 限流熔断降级" href="http://localhost:1313/posts/microservice/%E9%99%90%E6%B5%81%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Init
    </h2>
  </header>
  <div class="entry-content">
    <p>✅ 一、init() 是什么 init() 是 Go 的特殊函数，用于在包被加载时自动执行初始化逻辑。 它不需要显式调用，也不能被其他代码调用。
✅ 二、init() 的基本特性 特性 说明 触发时机 在包被第一次导入时自动执行（只执行一次） 调用方式 Go runtime 自动调用，不能手动调用 参数 无参数 返回值 无返回值 作用范围 每个包可以定义多个 init() 函数 执行顺序 按照导入依赖关系和源码出现顺序执行 ✅ 三、最基本的例子 package main import &#34;fmt&#34; func init() { fmt.Println(&#34;init() called&#34;) } func main() { fmt.Println(&#34;main() called&#34;) } 输出：
init() called main() called ✅ init() 总是在 main() 之前执行。
✅ 四、包初始化顺序（重点） Go 程序启动时会按如下顺序执行：
导入依赖包 初始化依赖包的常量和变量 执行依赖包的 init() 函数 执行当前包的常量、变量初始化 执行当前包的 init() 函数 执行 main.main() 示例： // file: a.go package a import &#34;fmt&#34; var V = initVar() func initVar() int { fmt.Println(&#34;a.initVar()&#34;) return 42 } func init() { fmt.Println(&#34;a.init()&#34;) } // file: main.go package main import ( &#34;fmt&#34; &#34;example/a&#34; ) func init() { fmt.Println(&#34;main.init()&#34;) } func main() { fmt.Println(&#34;main.main()&#34;, a.V) } 输出：
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-10-22 09:59:13 +0800 CST'>October 22, 2025</span>&nbsp;·&nbsp;2 min</footer>
  <a class="entry-link" aria-label="post link to Init" href="http://localhost:1313/posts/go/init/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Defer
    </h2>
  </header>
  <div class="entry-content">
    <p>✅ 一、defer 的基本作用 defer 用来延迟执行一段函数调用，直到当前函数返回时才执行（无论是正常返回还是遇到 panic）。
示例： func main() { fmt.Println(&#34;A&#34;) defer fmt.Println(&#34;B&#34;) fmt.Println(&#34;C&#34;) } 输出：
A C B 👉 defer 的调用会在函数退出时执行。
✅ 二、多个 defer 的执行顺序：后进先出 (LIFO) func main() { defer fmt.Println(&#34;1&#34;) defer fmt.Println(&#34;2&#34;) defer fmt.Println(&#34;3&#34;) } 输出：
3 2 1 就像栈一样，最后注册的 defer 最先执行。
✅ 三、参数求值时机：defer 定义时就求值 这是一个非常重要的细节！
func main() { x := 10 defer fmt.Println(&#34;defer:&#34;, x) x = 20 fmt.Println(&#34;x =&#34;, x) } 输出：
x = 20 defer: 10 🔹 原因： defer 的参数会在注册 defer 时立刻求值，而不是在执行时求值。
✅ 四、闭包 defer：引用外部变量时会实时读取 func main() { x := 10 defer func() { fmt.Println(&#34;defer:&#34;, x) }() x = 20 fmt.Println(&#34;x =&#34;, x) } 输出：
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-10-22 09:58:12 +0800 CST'>October 22, 2025</span>&nbsp;·&nbsp;2 min</footer>
  <a class="entry-link" aria-label="post link to Defer" href="http://localhost:1313/posts/go/defer/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">算法题解题思路
    </h2>
  </header>
  <div class="entry-content">
    <p>一、常见题型与核心解法对应表 题型类别 常用解法 关键思维 常见题例 数组 / 序列类 双指针、滑动窗口、前缀和、单调栈 定长窗口 / 不定长窗口 三数之和、最大子序和、每日温度、接雨水 排序 / 查找类 快排、归并、二分查找 有序性 &#43; 区间分治 搜索插入位置、旋转数组最小值 动态规划（DP）类 状态转移 &#43; 子问题划分 “前 i 个…”、“以 i 结尾…” 打家劫舍、最大子序和、单词拆分、爬楼梯 字符串类 DP、双指针、哈希 子串、回文、匹配 最长回文子串、无重复子串长度 哈希 / 集合类 map &#43; 滑动窗口 存在性判断 两数之和、最长不重复子串 栈 / 队列类 单调栈、辅助栈、队列优化 “下一个更大元素” 有效括号、每日温度、接雨水 树 / 图类 DFS / BFS、递归 / 队列 遍历 &#43; 状态传递 二叉树最大深度、岛屿数量、最短路径 贪心类 局部最优 → 全局最优 排序 &#43; 选择 区间合并、跳跃游戏、分发糖果 数学类 模拟、整除、快速幂 数学规律化简 整数反转、Pow(x,n)、罗马数字转整数 二、陌生题分析框架（核心应对模板） 🧩 Step 1：先搞清问题类型 是否要求最值？
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-10-21 09:48:33 +0800 CST'>October 21, 2025</span>&nbsp;·&nbsp;3 min</footer>
  <a class="entry-link" aria-label="post link to 算法题解题思路" href="http://localhost:1313/posts/datastructalgorithm/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">面试题模板
    </h2>
  </header>
  <div class="entry-content">
    <p>SQL 面试题模板（综合） 模拟数据表 在大多数面试中，面试官会假设有几个经典的数据表。我们以此为基础：
Employees (员工表)
emp_id (INT, Primary Key) - 员工 ID emp_name (VARCHAR) - 员工姓名 salary (DECIMAL) - 薪水 dept_id (INT, Foreign Key) - 部门 ID Departments (部门表)
dept_id (INT, Primary Key) - 部门 ID dept_name (VARCHAR) - 部门名称 模块一：基础查询 (SELECT, WHERE, ORDER BY) 考察点：数据筛选、排序、限制的基本功。
[筛选] 查找 Employees 表中薪水 (salary) 高于 80000 的所有员工信息。 [多条件] 查找 ‘Sales’ (销售) 部门中，薪水低于 60000 的员工。 [模糊查询] 查找所有姓 ‘王’ 的员工 (使用 LIKE &#39;王%&#39;)。 [空值处理] 查找所有尚未分配部门（dept_id 为 NULL）的员工。 [排序与限制] 查找公司薪水最高的 5 名员工的信息 (使用 ORDER BY ... DESC 和 LIMIT ...)。 模块二：聚合与分组 (GROUP BY, HAVING) 考察点：数据汇总、分组统计的能力。
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-10-19 12:21:08 +0800 CST'>October 19, 2025</span>&nbsp;·&nbsp;3 min</footer>
  <a class="entry-link" aria-label="post link to 面试题模板" href="http://localhost:1313/posts/sql/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%A8%A1%E6%9D%BF/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">常见算法模板
    </h2>
  </header>
  <div class="entry-content">
    <p> 常见算法模板 第一部分：核心算法思想 1. 二分查找 (Binary Search) 适用于有序序列的查找。
// 基础版本：查找特定值 func binarySearch(nums []int, target int) int { left, right := 0, len(nums)-1 for left &lt;= right { mid := left &#43; (right-left)/2 // 防溢出 if nums[mid] == target { return mid } else if nums[mid] &lt; target { left = mid &#43; 1 } else { right = mid - 1 } } return -1 // 未找到 } // 变体：查找左侧边界（第一个 &gt;= target 的位置） func lowerBound(nums []int, target int) int { left, right := 0, len(nums) // 注意 right 的取值 for left &lt; right { mid := left &#43; (right-left)/2 if nums[mid] &gt;= target { right = mid } else { left = mid &#43; 1 } } return left } 2. 双指针 (Two Pointers) 快慢指针 常用于链表（判断环、找中点）或数组（原地修改）。
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-10-18 23:12:48 +0800 CST'>October 18, 2025</span>&nbsp;·&nbsp;9 min</footer>
  <a class="entry-link" aria-label="post link to 常见算法模板" href="http://localhost:1313/posts/datastructalgorithm/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">进程间通信
    </h2>
  </header>
  <div class="entry-content">
    <p></p>
  </div>
  <footer class="entry-footer"><span title='2025-10-18 20:26:52 +0800 CST'>October 18, 2025</span>&nbsp;·&nbsp;0 min</footer>
  <a class="entry-link" aria-label="post link to 进程间通信" href="http://localhost:1313/posts/cs/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">常用数据结构
    </h2>
  </header>
  <div class="entry-content">
    <p>常用数据结构定义 1. 链表（Linked List） type ListNode struct { Val int Next *ListNode } 2. 双向链表（Doubly Linked List） type DListNode struct { Val int Prev *DListNode Next *DListNode } 3. 栈（Stack） type Stack struct { data []int } 4. 队列（Queue） type Queue struct { data []int } 5. 二叉树（Binary Tree） type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 6. N叉树（N-ary Tree） type NTreeNode struct { Val int Children []*NTreeNode } 7. 图（Graph） type GraphNode struct { Val int Neighbors []*GraphNode } 8. 哈希表（HashMap） m := make(map[string]int) 9. 堆（Heap / Priority Queue） type Item struct { Val int } type IntHeap []Item 10. 矩阵（Matrix） matrix := [][]int{ {1, 2, 3}, {4, 5, 6}, {7, 8, 9}, } 11. Trie（前缀树） type TrieNode struct { Children map[rune]*TrieNode IsEnd bool } type Trie struct { Root *TrieNode } 12. 并查集（Union-Find） type UnionFind struct { Parent []int Rank []int } 13. LRU 缓存（Least Recently Used Cache） type pair struct { key, value int } type LRUCache struct { capacity int cache map[int]*list.Element list *list.List } 进阶 图 🧠 一、图的基本概念 图由：
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-10-15 21:52:36 +0800 CST'>October 15, 2025</span>&nbsp;·&nbsp;3 min</footer>
  <a class="entry-link" aria-label="post link to 常用数据结构" href="http://localhost:1313/posts/datastructalgorithm/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">打卡计划表
    </h2>
  </header>
  <div class="entry-content">
    <p>开启打卡计划 日期 题目 模板 二刷结果 迁移练习 备注 10/16 15. 三数之和 双指针 ✅ 三数差值最接近 完整复盘，写模板笔记 10/17 11. 盛最多水的容器 双指针 ✅ 股票最大利润 计时 25 分钟 10/18 3. 无重复字符的最长子串 滑动窗口 ✅ 最长允许1重复字符 模拟面试说思路 10/19 1. 两数之和 哈希 ✅ 三数之和、路径求和 强化迁移能力 10/20 20. 有效括号 栈 ✅ HTML标签验证 二刷完成 10/21 739. 每日温度 单调栈 ✅ 下一个更小元素 二刷 &#43; 迁移 10/22 206. 反转链表 链表 ✅ k组反转、回文链表 模板笔记 10/23 141. 环形链表 链表 ✅ 相交链表检测 二刷完成 10/24 53. 最大子序和 动态规划 ✅ 股票最大利润 计时练习 10/25 198. 打家劫舍 动态规划 ✅ 环形打家劫舍 二刷完成 10/26 139. 单词拆分 动态规划 ✅ 所有拆分方式 写迁移笔记 10/27 33. 搜索旋转排序数组 二分 搜索峰值 计时练习 10/28 200. 岛屿数量 DFS/BFS 封闭区域计数 二刷 &#43; 迁移 10/29 104. 二叉树最大深度 树 判断平衡二叉树 模板笔记 10/30 236. 最近公共祖先 树 N叉树版本 二刷完成 </p>
  </div>
  <footer class="entry-footer"><span title='2025-10-15 21:52:36 +0800 CST'>October 15, 2025</span>&nbsp;·&nbsp;1 min</footer>
  <a class="entry-link" aria-label="post link to 打卡计划表" href="http://localhost:1313/posts/datastructalgorithm/%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92%E8%A1%A8/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">刷题方法
    </h2>
  </header>
  <div class="entry-content">
    <p>个人感悟和前言 刷了很多题（其实也不是很多，但却是每天坚持半小时坚持了一年多了）， 但是老是面试的时候做不出来，或者要花很长时间才能做出来。我都产生自我怀疑了，我觉得是时候换个方式了。 我问了gpt,它给了我很多建议，接下来我会按照下面的方式重新规划我的学习方法
以下大多数参考了gpt
具体的做法 核心目标 一、核心目标 用最少的题，建立最大迁移力。 熟练识别模板，能举一反三。 面试时 3 分钟内能讲清思路。 重点在模式识别 &#43; 模板迁移，不追数量。 二、15 道最值得复盘的模板题 类别 LeetCode题目 核心模板 可迁移方向 双指针 15. 三数之和 排序 &#43; 去重 &#43; 左右夹逼 k数之和 / 差值最接近 / 删除一个字符变回文 双指针 11. 盛最多水的容器 左右夹逼取最大面积 股票买卖、最优区间类问题 滑动窗口 3. 无重复字符的最长子串 扩展窗口 &#43; 收缩窗口 最小覆盖子串、最长K个不同字符子串 哈希 1. 两数之和 哈希反查 三数之和、四数之和、路径求和 栈 20. 有效的括号 栈匹配 HTML标签验证、栈逆序 单调栈 739. 每日温度 单调递减栈 下一个更大元素、柱状图最大矩形 链表 206. 反转链表 指针前后反转 k组反转、回文链表检测 链表 141. 环形链表 快慢指针 相交链表检测、寻找环入口 动态规划 53. 最大子序和 dp[i] = max(nums[i], dp[i-1]&#43;nums[i]) 股票最大利润、子数组和问题 动态规划 198. 打家劫舍 dp[i] = max(dp[i-1], dp[i-2]&#43;nums[i]) 环形打家劫舍、爬楼梯变体 动态规划 139. 单词拆分 dp[i] = dp[j] &amp;&amp; wordDict[j:i] 句子拼接、分割字符串最少次数 二分查找 33. 搜索旋转排序数组 二分判定区间有序性 搜索峰值、最小差距值 DFS/BFS 200. 岛屿数量 遍历连通块 图遍历、封闭区域数量、朋友圈问题 树 104. 二叉树最大深度 递归 DFS 平衡二叉树、路径和 树 236. 最近公共祖先 后序递归 目录树路径、最小公共节点类问题 三、偏题迁移示例 原题模板 面试偏题举例 迁移思路 无重复字符的最长子串 最多允许一个重复字符的最长子串 滑动窗口 &#43; 计数增加一层判断 三数之和 找出所有和为目标值的三元组 排序 &#43; 去重 &#43; 双指针，只改目标值逻辑 有效括号 字符串里只有 &lt; &gt;，规则不同 替换匹配规则即可，核心仍是栈 每日温度 求每个元素右边第一个比它小的元素 单调递增栈，方向反转 打家劫舍 环形排列的房屋 拆成两种情况：不偷第一 vs 不偷最后 单词拆分 计算所有可行的拆分方式 dp[i] 的基础上计数或回溯 二叉树最大深度 判断是否平衡二叉树 在返回深度的同时判断差值 最近公共祖先 N 叉树版本 递归逻辑相同，遍历子节点代替左右子树 四、陌生题分析框架（面试必备） 求最值 → 贪心 / 动态规划 求存在 → 哈希 / 二分 求路径 / 连通 → DFS / BFS 求配对 / 区间 → 双指针 / 滑动窗口 暴力解 &amp; 复杂度 先写最直接暴力解，作为 fallback 考虑优化方向（排序 / 哈希 / 双指针） 是否有重复子问题 有 → 动态规划 没有 → 贪心或暴力优化 输入结构 数组 → 排序 / 双指针 矩阵 → DFS / BFS 树 / 图 → 递归 / 队列 写伪代码 先讲思路，代码只是形式 面试官更关注分析能力 五、复盘计划（3 周周期） 周数 目标 内容 第1周 模板巩固 前8题（数组、链表、哈希、栈）二刷，写模板笔记 第2周 动态规划 &amp; 树 后7题二刷，形成 dp / 树模板总结 第3周 偏题迁移训练 每天抽一道陌生题，用陌生题分析框架解题，重点练思路，不追完美 六、Go 开发者模板代码示例 // 双指针模板 func twoSum(nums []int, target int) []int { m := make(map[int]int) for i, v := range nums { if j, ok := m[target-v]; ok { return []int{j, i} } m[v] = i } return nil } // 滑动窗口模板 func lengthOfLongestSubstring(s string) int { window := make(map[byte]int) left, right, res := 0, 0, 0 for right &lt; len(s) { c := s[right] right&#43;&#43; window[c]&#43;&#43; for window[c] &gt; 1 { d := s[left] left&#43;&#43; window[d]-- } if res &lt; right-left { res = right - left } } return res } // map 初始化 m := make(map[int]int) // set 用法 set := map[int]bool{} set[x] = true if set[y] { ... } // priority queue 模板 type Item struct{ value, priority int } type PQ []Item func (pq PQ) Len() int { return len(pq) } func (pq PQ) Less(i, j int) bool { return pq[i].priority &lt; pq[j].priority } func (pq PQ) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] } func (pq *PQ) Push(x any) { *pq = append(*pq, x.(Item)) } func (pq *PQ) Pop() any { old := *pq n := len(old) x := old[n-1] *pq = old[:n-1] return x } 七、最终目标 不靠“记题”，靠“识别结构 &#43; 套模板 &#43; 临场分析”。 偏题也能快速迁移思路，不慌张。 面试时有底气，3 分钟就能讲清解题思路。 </p>
  </div>
  <footer class="entry-footer"><span title='2025-10-15 21:31:14 +0800 CST'>October 15, 2025</span>&nbsp;·&nbsp;3 min</footer>
  <a class="entry-link" aria-label="post link to 刷题方法" href="http://localhost:1313/posts/datastructalgorithm/%E5%88%B7%E9%A2%98%E6%96%B9%E6%B3%95/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/posts/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="http://localhost:1313/posts/page/3/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="http://localhost:1313/">yangcp</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
