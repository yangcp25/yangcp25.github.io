<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Posts | yangcp</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - yangcp">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css" integrity="sha256-IhHKMWS&#43;eDACT2qtKzouUghDpk&#43;PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/posts/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="yangcp (Alt + H)">yangcp</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tag">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/me/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="http://localhost:1313/">Home</a></div>
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">排序算法总结
    </h2>
  </header>
  <div class="entry-content">
    <p>总结——所有常见排序算法的核心思想、时间复杂度、空间复杂度、稳定性、是否原地排序、适用场景和简单例子。 下面是最全面且面试导向的总结版本👇
🧠 排序算法总览表 算法 思想 时间复杂度 空间复杂度 稳定性 原地排序 适用场景 冒泡排序 (Bubble Sort) 相邻交换，最大（或最小）元素逐步“浮出” O(n²) O(1) ✅ 稳定 ✅ 数据量小、部分有序 选择排序 (Selection Sort) 每次选择最小元素放到前面 O(n²) O(1) ❌ 不稳定 ✅ 数据量小，对交换次数敏感 插入排序 (Insertion Sort) 将未排序元素插入到已排序序列中 O(n²) O(1) ✅ 稳定 ✅ 数据基本有序时高效 希尔排序 (Shell Sort) 插入排序的改进版，分组比较减少交换 O(n¹˙³~n²) O(1) ❌ 不稳定 ✅ 中等规模数据 归并排序 (Merge Sort) 分治 &#43; 合并有序子序列 O(n log n) O(n) ✅ 稳定 ❌ 大数据、外部排序 快速排序 (Quick Sort) 分治 &#43; 基准划分 平均 O(n log n)最坏 O(n²) O(log n) ❌ 不稳定 ✅ 通用最快的内部排序 堆排序 (Heap Sort) 利用堆结构维护最大/最小值 O(n log n) O(1) ❌ 不稳定 ✅ 需要快速找最大/最小的场景 计数排序 (Counting Sort) 统计每个元素出现次数 O(n &#43; k) O(n &#43; k) ✅ 稳定 ❌ 整数、范围较小的场景 桶排序 (Bucket Sort) 按区间划分多个桶再分别排序 O(n &#43; k) O(n &#43; k) ✅ 稳定（视子排序） ❌ 数据均匀分布的浮点数 基数排序 (Radix Sort) 按位（个位→高位）排序 O(d·(n&#43;k)) O(n &#43; k) ✅ 稳定 ❌ 整数、字符串排序 🔍 各算法核心思想讲解与代码示例 1️⃣ 冒泡排序 Bubble Sort 每一轮两两比较，把最大值“冒泡”到最后。
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-11-05 09:29:18 +0800 CST'>November 5, 2025</span>&nbsp;·&nbsp;5 min</footer>
  <a class="entry-link" aria-label="post link to 排序算法总结" href="http://localhost:1313/posts/datastructalgorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">内存分配
    </h2>
  </header>
  <div class="entry-content">
    <p>go的内存分配 根据对象大小的不同，go的内存分配有3种类型： Tiny(size &lt; 16B): Objects of size less than 16 bytes are allocated using the mcache’s tiny allocator. This is efficient and multiple tiny allocations are done on a single 16-byte block. Small(size 16B ~ 32KB): Objects of size between 16 bytes and 32 Kilobytes are allocated on the corresponding size class(mspan) on mcache of the P where the G is running. In both tiny and small allocation if the mspan’s list is empty the allocator will obtain a run of pages from the mheap to use for the mspan. If the mheap is empty or has no page runs large enough then it allocates a new group of pages (at least 1MB) from the OS. Large(size &gt; 32KB): Objects of size greater than 32 kilobytes are allocated directly on the corresponding size class of mheap. If the mheap is empty or has no page runs large enough then it allocates a new group of pages (at least 1MB) from the OS. 总结一下Go是如何进行内存分配: mcache中如果有空闲的空间， 那么直接在mcache分配 mcache如果没有，那么尝试去mcentral中获取一个空闲的mspan mcentral中也咩有可用的mspan，那么直接去mheap向操作系统申请可用的mspan
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-10-31 18:10:00 +0800 CST'>October 31, 2025</span>&nbsp;·&nbsp;2 min</footer>
  <a class="entry-link" aria-label="post link to 内存分配" href="http://localhost:1313/posts/go/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">sql高频题
    </h2>
  </header>
  <div class="entry-content">
    <p>分为六个维度：基础聚合 → 子查询 → TopN → 窗口函数 → 业务建模 → 性能优化。
🎯 高频 SQL 题库（含答案与思路） 一、基础聚合与分组（GROUP BY / HAVING） 🧩 题 1：查询每个部门的平均工资 表结构：
employee(emp_id, emp_name, dept_id, salary) SQL：
SELECT dept_id, AVG(salary) AS avg_salary FROM employee GROUP BY dept_id; 📘 考点： 聚合函数 &#43; 分组
🧩 题 2：查询带学生数超过 10 人的老师 teacher(teacher_id, name) student(student_id, teacher_id) SQL：
SELECT teacher_id, COUNT(*) AS student_count FROM student GROUP BY teacher_id HAVING COUNT(*) &gt; 10; 📘 考点： HAVING 与 WHERE 的区别（HAVING 针对聚合后过滤）
二、子查询（Subquery） 🧩 题 3：查询工资高于本部门平均工资的员工 SELECT e.emp_name, e.salary FROM employee e JOIN ( SELECT dept_id, AVG(salary) AS avg_salary FROM employee GROUP BY dept_id ) d ON e.dept_id = d.dept_id WHERE e.salary &gt; d.avg_salary; 📘 考点： 相关子查询 vs 非相关子查询
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-10-27 10:26:15 +0800 CST'>October 27, 2025</span>&nbsp;·&nbsp;3 min</footer>
  <a class="entry-link" aria-label="post link to sql高频题" href="http://localhost:1313/posts/sql/%E9%AB%98%E9%A2%91%E9%A2%98/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Liunx常用命令
    </h2>
  </header>
  <div class="entry-content">
    <p>Linux 中非常常用和基础的命令，按照功能进行了分类：
1. 文件和目录管理 ls (list)
作用：列出目录中的文件和子目录。 常用选项： ls -l：显示详细信息（权限、所有者、大小、修改日期）。 ls -a：显示所有文件，包括隐藏文件（以 . 开头的）。 ls -h：与 -l 配合使用，以人类可读的格式显示文件大小（如 1K, 2M, 3G）。 示例：ls -lah /home/user cd (change directory)
作用：切换当前工作目录。 常用用法： cd /var/log：切换到 /var/log 目录。 cd ..：切换到上一级目录。 cd ~ 或 cd：切换到当前用户的主目录。 cd -：切换到上一个工作目录。 pwd (print working directory)
作用：显示当前所在的目录路径。 mkdir (make directory)
作用：创建新目录。 常用选项： mkdir -p /path/to/new/dir：递归创建目录，如果父目录不存在也会一并创建。 示例：mkdir my_project rmdir (remove directory)
作用：删除空目录。 rm (remove)
作用：删除文件或目录。 常用选项： rm file.txt：删除一个文件。 rm -r directory_name：递归删除目录及其所有内容。 rm -f file.txt：强制删除，不进行提示。 rm -rf directory_name：（慎用！） 强制递归删除目录，不会有任何提示。 cp (copy)
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-10-26 19:15:43 +0800 CST'>October 26, 2025</span>&nbsp;·&nbsp;3 min</footer>
  <a class="entry-link" aria-label="post link to Liunx常用命令" href="http://localhost:1313/posts/cs/liunx%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Go 场景题模版
    </h2>
  </header>
  <div class="entry-content">
    <p>Go 场景题训练手册 — 题目版 作者：cp yang 说明：分为 初级 / 中级 / 高级 / 实战 Debug 四个章节。每题为面试常见场景题（用于练习）
🟢 初级场景题（语言特性与陷阱） 切片在函数参数传递时，什么时候会影响外部数据？请举例并解释。 for range vs for i := 0; i &lt; len(slice); i&#43;&#43;，在修改元素和效率上有什么区别？ map 初始化的正确写法有哪些？哪些写法会导致 panic？ defer 的执行顺序是什么？return 与 defer 的执行顺序如何？ append 扩容时如何影响底层数组？如何避免不必要的复制？ string 与 []byte 转换在高频场景下的性能问题如何优化？ 实现一个线程安全的简单 map（支持 Get/Set/Delete）。 🟡 中级场景题（并发与控制） 如何使用 sync.WaitGroup 控制并发任务？请给出示例，并说明常见错误。 设计一个固定大小的 goroutine 池（worker pool），能提交任务并等待完成。 设计一个生产者-消费者模型，支持多生产者、多消费者，并能优雅退出。 实现两个 goroutine 交替打印 1~100（A 打印 1，B 打印 2，依次交替）。 如何限制并发数量（例如同时最多 10 个任务）？给出实现。 使用 context 实现任务超时与取消，给出示例。 🔴 高级场景题（系统设计与性能） 设计一个本地缓存系统，支持 TTL、并发安全和定期清理。写出核心接口与实现要点。 设计并实现一个 LRU 缓存（map &#43; 双向链表），要求并发安全。 设计一个简易消息队列（支持发布/订阅、可持久化思路说明）。写出关键数据结构与伪码。 如何设计一个高并发的秒杀系统以防止超卖？给出架构思路与关键代码片段（Redis/本地预减库存等）。 设计一个限流组件（令牌桶），实现接口并说明在微服务网关如何使用。 ⚙️ 实战 Debug 场景题（排障与优化） 程序出现大量 goroutine 泄漏（数量不断增长），你如何排查？列出排查步骤与 pprof 使用方法。 出现死锁（程序卡住），如何定位和修复？给出示例代码及修改建议。 程序内存暴涨并触发 GC 压力，如何分析原因并给出优化方案？ 高并发下锁竞争严重（通过 Mutex 看到 QPS 降低），如何诊断并优化？ 使用 pprof 找到热点 CPU 占用点后，你会如何改进代码？给出一个简单示例。 </p>
  </div>
  <footer class="entry-footer"><span title='2025-10-22 22:38:03 +0800 CST'>October 22, 2025</span>&nbsp;·&nbsp;1 min</footer>
  <a class="entry-link" aria-label="post link to Go 场景题模版" href="http://localhost:1313/posts/scenario/%E5%9C%BA%E6%99%AF%E9%A2%98%E6%A8%A1%E7%89%88/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Go 场景题模版 — 答案版
    </h2>
  </header>
  <div class="entry-content">
    <p> 🟢 初级场景题（语言特性与陷阱） 1. 切片在函数参数传递时，什么时候会影响外部数据？ 思路： 切片是三元组（指针、len、cap）。传参时会拷贝这三项，但底层数组仍然共享。只有当 append 导致扩容（新的底层数组分配）或修改通过索引直接写入时，外部可见。
直接 s[i] = x 会影响外部； s = append(s, x) 当 cap 不足时会分配新数组，外部不会看到新元素。 示例代码：
package main import &#34;fmt&#34; func appendMaybe(s []int) []int { s = append(s, 100) // 若 cap 不足，这里会分配新底层数组 return s } func modify(s []int) { if len(s) &gt; 0 { s[0] = 999 // 修改共享底层数组 } } func main() { a := make([]int, 1, 1) a[0] = 1 b := appendMaybe(a) fmt.Println(&#34;a:&#34;, a) // 如果扩容发生，a 不包含 100 fmt.Println(&#34;b:&#34;, b) c := make([]int, 1, 2) c[0] = 1 d := appendMaybe(c) fmt.Println(&#34;c:&#34;, c) // cap 足够，c 会看到 append 的结果 (如果 append reuses) fmt.Println(&#34;d:&#34;, d) modify(a) fmt.Println(&#34;a after modify:&#34;, a) // 被修改 } 2. for range vs for i := 0; i &lt; len(slice); i&#43;&#43; 思路： for range 会在每次迭代时把元素拷贝到新的变量（v），因此直接修改 v 不会影响切片。索引访问 slice[i] 直接访问底层数组可以修改原值。性能上两者差异很小，除非元素为大结构体，range 会拷贝整个结构体。
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-10-22 22:38:00 +0800 CST'>October 22, 2025</span>&nbsp;·&nbsp;15 min</footer>
  <a class="entry-link" aria-label="post link to Go 场景题模版 — 答案版" href="http://localhost:1313/posts/scenario/%E5%9C%BA%E6%99%AF%E9%A2%98%E6%A8%A1%E7%89%88-%E7%AD%94%E6%A1%88/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">限流熔断降级
    </h2>
  </header>
  <div class="entry-content">
    <p> 「熔断、限流、降级」 它们都属于服务稳定性设计（Service Resilience）的一部分。
下面我给你一个“面试官喜欢听”的回答框架，从概念 → 场景 → 实现 → 举例 四步讲清楚， 适合百度这种系统架构导向的岗位 👇
🧩 一、三者区别和联系（高层答法） 一句话记忆：
限流：控制请求量，不让系统被压垮。 熔断：发现下游挂了，别再请求它。 降级：资源紧张时，主动牺牲部分功能，保证核心可用。 面试开头可以这样讲：
“在微服务架构下，我们通常通过限流、熔断、降级三种机制保障系统的稳定性。 三者的核心目标都是防止服务雪崩，只是介入的时机不同：
限流在请求入口处防止流量打爆； 熔断在调用链中断开异常依赖； 降级则在系统压力大时主动丢弃非核心功能。” ⚙️ 二、限流（Rate Limiting） 📘 概念 限制系统单位时间内可处理的请求数。
📍常见算法 固定窗口（Fixed Window） 滑动窗口（Sliding Window） 漏桶算法（Leaky Bucket） 令牌桶算法（Token Bucket）✅ 常用 令牌桶算法原理：系统按照固定速率生成令牌，请求只有拿到令牌才能执行，否则拒绝或排队。
🛠️ 实现方式 单机限流：用 golang.org/x/time/rate（Go官方限流包） 分布式限流：用 Redis 实现（Lua脚本保证原子性） 网关层限流：在 API Gateway（如 Kong、Nginx、Kratos Gateway）配置规则 💬 举例 “比如我在上一个项目中，为防止短信接口被刷，我们在 Nginx 层按 IP &#43; URI 做限流，用令牌桶算法控制速率为 10 req/s，多余的直接返回 429 Too Many Requests。”
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-10-22 17:18:39 +0800 CST'>October 22, 2025</span>&nbsp;·&nbsp;2 min</footer>
  <a class="entry-link" aria-label="post link to 限流熔断降级" href="http://localhost:1313/posts/microservice/%E9%99%90%E6%B5%81%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Init
    </h2>
  </header>
  <div class="entry-content">
    <p>✅ 一、init() 是什么 init() 是 Go 的特殊函数，用于在包被加载时自动执行初始化逻辑。 它不需要显式调用，也不能被其他代码调用。
✅ 二、init() 的基本特性 特性 说明 触发时机 在包被第一次导入时自动执行（只执行一次） 调用方式 Go runtime 自动调用，不能手动调用 参数 无参数 返回值 无返回值 作用范围 每个包可以定义多个 init() 函数 执行顺序 按照导入依赖关系和源码出现顺序执行 ✅ 三、最基本的例子 package main import &#34;fmt&#34; func init() { fmt.Println(&#34;init() called&#34;) } func main() { fmt.Println(&#34;main() called&#34;) } 输出：
init() called main() called ✅ init() 总是在 main() 之前执行。
✅ 四、包初始化顺序（重点） Go 程序启动时会按如下顺序执行：
导入依赖包 初始化依赖包的常量和变量 执行依赖包的 init() 函数 执行当前包的常量、变量初始化 执行当前包的 init() 函数 执行 main.main() 示例： // file: a.go package a import &#34;fmt&#34; var V = initVar() func initVar() int { fmt.Println(&#34;a.initVar()&#34;) return 42 } func init() { fmt.Println(&#34;a.init()&#34;) } // file: main.go package main import ( &#34;fmt&#34; &#34;example/a&#34; ) func init() { fmt.Println(&#34;main.init()&#34;) } func main() { fmt.Println(&#34;main.main()&#34;, a.V) } 输出：
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-10-22 09:59:13 +0800 CST'>October 22, 2025</span>&nbsp;·&nbsp;2 min</footer>
  <a class="entry-link" aria-label="post link to Init" href="http://localhost:1313/posts/go/init/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Defer
    </h2>
  </header>
  <div class="entry-content">
    <p>✅ 一、defer 的基本作用 defer 用来延迟执行一段函数调用，直到当前函数返回时才执行（无论是正常返回还是遇到 panic）。
示例： func main() { fmt.Println(&#34;A&#34;) defer fmt.Println(&#34;B&#34;) fmt.Println(&#34;C&#34;) } 输出：
A C B 👉 defer 的调用会在函数退出时执行。
✅ 二、多个 defer 的执行顺序：后进先出 (LIFO) func main() { defer fmt.Println(&#34;1&#34;) defer fmt.Println(&#34;2&#34;) defer fmt.Println(&#34;3&#34;) } 输出：
3 2 1 就像栈一样，最后注册的 defer 最先执行。
✅ 三、参数求值时机：defer 定义时就求值 这是一个非常重要的细节！
func main() { x := 10 defer fmt.Println(&#34;defer:&#34;, x) x = 20 fmt.Println(&#34;x =&#34;, x) } 输出：
x = 20 defer: 10 🔹 原因： defer 的参数会在注册 defer 时立刻求值，而不是在执行时求值。
✅ 四、闭包 defer：引用外部变量时会实时读取 func main() { x := 10 defer func() { fmt.Println(&#34;defer:&#34;, x) }() x = 20 fmt.Println(&#34;x =&#34;, x) } 输出：
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-10-22 09:58:12 +0800 CST'>October 22, 2025</span>&nbsp;·&nbsp;2 min</footer>
  <a class="entry-link" aria-label="post link to Defer" href="http://localhost:1313/posts/go/defer/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">算法题解题思路
    </h2>
  </header>
  <div class="entry-content">
    <p>一、常见题型与核心解法对应表 题型类别 常用解法 关键思维 常见题例 数组 / 序列类 双指针、滑动窗口、前缀和、单调栈 定长窗口 / 不定长窗口 三数之和、最大子序和、每日温度、接雨水 排序 / 查找类 快排、归并、二分查找 有序性 &#43; 区间分治 搜索插入位置、旋转数组最小值 动态规划（DP）类 状态转移 &#43; 子问题划分 “前 i 个…”、“以 i 结尾…” 打家劫舍、最大子序和、单词拆分、爬楼梯 字符串类 DP、双指针、哈希 子串、回文、匹配 最长回文子串、无重复子串长度 哈希 / 集合类 map &#43; 滑动窗口 存在性判断 两数之和、最长不重复子串 栈 / 队列类 单调栈、辅助栈、队列优化 “下一个更大元素” 有效括号、每日温度、接雨水 树 / 图类 DFS / BFS、递归 / 队列 遍历 &#43; 状态传递 二叉树最大深度、岛屿数量、最短路径 贪心类 局部最优 → 全局最优 排序 &#43; 选择 区间合并、跳跃游戏、分发糖果 数学类 模拟、整除、快速幂 数学规律化简 整数反转、Pow(x,n)、罗马数字转整数 二、陌生题分析框架（核心应对模板） 🧩 Step 1：先搞清问题类型 是否要求最值？
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-10-21 09:48:33 +0800 CST'>October 21, 2025</span>&nbsp;·&nbsp;3 min</footer>
  <a class="entry-link" aria-label="post link to 算法题解题思路" href="http://localhost:1313/posts/datastructalgorithm/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="http://localhost:1313/posts/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">yangcp</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
