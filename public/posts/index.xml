<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on yangcp</title><link>https://yangcp25.github.io/posts/</link><description>Recent content in Posts on yangcp</description><generator>Hugo -- 0.147.4</generator><language>zh-CN</language><lastBuildDate>Wed, 09 Jul 2025 09:20:50 +0800</lastBuildDate><atom:link href="https://yangcp25.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>BFS&amp;&amp;DFS</title><link>https://yangcp25.github.io/posts/bfs_dfs/</link><pubDate>Wed, 09 Jul 2025 09:20:50 +0800</pubDate><guid>https://yangcp25.github.io/posts/bfs_dfs/</guid><description>&lt;h3 id="树的遍历">树的遍历&lt;/h3>
&lt;h4 id="深度优先遍历dfs">深度优先遍历DFS&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="广度优先遍历bfs">广度优先遍历BFS&lt;/h4>
&lt;h4 id="根据先序遍历和中序遍历构造二叉树">根据先序遍历和中序遍历构造二叉树&lt;/h4>
&lt;h3 id="图的遍历">图的遍历&lt;/h3>
&lt;h4 id="深度优先遍历dfs-1">深度优先遍历DFS&lt;/h4>
&lt;h4 id="广度优先遍历bfs-1">广度优先遍历BFS&lt;/h4>
&lt;h4 id="带权图的最短路径算法-dijkstra">带权图的最短路径算法 dijkstra&lt;/h4></description></item><item><title>https原理</title><link>https://yangcp25.github.io/posts/https_2025-07-08/</link><pubDate>Tue, 08 Jul 2025 09:35:24 +0800</pubDate><guid>https://yangcp25.github.io/posts/https_2025-07-08/</guid><description>&lt;h2 id="定义">定义&lt;/h2>
&lt;h3 id="http">http&lt;/h3>
&lt;p>http是超文本传输协议，用于传输网页内容，它基于TCP，所以是可靠性传输。但是它没有解决数据安全性
方面的问题&lt;/p>
&lt;h3 id="http安全方面的问题">http安全方面的问题&lt;/h3>
&lt;ul>
&lt;li>http没有对数据进行加密，任何人都可以随意读取这些数据，遭成数据的泄密。&lt;/li>
&lt;li>其次没有认证，也就是没有办法知道数据来源的可靠性，攻击者可以中间人攻击来伪造数据&lt;/li>
&lt;li>数据完整性，任何人可以读取也可以修改数据&lt;/li>
&lt;/ul>
&lt;h3 id="https是什么">https是什么&lt;/h3>
&lt;p>https是http的安全版本，https基于ssl，ssl基于tls。http+数据加密+认证+数据完整性就是https。&lt;/p>
&lt;h3 id="https怎么解决的这些问题">https怎么解决的这些问题&lt;/h3>
&lt;h4 id="数据加密">数据加密&lt;/h4>
&lt;h5 id="加密算法">加密算法&lt;/h5>
&lt;p>加密算法分为对称加密和非对称加密，还有一些摘要算法 / 哈希算法，一下是一些常见的加密算法&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>示例&lt;/th>
&lt;th>是否可逆&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>对称加密&lt;/td>
&lt;td>DES / AES / 3DES&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>加密解密用同一密钥&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>非对称加密&lt;/td>
&lt;td>RSA / ECC&lt;/td>
&lt;td>✅&lt;/td>
&lt;td>公钥加密，私钥解密&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>摘要算法&lt;/td>
&lt;td>MD5 / SHA256&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>不可逆，用于校验完整性&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>签名算法&lt;/td>
&lt;td>DSA / RSA签名&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>用私钥签名，公钥验签&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>服务器端生成密钥对，将公钥发送给客户端，客户端使用公钥加密对称加密使用的秘钥，发送给服务器端，服务器端使用私钥解密数据，
得到秘钥，后续通过这个秘钥对数据进行加密解密。&lt;/p>
&lt;h4 id="ca">CA&lt;/h4>
&lt;p>CA（Certificate Authority）是证书颁发机构，它负责签发证书，并管理证书的颁发和吊销。&lt;/p>
&lt;h5 id="为什么需要ca">为什么需要CA&lt;/h5>
&lt;p>客户端无法知晓拿到的公钥是由目标服务器办法的，为了验证证书的合法性，防护中间人攻击，需要CA证书颁发机构签发证书。&lt;/p>
&lt;h5 id="证书生成">证书生成&lt;/h5>
&lt;p>首先，服务器管理员会向CA提起证书申请，CA会验证域名的所属权，做法通常是在域名解析加一个特定值。
验证通过后，CA会将服务器的公钥用自己的私钥进行签名，生成证书。并办法给服务器管理员。&lt;/p>
&lt;h5 id="证书验证过程">证书验证过程&lt;/h5>
&lt;p>客户端发起连接请求，服务器会返回证书，客户端会验证证书的合法性，并获取证书的公钥。
浏览器会在发版的时候将各大CA机构的公钥预制在浏览器中，使用CA的公钥对服务器的证书进行解密，拿到解密的hash值。同时
使用同样的摘要算法对原始内容进行加密，用得到的摘要和解密的摘要对比，如果相等，说明证书是CA颁发的，也就证明
了证书的合法性和完整性。&lt;/p></description></item><item><title>golang的interface和reflect</title><link>https://yangcp25.github.io/posts/2025-07-06/</link><pubDate>Sun, 06 Jul 2025 12:44:43 +0800</pubDate><guid>https://yangcp25.github.io/posts/2025-07-06/</guid><description>&lt;h2 id="interface">interface&lt;/h2>
&lt;h3 id="鸭子类型">鸭子类型&lt;/h3>
&lt;p>如果一个东西，走起来像鸭子，叫起来像鸭子，那么我们认为他就是鸭子。也就是说我们关注对象的行为，而不是对象本身。&lt;/p>
&lt;p>go里面通过接口来达到鸭子类型的效果。&lt;/p>
&lt;h3 id="多态">多态&lt;/h3>
&lt;p>多态是指同一个操作（函数、方法），在不通的对象的作用下，会有不同的行为。
一般多态有两种实现方式：&lt;/p>
&lt;ul>
&lt;li>继承和组合，比如java、c++。&lt;/li>
&lt;li>接口的形式&lt;/li>
&lt;/ul>
&lt;p>在go里面它没有继承的概念，但是go里面有组合。组合式是一种更灵活的方式。
他可以通过组合和重写来实现继承。在调用结构体的方法的时候，会优先调用最近的结构体的方法。
我们推荐在go里通过接口来实现多态，会更加清晰明了。&lt;/p>
&lt;h3 id="go的interface">go的interface&lt;/h3>
&lt;h4 id="定义">定义&lt;/h4>
&lt;p>go里面的接口是一种复合数据类型。他的底层有2种实现，&lt;code>eface&lt;/code>和&lt;code>iface&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//eface 结构&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">eface&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tab&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">typtab&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">data&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// iface结构&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">iface&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tab&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">itab&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">data&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>go里面的所有数据类型都实现了eface,也就是说可以借助interface来表示他的数据类型。
还可以通过interface来定义方法集合 。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">method&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可能你会有一个疑问，那go是怎么确定interface 到底应该是使用eface 还是 iface呢？
go是在编译阶段就会确定好interface 使用的eface 还是 iface。后面不会改变。&lt;/p>
&lt;h4 id="如何使用">如何使用&lt;/h4>
&lt;h5 id="什么时候会使用interface">什么时候会使用interface&lt;/h5>
&lt;ul>
&lt;li>通过接口来实现解耦合，比如依赖注入、适配器模式。&lt;/li>
&lt;li>不确定传入参数的类型，需要在运行时来确定。&lt;/li>
&lt;/ul>
&lt;h5 id="使用方法">使用方法&lt;/h5>
&lt;ul>
&lt;li>接口列表&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">animal&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">move&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">dog&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">d&lt;/span> &lt;span style="color:#a6e22e">dog&lt;/span>) &lt;span style="color:#a6e22e">move&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;dog moving&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">cat&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#a6e22e">cat&lt;/span>) &lt;span style="color:#a6e22e">move&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;cat moving&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#a6e22e">animal&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">a&lt;/span> = &lt;span style="color:#a6e22e">dog&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">a&lt;/span>.&lt;span style="color:#a6e22e">move&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">a&lt;/span> = &lt;span style="color:#a6e22e">cat&lt;/span>{} &lt;span style="color:#75715e">// a是结构可以同意调用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">a&lt;/span>.&lt;span style="color:#a6e22e">move&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 接口注入&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">call&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 不确定具体的参数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vat&lt;/span> &lt;span style="color:#a6e22e">func1&lt;/span> = &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">param&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">func1&lt;/span> = &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">param&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;call any&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">param&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">call&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#a6e22e">animal&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;call animal \n&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">a&lt;/span>.&lt;span style="color:#a6e22e">move&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="需要注意的点和坑">需要注意的点和坑&lt;/h4>
&lt;ul>
&lt;li>使用接口会让编译器无法确定数据类型，导致无法再编译阶段发现类型错误，引发运行时错误。&lt;/li>
&lt;li>使用接口会让程序变得难以阅读和理解。&lt;/li>
&lt;li>性能会损失大概一倍&lt;/li>
&lt;/ul>
&lt;h2 id="reflect">reflect&lt;/h2>
&lt;h4 id="unsafepointer">unsafe.pointer&lt;/h4>
&lt;p>go语言unsafe包提供了一些函数，可以获取指针，修改指针，获取指针指向的数据，修改指针指向的数据。
简单来讲，go本身不能操作指针，但是提供了reflect包让我们可以操作指针来获得程序的
性能提升。&lt;/p></description></item></channel></rss>