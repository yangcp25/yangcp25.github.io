<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Reflect on yangcp</title><link>https://yangcp25.github.io/tags/reflect/</link><description>Recent content in Reflect on yangcp</description><generator>Hugo -- 0.147.4</generator><language>zh-CN</language><lastBuildDate>Sun, 06 Jul 2025 12:44:43 +0800</lastBuildDate><atom:link href="https://yangcp25.github.io/tags/reflect/index.xml" rel="self" type="application/rss+xml"/><item><title>golang的interface和reflect</title><link>https://yangcp25.github.io/posts/2025-07-06/</link><pubDate>Sun, 06 Jul 2025 12:44:43 +0800</pubDate><guid>https://yangcp25.github.io/posts/2025-07-06/</guid><description>&lt;h2 id="interface">interface&lt;/h2>
&lt;h3 id="鸭子类型">鸭子类型&lt;/h3>
&lt;p>如果一个东西，走起来像鸭子，叫起来像鸭子，那么我们认为他就是鸭子。也就是说我们关注对象的行为，而不是对象本身。&lt;/p>
&lt;p>go里面通过接口来达到鸭子类型的效果。&lt;/p>
&lt;h3 id="多态">多态&lt;/h3>
&lt;p>多态是指同一个操作（函数、方法），在不通的对象的作用下，会有不同的行为。
一般多态有两种实现方式：&lt;/p>
&lt;ul>
&lt;li>继承和组合，比如java、c++。&lt;/li>
&lt;li>接口的形式&lt;/li>
&lt;/ul>
&lt;p>在go里面它没有继承的概念，但是go里面有组合。组合式是一种更灵活的方式。
他可以通过组合和重写来实现继承。在调用结构体的方法的时候，会优先调用最近的结构体的方法。
我们推荐在go里通过接口来实现多态，会更加清晰明了。&lt;/p>
&lt;h3 id="go的interface">go的interface&lt;/h3>
&lt;h4 id="定义">定义&lt;/h4>
&lt;p>go里面的接口是一种复合数据类型。他的底层有2种实现，&lt;code>eface&lt;/code>和&lt;code>iface&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//eface 结构&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">eface&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tab&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">typtab&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">data&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// iface结构&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">iface&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tab&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">itab&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">data&lt;/span> &lt;span style="color:#a6e22e">unsafe&lt;/span>.&lt;span style="color:#a6e22e">Pointer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>go里面的所有数据类型都实现了eface,也就是说可以借助interface来表示他的数据类型。
还可以通过interface来定义方法集合 。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">method&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可能你会有一个疑问，那go是怎么确定interface 到底应该是使用eface 还是 iface呢？
go是在编译阶段就会确定好interface 使用的eface 还是 iface。后面不会改变。&lt;/p>
&lt;h4 id="如何使用">如何使用&lt;/h4>
&lt;h5 id="什么时候会使用interface">什么时候会使用interface&lt;/h5>
&lt;ul>
&lt;li>通过接口来实现解耦合，比如依赖注入、适配器模式。&lt;/li>
&lt;li>不确定传入参数的类型，需要在运行时来确定。&lt;/li>
&lt;/ul>
&lt;h5 id="使用方法">使用方法&lt;/h5>
&lt;ul>
&lt;li>接口列表&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">animal&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">move&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">dog&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">d&lt;/span> &lt;span style="color:#a6e22e">dog&lt;/span>) &lt;span style="color:#a6e22e">move&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;dog moving&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">cat&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#a6e22e">cat&lt;/span>) &lt;span style="color:#a6e22e">move&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;cat moving&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#a6e22e">animal&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">a&lt;/span> = &lt;span style="color:#a6e22e">dog&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">a&lt;/span>.&lt;span style="color:#a6e22e">move&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">a&lt;/span> = &lt;span style="color:#a6e22e">cat&lt;/span>{} &lt;span style="color:#75715e">// a是结构可以同意调用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">a&lt;/span>.&lt;span style="color:#a6e22e">move&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 接口注入&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">call&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 不确定具体的参数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vat&lt;/span> &lt;span style="color:#a6e22e">func1&lt;/span> = &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">param&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">func1&lt;/span> = &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">param&lt;/span> &lt;span style="color:#66d9ef">any&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;call any&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">param&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">call&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#a6e22e">animal&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;call animal \n&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">a&lt;/span>.&lt;span style="color:#a6e22e">move&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="需要注意的点和坑">需要注意的点和坑&lt;/h4>
&lt;ul>
&lt;li>使用接口会让编译器无法确定数据类型，导致无法再编译阶段发现类型错误，引发运行时错误。&lt;/li>
&lt;li>使用接口会让程序变得难以阅读和理解。&lt;/li>
&lt;li>性能会损失大概一倍&lt;/li>
&lt;/ul>
&lt;h2 id="reflect">reflect&lt;/h2>
&lt;h4 id="unsafepointer">unsafe.pointer&lt;/h4>
&lt;p>go语言unsafe包提供了一些函数，可以获取指针，修改指针，获取指针指向的数据，修改指针指向的数据。
简单来讲，go本身不能操作指针，但是提供了reflect包让我们可以操作指针来获得程序的
性能提升。&lt;/p></description></item></channel></rss>