[{
"title":"Socket",
"permalink": "http://localhost:56264/posts/network/socket/",
"summary": "",
"content": " ",
"tags":null,
"categories":null
},{
"title":"BFS\u0026\u0026DFS",
"permalink": "http://localhost:56264/posts/bfs_dfs/",
"summary": "树的遍历 深度优先遍历DFS 广度优先遍历BFS 根据先序遍历和中序遍历构造二叉树 图的遍历 深度优先遍历DFS 广度优先遍历BFS 带权图的最短路径算法 dijkstra",
"content": "树的遍历 深度优先遍历DFS 广度优先遍历BFS 根据先序遍历和中序遍历构造二叉树 图的遍历 深度优先遍历DFS 广度优先遍历BFS 带权图的最短路径算法 dijkstra ",
"tags":["算法","数据结构","BFS","DFS","dijkstra"],
"categories":null
},{
"title":"https原理",
"permalink": "http://localhost:56264/posts/https_2025-07-08/",
"summary": "定义 http http是超文本传输协议，用于传输网页内容，它基于TCP，所以是可靠性传输。但是它没有解决数据安全性 方面的问题\nhttp安全方面的问题 http没有对数据进行加密，任何人都可以随意读取这些数据，遭成数据的泄密。 其次没有认证，也就是没有办法知道数据来源的可靠性，攻击者可以中间人攻击来伪造数据 数据完整性，任何人可以读取也可以修改数据 https是什么 https是http的安全版本，https基于ssl，ssl基于tls。http+数据加密+认证+数据完整性就是https。\nhttps怎么解决的这些问题 数据加密 加密算法 加密算法分为对称加密和非对称加密，还有一些摘要算法 / 哈希算法，一下是一些常见的加密算法\n类型 示例 是否可逆 说明 对称加密 DES / AES / 3DES ✅ 加密解密用同一密钥 非对称加密 RSA / ECC ✅ 公钥加密，私钥解密 摘要算法 MD5 / SHA256 ❌ 不可逆，用于校验完整性 签名算法 DSA / RSA签名 ❌ 用私钥签名，公钥验签 服务器端生成密钥对，将公钥发送给客户端，客户端使用公钥加密对称加密使用的秘钥，发送给服务器端，服务器端使用私钥解密数据， 得到秘钥，后续通过这个秘钥对数据进行加密解密。\nCA CA（Certificate Authority）是证书颁发机构，它负责签发证书，并管理证书的颁发和吊销。\n为什么需要CA 客户端无法知晓拿到的公钥是由目标服务器办法的，为了验证证书的合法性，防护中间人攻击，需要CA证书颁发机构签发证书。\n证书生成 首先，服务器管理员会向CA提起证书申请，CA会验证域名的所属权，做法通常是在域名解析加一个特定值。 验证通过后，CA会将服务器的公钥用自己的私钥进行签名，生成证书。并办法给服务器管理员。\n证书验证过程 客户端发起连接请求，服务器会返回证书，客户端会验证证书的合法性，并获取证书的公钥。 浏览器会在发版的时候将各大CA机构的公钥预制在浏览器中，使用CA的公钥对服务器的证书进行解密，拿到解密的hash值。同时 使用同样的摘要算法对原始内容进行加密，用得到的摘要和解密的摘要对比，如果相等，说明证书是CA颁发的，也就证明 了证书的合法性和完整性。\n",
"content": "定义 http http是超文本传输协议，用于传输网页内容，它基于TCP，所以是可靠性传输。但是它没有解决数据安全性 方面的问题\nhttp安全方面的问题 http没有对数据进行加密，任何人都可以随意读取这些数据，遭成数据的泄密。 其次没有认证，也就是没有办法知道数据来源的可靠性，攻击者可以中间人攻击来伪造数据 数据完整性，任何人可以读取也可以修改数据 https是什么 https是http的安全版本，https基于ssl，ssl基于tls。http+数据加密+认证+数据完整性就是https。\nhttps怎么解决的这些问题 数据加密 加密算法 加密算法分为对称加密和非对称加密，还有一些摘要算法 / 哈希算法，一下是一些常见的加密算法\n类型 示例 是否可逆 说明 对称加密 DES / AES / 3DES ✅ 加密解密用同一密钥 非对称加密 RSA / ECC ✅ 公钥加密，私钥解密 摘要算法 MD5 / SHA256 ❌ 不可逆，用于校验完整性 签名算法 DSA / RSA签名 ❌ 用私钥签名，公钥验签 服务器端生成密钥对，将公钥发送给客户端，客户端使用公钥加密对称加密使用的秘钥，发送给服务器端，服务器端使用私钥解密数据， 得到秘钥，后续通过这个秘钥对数据进行加密解密。\nCA CA（Certificate Authority）是证书颁发机构，它负责签发证书，并管理证书的颁发和吊销。\n为什么需要CA 客户端无法知晓拿到的公钥是由目标服务器办法的，为了验证证书的合法性，防护中间人攻击，需要CA证书颁发机构签发证书。\n证书生成 首先，服务器管理员会向CA提起证书申请，CA会验证域名的所属权，做法通常是在域名解析加一个特定值。 验证通过后，CA会将服务器的公钥用自己的私钥进行签名，生成证书。并办法给服务器管理员。\n证书验证过程 客户端发起连接请求，服务器会返回证书，客户端会验证证书的合法性，并获取证书的公钥。 浏览器会在发版的时候将各大CA机构的公钥预制在浏览器中，使用CA的公钥对服务器的证书进行解密，拿到解密的hash值。同时 使用同样的摘要算法对原始内容进行加密，用得到的摘要和解密的摘要对比，如果相等，说明证书是CA颁发的，也就证明 了证书的合法性和完整性。\n",
"tags":["计算机网络","https"],
"categories":null
},{
"title":"About Me",
"permalink": "http://localhost:56264/about/me/",
"summary": " 三年PHP经验，2年全栈经验，三年golang经验，持续学习中\u0026hellip; ",
"content": " 三年PHP经验，2年全栈经验，三年golang经验，持续学习中\u0026hellip; ",
"tags":null,
"categories":null
},{
"title":"golang的interface和reflect",
"permalink": "http://localhost:56264/posts/2025-07-06/",
"summary": "interface 鸭子类型 如果一个东西，走起来像鸭子，叫起来像鸭子，那么我们认为他就是鸭子。也就是说我们关注对象的行为，而不是对象本身。\ngo里面通过接口来达到鸭子类型的效果。\n多态 多态是指同一个操作（函数、方法），在不通的对象的作用下，会有不同的行为。 一般多态有两种实现方式：\n继承和组合，比如java、c++。 接口的形式 在go里面它没有继承的概念，但是go里面有组合。组合式是一种更灵活的方式。 他可以通过组合和重写来实现继承。在调用结构体的方法的时候，会优先调用最近的结构体的方法。 我们推荐在go里通过接口来实现多态，会更加清晰明了。\ngo的interface 定义 go里面的接口是一种复合数据类型。他的底层有2种实现，eface和iface。\n//eface 结构 type eface struct { tab *typtab data unsafe.Pointer } // iface结构 type iface struct { tab *itab data unsafe.Pointer } go里面的所有数据类型都实现了eface,也就是说可以借助interface来表示他的数据类型。 还可以通过interface来定义方法集合 。\ntype A interface { method() } 可能你会有一个疑问，那go是怎么确定interface 到底应该是使用eface 还是 iface呢？ go是在编译阶段就会确定好interface 使用的eface 还是 iface。后面不会改变。\n如何使用 什么时候会使用interface 通过接口来实现解耦合，比如依赖注入、适配器模式。 不确定传入参数的类型，需要在运行时来确定。 使用方法 接口列表 type animal interface { move() } type dog struct {} func (d dog) move() { fmt.Println(\u0026#34;dog moving\u0026#34;) } type cat struct {} func (c cat) move() { fmt.Println(\u0026#34;cat moving\u0026#34;) } func main() { var a animal a = dog{} a.move() a = cat{} // a是结构可以同意调用 a.move() // 接口注入 call(a) // 不确定具体的参数 vat func1 = func(param any) {} func1 = func(param any) { fmt.Println(\u0026#34;call any\u0026#34;, param) } } func call(a animal) { fmt.Println(\u0026#34;call animal \\n\u0026#34;) a.move() } 需要注意的点和坑 使用接口会让编译器无法确定数据类型，导致无法再编译阶段发现类型错误，引发运行时错误。 使用接口会让程序变得难以阅读和理解。 性能会损失大概一倍 reflect unsafe.pointer go语言unsafe包提供了一些函数，可以获取指针，修改指针，获取指针指向的数据，修改指针指向的数据。 简单来讲，go本身不能操作指针，但是提供了reflect包让我们可以操作指针来获得程序的 性能提升。\n",
"content": "interface 鸭子类型 如果一个东西，走起来像鸭子，叫起来像鸭子，那么我们认为他就是鸭子。也就是说我们关注对象的行为，而不是对象本身。\ngo里面通过接口来达到鸭子类型的效果。\n多态 多态是指同一个操作（函数、方法），在不通的对象的作用下，会有不同的行为。 一般多态有两种实现方式：\n继承和组合，比如java、c++。 接口的形式 在go里面它没有继承的概念，但是go里面有组合。组合式是一种更灵活的方式。 他可以通过组合和重写来实现继承。在调用结构体的方法的时候，会优先调用最近的结构体的方法。 我们推荐在go里通过接口来实现多态，会更加清晰明了。\ngo的interface 定义 go里面的接口是一种复合数据类型。他的底层有2种实现，eface和iface。\n//eface 结构 type eface struct { tab *typtab data unsafe.Pointer } // iface结构 type iface struct { tab *itab data unsafe.Pointer } go里面的所有数据类型都实现了eface,也就是说可以借助interface来表示他的数据类型。 还可以通过interface来定义方法集合 。\ntype A interface { method() } 可能你会有一个疑问，那go是怎么确定interface 到底应该是使用eface 还是 iface呢？ go是在编译阶段就会确定好interface 使用的eface 还是 iface。后面不会改变。\n如何使用 什么时候会使用interface 通过接口来实现解耦合，比如依赖注入、适配器模式。 不确定传入参数的类型，需要在运行时来确定。 使用方法 接口列表 type animal interface { move() } type dog struct {} func (d dog) move() { fmt.Println(\u0026#34;dog moving\u0026#34;) } type cat struct {} func (c cat) move() { fmt.Println(\u0026#34;cat moving\u0026#34;) } func main() { var a animal a = dog{} a.move() a = cat{} // a是结构可以同意调用 a.move() // 接口注入 call(a) // 不确定具体的参数 vat func1 = func(param any) {} func1 = func(param any) { fmt.Println(\u0026#34;call any\u0026#34;, param) } } func call(a animal) { fmt.Println(\u0026#34;call animal \\n\u0026#34;) a.move() } 需要注意的点和坑 使用接口会让编译器无法确定数据类型，导致无法再编译阶段发现类型错误，引发运行时错误。 使用接口会让程序变得难以阅读和理解。 性能会损失大概一倍 reflect unsafe.pointer go语言unsafe包提供了一些函数，可以获取指针，修改指针，获取指针指向的数据，修改指针指向的数据。 简单来讲，go本身不能操作指针，但是提供了reflect包让我们可以操作指针来获得程序的 性能提升。\n定义 在计算机领域，反射（Reflection）是指程序在运行时能够检查自身，并获取其内部信息。可以修改数据，调用方法的 一种能力。 go语言提供了一种在运行时能够获取数据本身的状态，数据，和调用方法的能力，在编译阶段 是不知道具体的类型的，需要在运行时确定。\n使用 常见使用场景 函数参数的动态传入，通过reflect获取参数的类型 动态修改切片，map，结构体 动态创建函数 GORM,通过反射获取结构体的tag来构建数据的sql语句 使用方法 reflect.ValueOf(a) reflect.TypeOf((a) 对指针解引用 reflect.ValueOf(a).Elem() 获取指针类型 reflect.TypeOf(a).Elem() 获取tag reflect.TypeOf(a).Elem().Field(0).Tag.Get(\u0026#34;json\u0026#34;) 获取字段 reflect.TypeOf(a).Elem().Field(0) 动态创建函数 func1 := reflect.MakeFunc(reflect.TypeOf(func(param any) {}), func(args []reflect.Value) []reflect.Value {}) // 动态调用函数 func1.Call([]reflect.Value{reflect.ValueOf(param)}) 需要注意的点和坑 使用反射会损失性能 使用反射会改变代码的可读性 编译器不能检查数据类型，会引发运行时错误 ",
"tags":["go","interface","reflect"],
"categories":null
}]