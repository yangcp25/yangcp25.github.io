[{
"title":"CAP",
"permalink": "http://localhost:1313/posts/architecture/cap/",
"summary": "定义 CAP理论是指分布式当中一致性、可用性以及分区容错性三者不可兼得。我们需要根据实际应用场景做出相应的取舍， 其中在现实中，分布式系统中的网络是不可能完全保证可用的，所以就需要在CP和AP中做出选择。\n实践 常见的使用场景 一些常见的开源软件的使用我们会经常遇到这个场景。拿最常见的redis为例，redis的分布式部署方案有三种，主从、哨兵、cluster。\n注意事项 这个理论提醒我们在分布式系统中需要根据具体的需求做出取舍。\nredis分布式锁在分布式部署情况下的问题 简单来说需要把所有锁操作限定到一个槽里面，其次可以使用开源的解决方案比如redlock,以及优秀的redis客户端在发生key在其他节点会自动帮助我们 处理move操作\n参考资料 维基百科编者. CAP定理. 维基百科. 最后修订于2023年11月9日. 访问于2025年7月16日. ",
"content": "定义 CAP理论是指分布式当中一致性、可用性以及分区容错性三者不可兼得。我们需要根据实际应用场景做出相应的取舍， 其中在现实中，分布式系统中的网络是不可能完全保证可用的，所以就需要在CP和AP中做出选择。\n实践 常见的使用场景 一些常见的开源软件的使用我们会经常遇到这个场景。拿最常见的redis为例，redis的分布式部署方案有三种，主从、哨兵、cluster。\n注意事项 这个理论提醒我们在分布式系统中需要根据具体的需求做出取舍。\nredis分布式锁在分布式部署情况下的问题 简单来说需要把所有锁操作限定到一个槽里面，其次可以使用开源的解决方案比如redlock,以及优秀的redis客户端在发生key在其他节点会自动帮助我们 处理move操作\n参考资料 维基百科编者. CAP定理. 维基百科. 最后修订于2023年11月9日. 访问于2025年7月16日. ",
"tags":null,
"categories":null
},{
"title":"HeapSort",
"permalink": "http://localhost:1313/posts/datastructalgorithm/heapsort/",
"summary": "pSort 堆排序 我发现字节好像很喜欢考这个堆排序，再结合一些其他的场景，所以这里做下堆排序相关的总结。\n通用写法 ```\u0000\u0000\u0000\u0000\u0000\u0000\u0000 ",
"content": "pSort 堆排序 我发现字节好像很喜欢考这个堆排序，再结合一些其他的场景，所以这里做下堆排序相关的总结。\n通用写法 ```\u0000\u0000\u0000\u0000\u0000\u0000\u0000 ",
"tags":null,
"categories":null
},{
"title":"Socket",
"permalink": "http://localhost:1313/posts/network/socket/",
"summary": "Socket IO模型 常见的IO模型有四种：多进程、多线程、IO复用、协程\n多进程：最原始的一种模式，好处是开发难度小，同一个进程共享内容，缺点是创建和销毁的成本很高。常见的比如php的php-fpm 多线程：相比于多进程开销更小，但是遇到C10K问题还是会出现瓶颈，线程的内存占用通常以M为单位。提高了效率，但是遇到高并发，资源占用还是比较大。常见的比如java的多线程 IO模型: 基于事件的IO处理机制，是单线程模型，通过监听文件句柄socket,注册事件， 当有IO事件发生时，会触发回调函数。由于在单线程模型，开销更小，适合处理高并发。常见的如nodejs、redis。 协程: 协程是态线程，协程的切换开销小，通常以kb为单位，通常一个协程只占用4KB，适合处理高并发。常见的如go语言。 Socket定义 socket是应用层和传输层的一组API接口，用于实现网络通信。 linux当中一切皆文件，操作系统为了统一处理IO模型，将socket也视作文件句柄。\n特性 普通文件 Socket（网络文件） 底层对象 struct inode + struct file struct socket + struct file 操作集 read/write 操作读写磁盘数据 recv/send（也支持 read/write，最终映射到网络收发） 偏移量（offset） 有，指示文件读写位置 无意义，总是以流／报文方式收发 阻塞／非阻塞 可设置阻塞或非阻塞 同样支持阻塞模式和非阻塞模式 I/O 多路复用 支持 select/poll/epoll 完全支持 通过监听文件句柄，结合select/pull/epoll, 可以实现网络编程。\nwebsocket websocket是一种基于http的协议，用于浏览器和服务器之间进行长连接实时通信。一般会通过对http请求升级upgrade，将http协议升级为websocket协议。\n如何使用 tcp连接需要指定五元组：ip、端口、协议、源ip、源端口，同样的socket也需要指定这些参数。 server端的建立过程：\nsocket() bind() listen() accept() close client端的建立过程：\nsocket() connect() accept() close() 代码示例 原始方案，使用net包:\nsever端\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;syscall\u0026#34; ) func check(err error) { if err != nil { fmt.Fprintln(os.Stderr, \u0026#34;错误：\u0026#34;, err) os.Exit(1) } } func main() { // 1. 创建 socket fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, syscall.IPPROTO_TCP) check(err) defer syscall.Close(fd) // 2. 绑定到本地地址 0.0.0.0:8888 sa := \u0026amp;syscall.SockaddrInet4{Port: 8888} // IP 全 0 表示 INADDR_ANY check(syscall.Bind(fd, sa)) // 3. 开始监听（backlog 128） check(syscall.Listen(fd, 128)) fmt.Println(\u0026#34;raw socket 服务器已启动，端口 8888\u0026#34;) // 4. 接受连接 nfd, rsa, err := syscall.Accept(fd) check(err) fmt.Printf(\u0026#34;接收到客户端：%v\\n\u0026#34;, rsa) defer syscall.Close(nfd) // 5. 全双工：一个 goroutine 从 stdin 发出去，一个 goroutine 从 socket 读进来 go func() { buf := make([]byte, 1024) for { // 从标准输入读 n, err := syscall.Read(syscall.Stdin, buf) if err != nil { fmt.Fprintln(os.Stderr, \u0026#34;stdin 读取错误：\u0026#34;, err) return } if n \u0026gt; 0 { _, err = syscall.Write(nfd, buf[:n]) if err != nil { fmt.Fprintln(os.Stderr, \u0026#34;向客户端写入错误：\u0026#34;, err) return } } } }() // 主 goroutine 负责从 socket 读并写到 stdout buf := make([]byte, 1024) for { n, err := syscall.Read(nfd, buf) if err != nil { fmt.Fprintln(os.Stderr, \u0026#34;从客户端读取错误：\u0026#34;, err) return } if n \u0026gt; 0 { // 打印到标准输出 _, err = syscall.Write(syscall.Stdout, buf[:n]) if err != nil { fmt.Fprintln(os.Stderr, \u0026#34;写到 stdout 错误：\u0026#34;, err) return } } } } client端\n",
"content": "Socket IO模型 常见的IO模型有四种：多进程、多线程、IO复用、协程\n多进程：最原始的一种模式，好处是开发难度小，同一个进程共享内容，缺点是创建和销毁的成本很高。常见的比如php的php-fpm 多线程：相比于多进程开销更小，但是遇到C10K问题还是会出现瓶颈，线程的内存占用通常以M为单位。提高了效率，但是遇到高并发，资源占用还是比较大。常见的比如java的多线程 IO模型: 基于事件的IO处理机制，是单线程模型，通过监听文件句柄socket,注册事件， 当有IO事件发生时，会触发回调函数。由于在单线程模型，开销更小，适合处理高并发。常见的如nodejs、redis。 协程: 协程是态线程，协程的切换开销小，通常以kb为单位，通常一个协程只占用4KB，适合处理高并发。常见的如go语言。 Socket定义 socket是应用层和传输层的一组API接口，用于实现网络通信。 linux当中一切皆文件，操作系统为了统一处理IO模型，将socket也视作文件句柄。\n特性 普通文件 Socket（网络文件） 底层对象 struct inode + struct file struct socket + struct file 操作集 read/write 操作读写磁盘数据 recv/send（也支持 read/write，最终映射到网络收发） 偏移量（offset） 有，指示文件读写位置 无意义，总是以流／报文方式收发 阻塞／非阻塞 可设置阻塞或非阻塞 同样支持阻塞模式和非阻塞模式 I/O 多路复用 支持 select/poll/epoll 完全支持 通过监听文件句柄，结合select/pull/epoll, 可以实现网络编程。\nwebsocket websocket是一种基于http的协议，用于浏览器和服务器之间进行长连接实时通信。一般会通过对http请求升级upgrade，将http协议升级为websocket协议。\n如何使用 tcp连接需要指定五元组：ip、端口、协议、源ip、源端口，同样的socket也需要指定这些参数。 server端的建立过程：\nsocket() bind() listen() accept() close client端的建立过程：\nsocket() connect() accept() close() 代码示例 原始方案，使用net包:\nsever端\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;syscall\u0026#34; ) func check(err error) { if err != nil { fmt.Fprintln(os.Stderr, \u0026#34;错误：\u0026#34;, err) os.Exit(1) } } func main() { // 1. 创建 socket fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, syscall.IPPROTO_TCP) check(err) defer syscall.Close(fd) // 2. 绑定到本地地址 0.0.0.0:8888 sa := \u0026amp;syscall.SockaddrInet4{Port: 8888} // IP 全 0 表示 INADDR_ANY check(syscall.Bind(fd, sa)) // 3. 开始监听（backlog 128） check(syscall.Listen(fd, 128)) fmt.Println(\u0026#34;raw socket 服务器已启动，端口 8888\u0026#34;) // 4. 接受连接 nfd, rsa, err := syscall.Accept(fd) check(err) fmt.Printf(\u0026#34;接收到客户端：%v\\n\u0026#34;, rsa) defer syscall.Close(nfd) // 5. 全双工：一个 goroutine 从 stdin 发出去，一个 goroutine 从 socket 读进来 go func() { buf := make([]byte, 1024) for { // 从标准输入读 n, err := syscall.Read(syscall.Stdin, buf) if err != nil { fmt.Fprintln(os.Stderr, \u0026#34;stdin 读取错误：\u0026#34;, err) return } if n \u0026gt; 0 { _, err = syscall.Write(nfd, buf[:n]) if err != nil { fmt.Fprintln(os.Stderr, \u0026#34;向客户端写入错误：\u0026#34;, err) return } } } }() // 主 goroutine 负责从 socket 读并写到 stdout buf := make([]byte, 1024) for { n, err := syscall.Read(nfd, buf) if err != nil { fmt.Fprintln(os.Stderr, \u0026#34;从客户端读取错误：\u0026#34;, err) return } if n \u0026gt; 0 { // 打印到标准输出 _, err = syscall.Write(syscall.Stdout, buf[:n]) if err != nil { fmt.Fprintln(os.Stderr, \u0026#34;写到 stdout 错误：\u0026#34;, err) return } } } } client端\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;syscall\u0026#34; ) func check(err error) { if err != nil { fmt.Fprintln(os.Stderr, \u0026#34;错误：\u0026#34;, err) os.Exit(1) } } func main() { // 1. 创建 socket fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, syscall.IPPROTO_TCP) check(err) defer syscall.Close(fd) // 2. 连接到服务器 127.0.0.1:8888 sa := \u0026amp;syscall.SockaddrInet4{Port: 8888} copy(sa.Addr[:], []byte{127, 0, 0, 1}) check(syscall.Connect(fd, sa)) fmt.Println(\u0026#34;raw socket 已连接到 127.0.0.1:8888\u0026#34;) // 3. 全双工：一个 goroutine 从 stdin 发出去，一个从 socket 读进来 go func() { buf := make([]byte, 1024) for { n, err := syscall.Read(syscall.Stdin, buf) if err != nil { fmt.Fprintln(os.Stderr, \u0026#34;stdin 读取错误：\u0026#34;, err) return } if n \u0026gt; 0 { _, err = syscall.Write(fd, buf[:n]) if err != nil { fmt.Fprintln(os.Stderr, \u0026#34;写到服务器错误：\u0026#34;, err) return } } } }() // 主 goroutine 负责从 socket 读并写到 stdout buf := make([]byte, 1024) for { n, err := syscall.Read(fd, buf) if err != nil { fmt.Fprintln(os.Stderr, \u0026#34;从服务器读取错误：\u0026#34;, err) return } if n \u0026gt; 0 { _, err = syscall.Write(syscall.Stdout, buf[:n]) if err != nil { fmt.Fprintln(os.Stderr, \u0026#34;写到 stdout 错误：\u0026#34;, err) return } } } } 封装成net包，代码更简洁。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; ) func main() { // socket bind listen con, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:8099\u0026#34;) if err != nil { panic(err) } conn, err := con.Accept() go func() { if _, err := io.Copy(conn, os.Stdin); err != nil { fmt.Errorf(\u0026#34;server to client :%w\u0026#34;, err) } }() if _, err := io.Copy(os.Stdout, conn); err != nil { fmt.Errorf(\u0026#34;from client :%w\u0026#34;, err) } } client端\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; ) func main() { // socket connect conn, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;:8099\u0026#34;) if err != nil { panic(err) } go func() { if _, err := io.Copy(conn, os.Stdin); err != nil { fmt.Errorf(\u0026#34; to server :%w\u0026#34;, err) } }() if _, err := io.Copy(os.Stdout, conn); err != nil { fmt.Errorf(\u0026#34;from server :%w\u0026#34;, err) } } 注意事项 注意关闭文件句柄 实现高可用，需要处理重试逻辑 ",
"tags":null,
"categories":null
},{
"title":"BFS\u0026\u0026DFS",
"permalink": "http://localhost:1313/posts/datastructalgorithm/bfs_dfs/",
"summary": "树的遍历 深度优先遍历DFS package main import \u0026#34;fmt\u0026#34; func main() { root := \u0026amp;TreeNode{ Val: 1, } root.Left = \u0026amp;TreeNode{Val: 2} root.Right = \u0026amp;TreeNode{Val: 3} root.Right.Left = \u0026amp;TreeNode{Val: 4} root.Left.Left = \u0026amp;TreeNode{Val: 5} list := make([]int, 0) var treeDFS = func(root *TreeNode) {} treeDFS = func(root *TreeNode) { if root == nil { return } list = append(list, root.Val) treeDFS(root.Left) treeDFS(root.Right) } treeDFS(root) fmt.Println(list) //list2 := TreeBFS(root) //fmt.Println(list2) } type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 函数版本\npackage main import \u0026#34;fmt\u0026#34; func main() { root := \u0026amp;TreeNode{ Val: 1, } root.Left = \u0026amp;TreeNode{Val: 2} root.Right = \u0026amp;TreeNode{Val: 3} root.Right.Left = \u0026amp;TreeNode{Val: 4} root.Left.Left = \u0026amp;TreeNode{Val: 5} list := make([]int, 0) TreeDFS(root, \u0026amp;list) fmt.Println(list) //list2 := TreeBFS(root) //fmt.Println(list2) } func TreeDFS(root *TreeNode, list *[]int) { if root == nil { return } *list = append(*list, root.Val) TreeDFS(root.Left, list) TreeDFS(root.Right, list) } type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 广度优先遍历BFS list2 := make([]int, 0) queue := make([]*TreeNode, 0) queue = append(queue, root) for len(queue) \u0026gt; 0 { count := len(queue) for i := 0; i \u0026lt; count; i++ { node := queue[0] queue = queue[1:] list2 = append(list2, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } fmt.Println(list2) 根据先序遍历和中序遍历构造二叉树 图的遍历 深度优先遍历DFS 广度优先遍历BFS 带权图的最短路径算法 dijkstra",
"content": "树的遍历 深度优先遍历DFS package main import \u0026#34;fmt\u0026#34; func main() { root := \u0026amp;TreeNode{ Val: 1, } root.Left = \u0026amp;TreeNode{Val: 2} root.Right = \u0026amp;TreeNode{Val: 3} root.Right.Left = \u0026amp;TreeNode{Val: 4} root.Left.Left = \u0026amp;TreeNode{Val: 5} list := make([]int, 0) var treeDFS = func(root *TreeNode) {} treeDFS = func(root *TreeNode) { if root == nil { return } list = append(list, root.Val) treeDFS(root.Left) treeDFS(root.Right) } treeDFS(root) fmt.Println(list) //list2 := TreeBFS(root) //fmt.Println(list2) } type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 函数版本\npackage main import \u0026#34;fmt\u0026#34; func main() { root := \u0026amp;TreeNode{ Val: 1, } root.Left = \u0026amp;TreeNode{Val: 2} root.Right = \u0026amp;TreeNode{Val: 3} root.Right.Left = \u0026amp;TreeNode{Val: 4} root.Left.Left = \u0026amp;TreeNode{Val: 5} list := make([]int, 0) TreeDFS(root, \u0026amp;list) fmt.Println(list) //list2 := TreeBFS(root) //fmt.Println(list2) } func TreeDFS(root *TreeNode, list *[]int) { if root == nil { return } *list = append(*list, root.Val) TreeDFS(root.Left, list) TreeDFS(root.Right, list) } type TreeNode struct { Val int Left *TreeNode Right *TreeNode } 广度优先遍历BFS list2 := make([]int, 0) queue := make([]*TreeNode, 0) queue = append(queue, root) for len(queue) \u0026gt; 0 { count := len(queue) for i := 0; i \u0026lt; count; i++ { node := queue[0] queue = queue[1:] list2 = append(list2, node.Val) if node.Left != nil { queue = append(queue, node.Left) } if node.Right != nil { queue = append(queue, node.Right) } } } fmt.Println(list2) 根据先序遍历和中序遍历构造二叉树 图的遍历 深度优先遍历DFS 广度优先遍历BFS 带权图的最短路径算法 dijkstra ",
"tags":["算法","数据结构","BFS","DFS","dijkstra"],
"categories":null
},{
"title":"https原理",
"permalink": "http://localhost:1313/posts/network/https/",
"summary": "定义 http http是超文本传输协议，用于传输网页内容，它基于TCP，所以是可靠性传输。但是它没有解决数据安全性 方面的问题\nhttp安全方面的问题 http没有对数据进行加密，任何人都可以随意读取这些数据，遭成数据的泄密。 其次没有认证，也就是没有办法知道数据来源的可靠性，攻击者可以中间人攻击来伪造数据 数据完整性，任何人可以读取也可以修改数据 https是什么 https是http的安全版本，https基于ssl，ssl基于tls。http+数据加密+认证+数据完整性就是https。\nhttps怎么解决的这些问题 数据加密 加密算法 加密算法分为对称加密和非对称加密，还有一些摘要算法 / 哈希算法，一下是一些常见的加密算法\n类型 示例 是否可逆 说明 对称加密 DES / AES / 3DES ✅ 加密解密用同一密钥 非对称加密 RSA / ECC ✅ 公钥加密，私钥解密 摘要算法 MD5 / SHA256 ❌ 不可逆，用于校验完整性 签名算法 DSA / RSA签名 ❌ 用私钥签名，公钥验签 服务器端生成密钥对，将公钥发送给客户端，客户端使用公钥加密对称加密使用的秘钥，发送给服务器端，服务器端使用私钥解密数据， 得到秘钥，后续通过这个秘钥对数据进行加密解密。\nCA CA（Certificate Authority）是证书颁发机构，它负责签发证书，并管理证书的颁发和吊销。\n为什么需要CA 客户端无法知晓拿到的公钥是由目标服务器颁发的，为了验证证书的合法性，防护中间人攻击，需要CA证书颁发机构签发证书。\n证书生成 首先，服务器管理员会向CA提起证书申请，CA会验证域名的所属权，做法通常是在域名解析加一个特定值。 验证通过后，CA会将服务器的公钥用自己的私钥进行签名，生成证书。并颁发给服务器管理员。\n证书验证过程 客户端发起连接请求，服务器会返回证书，客户端会验证证书的合法性，并获取证书的公钥。 浏览器会在发版的时候将各大CA机构的公钥预制在浏览器中，使用CA的公钥对服务器的证书进行解密，拿到解密的hash值。同时 使用同样的摘要算法对原始内容进行加密，用得到的摘要和解密的摘要对比，如果相等，说明证书是CA颁发的，也就证明 了证书的合法性和完整性。\n",
"content": "定义 http http是超文本传输协议，用于传输网页内容，它基于TCP，所以是可靠性传输。但是它没有解决数据安全性 方面的问题\nhttp安全方面的问题 http没有对数据进行加密，任何人都可以随意读取这些数据，遭成数据的泄密。 其次没有认证，也就是没有办法知道数据来源的可靠性，攻击者可以中间人攻击来伪造数据 数据完整性，任何人可以读取也可以修改数据 https是什么 https是http的安全版本，https基于ssl，ssl基于tls。http+数据加密+认证+数据完整性就是https。\nhttps怎么解决的这些问题 数据加密 加密算法 加密算法分为对称加密和非对称加密，还有一些摘要算法 / 哈希算法，一下是一些常见的加密算法\n类型 示例 是否可逆 说明 对称加密 DES / AES / 3DES ✅ 加密解密用同一密钥 非对称加密 RSA / ECC ✅ 公钥加密，私钥解密 摘要算法 MD5 / SHA256 ❌ 不可逆，用于校验完整性 签名算法 DSA / RSA签名 ❌ 用私钥签名，公钥验签 服务器端生成密钥对，将公钥发送给客户端，客户端使用公钥加密对称加密使用的秘钥，发送给服务器端，服务器端使用私钥解密数据， 得到秘钥，后续通过这个秘钥对数据进行加密解密。\nCA CA（Certificate Authority）是证书颁发机构，它负责签发证书，并管理证书的颁发和吊销。\n为什么需要CA 客户端无法知晓拿到的公钥是由目标服务器颁发的，为了验证证书的合法性，防护中间人攻击，需要CA证书颁发机构签发证书。\n证书生成 首先，服务器管理员会向CA提起证书申请，CA会验证域名的所属权，做法通常是在域名解析加一个特定值。 验证通过后，CA会将服务器的公钥用自己的私钥进行签名，生成证书。并颁发给服务器管理员。\n证书验证过程 客户端发起连接请求，服务器会返回证书，客户端会验证证书的合法性，并获取证书的公钥。 浏览器会在发版的时候将各大CA机构的公钥预制在浏览器中，使用CA的公钥对服务器的证书进行解密，拿到解密的hash值。同时 使用同样的摘要算法对原始内容进行加密，用得到的摘要和解密的摘要对比，如果相等，说明证书是CA颁发的，也就证明 了证书的合法性和完整性。\n",
"tags":["计算机网络","https"],
"categories":null
},{
"title":"About Me",
"permalink": "http://localhost:1313/about/me/",
"summary": " 三年PHP经验，2年全栈经验，三年golang经验，持续学习中\u0026hellip; ",
"content": " 三年PHP经验，2年全栈经验，三年golang经验，持续学习中\u0026hellip; ",
"tags":null,
"categories":null
},{
"title":"golang的interface和reflect",
"permalink": "http://localhost:1313/posts/go/interfacereflect/",
"summary": "interface 鸭子类型 如果一个东西，走起来像鸭子，叫起来像鸭子，那么我们认为他就是鸭子。也就是说我们关注对象的行为，而不是对象本身。\ngo里面通过接口来达到鸭子类型的效果。\n多态 多态是指同一个操作（函数、方法），在不通的对象的作用下，会有不同的行为。 一般多态有两种实现方式：\n继承和组合，比如java、c++。 接口的形式 在go里面它没有继承的概念，但是go里面有组合。组合式是一种更灵活的方式。 他可以通过组合和重写来实现继承。在调用结构体的方法的时候，会优先调用最近的结构体的方法。 我们推荐在go里通过接口来实现多态，会更加清晰明了。\ngo的interface 定义 go里面的接口是一种复合数据类型。他的底层有2种实现，eface和iface。\n//eface 结构 type eface struct { tab *typtab data unsafe.Pointer } // iface结构 type iface struct { tab *itab data unsafe.Pointer } go里面的所有数据类型都实现了eface,也就是说可以借助interface来表示他的数据类型。 还可以通过interface来定义方法集合 。\ntype A interface { method() } 可能你会有一个疑问，那go是怎么确定interface 到底应该是使用eface 还是 iface呢？ go是在编译阶段就会确定好interface 使用的eface 还是 iface。后面不会改变。\n如何使用 什么时候会使用interface 通过接口来实现解耦合，比如依赖注入、适配器模式。 不确定传入参数的类型，需要在运行时来确定。 使用方法 接口列表 type animal interface { move() } type dog struct {} func (d dog) move() { fmt.Println(\u0026#34;dog moving\u0026#34;) } type cat struct {} func (c cat) move() { fmt.Println(\u0026#34;cat moving\u0026#34;) } func main() { var a animal a = dog{} a.move() a = cat{} // a是结构可以同意调用 a.move() // 接口注入 call(a) // 不确定具体的参数 vat func1 = func(param any) {} func1 = func(param any) { fmt.Println(\u0026#34;call any\u0026#34;, param) } } func call(a animal) { fmt.Println(\u0026#34;call animal \\n\u0026#34;) a.move() } 需要注意的点和坑 使用接口会让编译器无法确定数据类型，导致无法再编译阶段发现类型错误，引发运行时错误。 使用接口会让程序变得难以阅读和理解。 性能会损失大概一倍 reflect unsafe.pointer go语言unsafe包提供了一些函数，可以获取指针，修改指针，获取指针指向的数据，修改指针指向的数据。 简单来讲，go本身不能操作指针，但是提供了reflect包让我们可以操作指针来获得程序的 性能提升。\n",
"content": "interface 鸭子类型 如果一个东西，走起来像鸭子，叫起来像鸭子，那么我们认为他就是鸭子。也就是说我们关注对象的行为，而不是对象本身。\ngo里面通过接口来达到鸭子类型的效果。\n多态 多态是指同一个操作（函数、方法），在不通的对象的作用下，会有不同的行为。 一般多态有两种实现方式：\n继承和组合，比如java、c++。 接口的形式 在go里面它没有继承的概念，但是go里面有组合。组合式是一种更灵活的方式。 他可以通过组合和重写来实现继承。在调用结构体的方法的时候，会优先调用最近的结构体的方法。 我们推荐在go里通过接口来实现多态，会更加清晰明了。\ngo的interface 定义 go里面的接口是一种复合数据类型。他的底层有2种实现，eface和iface。\n//eface 结构 type eface struct { tab *typtab data unsafe.Pointer } // iface结构 type iface struct { tab *itab data unsafe.Pointer } go里面的所有数据类型都实现了eface,也就是说可以借助interface来表示他的数据类型。 还可以通过interface来定义方法集合 。\ntype A interface { method() } 可能你会有一个疑问，那go是怎么确定interface 到底应该是使用eface 还是 iface呢？ go是在编译阶段就会确定好interface 使用的eface 还是 iface。后面不会改变。\n如何使用 什么时候会使用interface 通过接口来实现解耦合，比如依赖注入、适配器模式。 不确定传入参数的类型，需要在运行时来确定。 使用方法 接口列表 type animal interface { move() } type dog struct {} func (d dog) move() { fmt.Println(\u0026#34;dog moving\u0026#34;) } type cat struct {} func (c cat) move() { fmt.Println(\u0026#34;cat moving\u0026#34;) } func main() { var a animal a = dog{} a.move() a = cat{} // a是结构可以同意调用 a.move() // 接口注入 call(a) // 不确定具体的参数 vat func1 = func(param any) {} func1 = func(param any) { fmt.Println(\u0026#34;call any\u0026#34;, param) } } func call(a animal) { fmt.Println(\u0026#34;call animal \\n\u0026#34;) a.move() } 需要注意的点和坑 使用接口会让编译器无法确定数据类型，导致无法再编译阶段发现类型错误，引发运行时错误。 使用接口会让程序变得难以阅读和理解。 性能会损失大概一倍 reflect unsafe.pointer go语言unsafe包提供了一些函数，可以获取指针，修改指针，获取指针指向的数据，修改指针指向的数据。 简单来讲，go本身不能操作指针，但是提供了reflect包让我们可以操作指针来获得程序的 性能提升。\n定义 在计算机领域，反射（Reflection）是指程序在运行时能够检查自身，并获取其内部信息。可以修改数据，调用方法的 一种能力。 go语言提供了一种在运行时能够获取数据本身的状态，数据，和调用方法的能力，在编译阶段 是不知道具体的类型的，需要在运行时确定。\n使用 常见使用场景 函数参数的动态传入，通过reflect获取参数的类型 动态修改切片，map，结构体 动态创建函数 GORM,通过反射获取结构体的tag来构建数据的sql语句 使用方法 reflect.ValueOf(a) reflect.TypeOf((a) 对指针解引用 reflect.ValueOf(a).Elem() 获取指针类型 reflect.TypeOf(a).Elem() 获取tag reflect.TypeOf(a).Elem().Field(0).Tag.Get(\u0026#34;json\u0026#34;) 获取字段 reflect.TypeOf(a).Elem().Field(0) 动态创建函数 func1 := reflect.MakeFunc(reflect.TypeOf(func(param any) {}), func(args []reflect.Value) []reflect.Value {}) // 动态调用函数 func1.Call([]reflect.Value{reflect.ValueOf(param)}) 需要注意的点和坑 使用反射会损失性能 使用反射会改变代码的可读性 编译器不能检查数据类型，会引发运行时错误 ",
"tags":["go","interface","reflect"],
"categories":null
}]